/// <reference types="node" />
import EventEmitter from 'events';
import { JsonRpcPayload } from './payload';
import type { Callback, Connection, EthereumProvider, ProviderError, RequestArguments, JsonRpcResponse, Payload } from './types';
export declare namespace JsonRpc {
    export { JsonRpcPayload as Payload, JsonRpcResponse as Response };
}
export type { EthereumProvider, RequestArguments, ProviderError };
declare class Provider extends EventEmitter implements EthereumProvider {
    private readonly connection;
    private readonly eventHandlers;
    private readonly promises;
    private readonly attemptedSubscriptions;
    private subscriptions;
    private networkVersion?;
    private manualChainId?;
    private providerChainId?;
    private checkConnectionRunning;
    private checkConnectionTimer?;
    private nextId;
    connected: boolean;
    accounts: string[];
    selectedAddress?: string;
    coinbase?: string;
    constructor(connection: Connection);
    get chainId(): string | undefined;
    checkConnection(retryTimeout?: number): Promise<void>;
    private attemptedSubscription;
    private setSubscriptionAttempted;
    startSubscription(event: string): Promise<void>;
    private resumeSubscriptions;
    enable(): Promise<string[]>;
    private doSend;
    send(methodOrPayload: string | JsonRpcPayload, callbackOrArgs: Callback<JsonRpcResponse> | unknown[]): Promise<unknown>;
    private sendBatch;
    subscribe(type: string, method: string, params?: never[]): Promise<string>;
    unsubscribe(type: string, id: string): Promise<true | undefined>;
    sendAsync(rawPayload: JsonRpcPayload | JsonRpcPayload[], cb: Callback<JsonRpcResponse> | Callback<JsonRpcResponse[]>): Promise<void | Error>;
    private sendAsyncBatch;
    isConnected(): boolean;
    close(): void;
    request<T>(payload: Payload): Promise<T>;
    setChain(chainId: string | number): void;
}
export default Provider;
