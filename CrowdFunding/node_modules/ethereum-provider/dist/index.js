"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = __importDefault(require("events"));
const payload_1 = require("./payload");
class Provider extends events_1.default {
    constructor(connection) {
        super();
        this.promises = {};
        this.attemptedSubscriptions = new Set();
        this.subscriptions = [];
        this.checkConnectionRunning = false;
        this.nextId = 1;
        this.connected = false;
        this.accounts = [];
        this.selectedAddress = undefined;
        this.coinbase = undefined;
        this.enable = this.enable.bind(this);
        this.doSend = this.doSend.bind(this);
        this.send = this.send.bind(this);
        this.sendBatch = this.sendBatch.bind(this);
        this.subscribe = this.subscribe.bind(this);
        this.unsubscribe = this.unsubscribe.bind(this);
        this.resumeSubscriptions = this.resumeSubscriptions.bind(this);
        this.sendAsync = this.sendAsync.bind(this);
        this.sendAsyncBatch = this.sendAsyncBatch.bind(this);
        this.isConnected = this.isConnected.bind(this);
        this.close = this.close.bind(this);
        this.request = this.request.bind(this);
        this.connection = connection;
        this.on('connect', this.resumeSubscriptions);
        this.connection.on('connect', () => this.checkConnection(1000));
        this.connection.on('close', () => {
            this.connected = false;
            this.attemptedSubscriptions.clear();
            this.emit('close');
            this.emit('disconnect');
        });
        this.connection.on('payload', payload => {
            const { id, method, error, result } = payload;
            if (typeof id !== 'undefined') {
                if (this.promises[id]) { // Fulfill promise
                    const requestMethod = this.promises[id].method;
                    if (requestMethod && ['eth_accounts', 'eth_requestAccounts'].includes(requestMethod)) {
                        const accounts = result || [];
                        this.accounts = accounts;
                        this.selectedAddress = accounts[0];
                        this.coinbase = accounts[0];
                    }
                    payload.error ? this.promises[id].reject(error) : this.promises[id].resolve(result);
                    delete this.promises[id];
                }
            }
            else if (method && method.indexOf('_subscription') > -1) { // Emit subscription result
                // Events: connect, disconnect, chainChanged, chainsChanged, accountsChanged, assetsChanged, message
                this.emit(payload.params.subscription, payload.params.result);
                this.emit(method, payload.params); // Older EIP-1193
                this.emit('message', {
                    type: payload.method,
                    data: {
                        subscription: payload.params.subscription,
                        result: payload.params.result
                    }
                });
                this.emit('data', payload); // Backwards Compatibility
            }
        });
        this.on('newListener', event => {
            if (Object.keys(this.eventHandlers).includes(event)) {
                if (!this.attemptedSubscription(event) && this.connected) {
                    this.startSubscription(event);
                    if (event === 'networkChanged') {
                        console.warn('The networkChanged event is being deprecated, use chainChanged instead');
                    }
                }
            }
        });
        this.eventHandlers = {
            networkChanged: netId => {
                this.networkVersion = (typeof netId === 'string') ? parseInt(netId) : netId;
                this.emit('networkChanged', this.networkVersion);
            },
            chainChanged: chainId => {
                this.providerChainId = chainId;
                if (!this.manualChainId) {
                    this.emit('chainChanged', chainId);
                }
            },
            chainsChanged: chains => {
                this.emit('chainsChanged', chains);
            },
            accountsChanged: (accounts) => {
                this.selectedAddress = accounts[0];
                this.emit('accountsChanged', accounts);
            },
            assetsChanged: assets => {
                this.emit('assetsChanged', assets);
            }
        };
    }
    get chainId() {
        return this.manualChainId || this.providerChainId;
    }
    async checkConnection(retryTimeout = 4000) {
        if (this.checkConnectionRunning || this.connected)
            return;
        clearTimeout(this.checkConnectionTimer);
        this.checkConnectionTimer = undefined;
        this.checkConnectionRunning = true;
        try {
            this.networkVersion = await this.doSend('net_version', [], undefined, false);
            this.providerChainId = await this.doSend('eth_chainId', [], undefined, false);
            this.connected = true;
        }
        catch (e) {
            this.checkConnectionTimer = setTimeout(() => this.checkConnection(), retryTimeout);
            this.connected = false;
        }
        finally {
            this.checkConnectionRunning = false;
            if (this.connected) {
                this.emit('connect', { chainId: this.providerChainId });
            }
        }
    }
    attemptedSubscription(event) {
        return this.attemptedSubscriptions.has(event);
    }
    setSubscriptionAttempted(event) {
        this.attemptedSubscriptions.add(event);
    }
    async startSubscription(event) {
        console.debug(`starting subscription for ${event} events`);
        this.setSubscriptionAttempted(event);
        try {
            const eventId = await (this.subscribe('eth_subscribe', event));
            this.on(eventId, this.eventHandlers[event]);
        }
        catch (e) {
            console.warn(`Unable to subscribe to ${event}`, e);
        }
    }
    resumeSubscriptions() {
        Object.keys(this.eventHandlers).forEach(event => {
            if (this.listenerCount(event) && !this.attemptedSubscription(event))
                this.startSubscription(event);
        });
    }
    async enable() {
        const accounts = await this.doSend('eth_accounts');
        if (accounts.length > 0) {
            this.accounts = accounts;
            this.selectedAddress = accounts[0];
            this.coinbase = accounts[0];
            this.emit('enable');
            return accounts;
        }
        else {
            const err = new Error('User Denied Full Provider');
            err.code = '4001';
            throw err;
        }
    }
    doSend(rawPayload, rawParams = [], targetChain = this.manualChainId, waitForConnection = true) {
        const sendFn = (resolve, reject) => {
            const method = (typeof rawPayload === 'object') ? rawPayload.method : rawPayload;
            const params = (typeof rawPayload === 'object') ? rawPayload.params : rawParams;
            const chainTarget = ((typeof rawPayload === 'object') && rawPayload.chainId) || targetChain;
            if (!method) {
                return reject(new Error('Method is not a valid string.'));
            }
            try {
                const payload = (0, payload_1.create)(method, params, this.nextId++, chainTarget);
                this.promises[payload.id] = {
                    resolve: (result) => resolve(result),
                    reject,
                    method: payload.method
                };
                this.connection.send(payload);
            }
            catch (e) {
                reject(e);
            }
        };
        if (this.connected || !waitForConnection) {
            return new Promise(sendFn);
        }
        return new Promise((resolve, reject) => {
            const resolveSend = () => {
                clearTimeout(disconnectTimer);
                return resolve(new Promise(sendFn));
            };
            const disconnectTimer = setTimeout(() => {
                this.off('connect', resolveSend);
                reject(new Error('Not connected'));
            }, 5000);
            this.once('connect', resolveSend);
        });
    }
    async send(methodOrPayload, callbackOrArgs) {
        if (typeof methodOrPayload === 'string' &&
            (!callbackOrArgs || Array.isArray(callbackOrArgs))) {
            const params = callbackOrArgs;
            return this.doSend(methodOrPayload, params);
        }
        if (methodOrPayload &&
            typeof methodOrPayload === 'object' &&
            typeof callbackOrArgs === 'function') {
            // a callback was passed to send(), forward everything to sendAsync()
            const cb = callbackOrArgs;
            return this.sendAsync(methodOrPayload, cb);
        }
        return this.request(methodOrPayload);
    }
    sendBatch(requests) {
        return Promise.all(requests.map(payload => {
            return this.doSend(payload.method, payload.params);
        }));
    }
    async subscribe(type, method, params = []) {
        const id = await this.doSend(type, [method, ...params]);
        this.subscriptions.push(id);
        return id;
    }
    async unsubscribe(type, id) {
        const success = await this.doSend(type, [id]);
        if (success) {
            this.subscriptions = this.subscriptions.filter(_id => _id !== id); // Remove subscription
            this.removeAllListeners(id); // Remove listeners
            return success;
        }
    }
    async sendAsync(rawPayload, cb) {
        if (!cb || typeof cb !== 'function')
            return new Error('Invalid or undefined callback provided to sendAsync');
        if (!rawPayload)
            return cb(new Error('Invalid Payload'));
        // sendAsync can be called with an array for batch requests used by web3.js 0.x
        // this is not part of EIP-1193's backwards compatibility but we still want to support it
        if (Array.isArray(rawPayload)) {
            const payloads = rawPayload.map(p => ({ ...p, jsonrpc: '2.0' }));
            const callback = cb;
            return this.sendAsyncBatch(payloads, callback);
        }
        else {
            const payload = { ...rawPayload, jsonrpc: '2.0' };
            const callback = cb;
            try {
                const result = await this.doSend(payload.method, payload.params);
                callback(null, { id: payload.id, jsonrpc: payload.jsonrpc, result });
            }
            catch (e) {
                callback(e);
            }
        }
    }
    async sendAsyncBatch(payloads, cb) {
        try {
            const results = await this.sendBatch(payloads);
            const result = results.map((entry, index) => {
                return { id: payloads[index].id, jsonrpc: payloads[index].jsonrpc, result: entry };
            });
            cb(null, result);
        }
        catch (e) {
            cb(e);
        }
    }
    isConnected() {
        return this.connected;
    }
    close() {
        if (this.connection && this.connection.close)
            this.connection.close();
        this.off('connect', this.resumeSubscriptions);
        this.connected = false;
        const error = new Error('Provider closed, subscription lost, please subscribe again.');
        this.subscriptions.forEach(id => this.emit(id, error)); // Send Error objects to any open subscriptions
        this.subscriptions = []; // Clear subscriptions
        this.manualChainId = undefined;
        this.providerChainId = undefined;
        this.networkVersion = undefined;
        this.selectedAddress = undefined;
        this.coinbase = undefined;
    }
    async request(payload) {
        return this.doSend(payload.method, payload.params, payload.chainId);
    }
    setChain(chainId) {
        if (typeof chainId === 'number')
            chainId = '0x' + chainId.toString(16);
        const chainChanged = (chainId !== this.chainId);
        this.manualChainId = chainId;
        if (chainChanged) {
            this.emit('chainChanged', this.chainId);
        }
    }
}
exports.default = Provider;
