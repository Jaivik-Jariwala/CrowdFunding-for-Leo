var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import React, { createContext, useEffect, useState } from "react";
import { useEndpoints } from "./hooks/useEndpoints";
import { useNetwork } from "./hooks/useNetwork";
import { useInjection } from "./hooks/useInjection";
import { useSigner } from "./hooks/useSigner";
import { defaultApiOption } from "./utils/createFallbackProvider";
import { ethers } from "ethers";
import { defaultNetworks, knownNetworks } from "./utils/createNetworkInterface";
export const Context = createContext({});
export const EVMContext = ({ children, defaultConnectionType = window.localStorage.getItem("network-to-initialize") === null
    ? "not initialized"
    : "endpoints", autoRefresh = true, customNetworks = [], chainId = Number(window.localStorage.getItem("network-to-initialize")) || 4, apiKeys = defaultApiOption, }) => {
    if (window.localStorage.getItem("network-to-initialize") !== null) {
        chainId = Number(window.localStorage.getItem("network-to-initialize"));
    }
    // Connection type
    const [connectionType, setConnectionType] = useState(defaultConnectionType);
    // Auto refresh
    const [autoRefreshActive, setAutoRefreshActive] = useState(autoRefresh);
    // Void Signer
    const [voidSigner, setVoidSigner] = useState(false);
    // haveWebExtension
    const [haveWebExtension, setHaveWebExtension] = useState(false);
    // provider
    const [provider, setProvider] = useState(null);
    const [network, setNetwork] = useState({});
    const [account, setAccount] = useState({});
    function launchConnection(_connectionType) {
        if (!provider) {
            setConnectionType(_connectionType);
        }
        else {
            console.warn("Connection type cannot be changed once the provider is set, you should reload the page");
        }
    }
    function setAutoRefresh(setTo) {
        setProvider((p) => {
            if (p !== null) {
                if (setTo) {
                    if (p.listeners("block").length === 0) {
                        console.log("listerners added");
                        setAutoRefreshActive(true);
                        return p.on("block", (blockNumber) => __awaiter(this, void 0, void 0, function* () {
                            console.log(`Block nÂ°${blockNumber} emitted on ${network.name} (${network.chainId})`);
                            setNetwork((n) => {
                                n.blockHeight = blockNumber;
                                return n;
                            });
                        }));
                    }
                    else {
                        return p;
                    }
                }
                else {
                    console.log("listerners removed");
                    setAutoRefreshActive(false);
                    return p.removeAllListeners("block");
                }
            }
            else {
                return p;
            }
        });
    }
    function switchNetwork(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            const paddedChainId = "0x" + Number(chainId.toString()).toString(16); // thanks javascript
            if (connectionType === "endpoints") {
                window.localStorage.setItem("network-to-initialize", paddedChainId);
                window.location.reload();
            }
            else if (connectionType === "injected") {
                const request = provider.provider.request;
                if (request)
                    request({
                        method: "wallet_switchEthereumChain",
                        params: [{ chainId: paddedChainId }],
                    });
            }
            else {
                console.warn("Connect to provider to use this method");
            }
        });
    }
    function loginToInjected() {
        return __awaiter(this, void 0, void 0, function* () {
            if (connectionType === "injected") {
                const request = provider.provider.request;
                if (request) {
                    const account = yield request({
                        method: "eth_requestAccounts",
                    });
                    console.log(`Account: ${account[0]} is connected`);
                }
            }
        });
    }
    function createVoidSigner(address) {
        return __awaiter(this, void 0, void 0, function* () {
            if (address.length !== 42 && !address.startsWith("0x")) {
                console.warn("Wrong address format");
            }
            else if (account.address) {
                console.warn("Disconnect accounts from your extensions, or delete existant void signer");
            }
            else {
                if (provider) {
                    const signer = new ethers.VoidSigner(ethers.utils.getAddress(address.toLowerCase()), provider);
                    const addressSummed = yield signer.getAddress();
                    const balance = (yield signer.getBalance()).toString();
                    setAccount({
                        address: addressSummed,
                        balance,
                        walletType: "void signer (watch only)",
                        isLogged: true,
                        signer: signer,
                    });
                    setVoidSigner(true);
                }
            }
        });
    }
    function deleteVoidSigner() {
        setVoidSigner(false);
    }
    function getNetworkList() {
        let list = [];
        list = list.concat(defaultNetworks);
        list = list.concat(knownNetworks);
        list = list.concat(customNetworks);
        return list;
    }
    useEffect(() => {
        try {
            setTimeout(() => {
                const ethereum = window.ethereum;
                setHaveWebExtension(ethereum ? true : false);
            }, 3000);
        }
        catch (e) {
            console.warn("You don't have any web extension to connect to the dApp");
        }
    }, []);
    useEndpoints(connectionType, setProvider, provider, chainId, customNetworks, apiKeys);
    useInjection(connectionType, setProvider, setAccount, provider);
    useNetwork(setProvider, setNetwork, provider, autoRefreshActive, chainId, customNetworks);
    useSigner(setAccount, provider, network, voidSigner);
    return (React.createElement(Context.Provider, { value: {
            connectionType,
            autoRefreshActive,
            haveWebExtension,
            provider,
            methods: {
                launchConnection,
                setAutoRefresh,
                switchNetwork,
                loginToInjected,
                createVoidSigner,
                deleteVoidSigner,
                getNetworkList,
            },
            network,
            account,
        } }, children));
};
