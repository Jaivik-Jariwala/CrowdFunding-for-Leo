{"version":3,"sources":["../src/constants/settings.ts","../src/interfaces/Auth.ts","../src/interfaces/EmbeddedWallets/EmbeddedWallets.ts","../src/utils/iFrameCommunication/EmbeddedWalletIframeCommunicator.ts","../src/utils/Storage/LocalStorage.ts","../src/utils/iFrameCommunication/IframeCommunicator.ts","../src/lib/Auth/AbstractLogin.ts","../src/lib/Auth/AwsManagedLogin.ts","../src/lib/Auth/UserManagedLogin.ts","../src/lib/Auth/index.ts","../src/lib/EmbeddedWallets/EmbeddedWallet.ts","../src/lib/EmbeddedWallets/GaslessTransactionMaker.ts","../src/lib/EmbeddedWallets/Signer.ts","../src/lib/Paper.ts"],"names":["EMBEDDED_WALLET_PATH","WALLET_USER_ID_LOCAL_STORAGE_NAME","clientId","AUTH_TOKEN_LOCAL_STORAGE_PREFIX","AUTH_TOKEN_LOCAL_STORAGE_NAME","DEVICE_SHARE_LOCAL_STORAGE_PREFIX","DEVICE_SHARE_LOCAL_STORAGE_NAME","userId","DEVICE_SHARE_LOCAL_STORAGE_NAME_DEPRECATED","RecoveryShareManagement","AuthProvider","UserStatus","UserWalletStatus","getPaperOriginUrl","data","LocalStorage","key","__async","_a","value","item","cookie","share","sleep","seconds","resolve","iframeBaseStyle","isIframeLoaded","IframeCommunicator","link","iframeId","container","iframeStyles","onIframeInitialize","iframe","hrefLink","sdkVersion","mergedIframeStyles","__spreadValues","prePostMessageSleepInSeconds","res","rej","channel","event","INIT_IFRAME_EVENT","_0","procedureName","params","showIframe","injectRecoveryCode","injectRecoveryCodeListener","e","_b","recoveryCode","EmbeddedWalletIframeCommunicator","customizationOptions","EMBEDDED_WALLET_IFRAME_ID","createEmbeddedWalletIframeLink","localStorage","path","queryParams","embeddedWalletUrl","queryKey","AbstractLogin","querier","preLogin","postLogin","email","recoveryShareManagement","isNewUser","isNewDevice","AwsManagedLogin","result","otp","UserManagedLogin","args","Auth","advancedOptions","onAuthSuccess","storedToken","walletDetails","token","authProvider","success","isRemoveAuthCookie","isRemoveUserId","getDefaultProvider","ChainToPublicRpc","GaslessTransactionMaker","chain","contractAddress","methodArgs","methodInterface","Signer","defineReadOnly","EthersSigner","provider","address","message","_c","_d","network","signedMessage","transaction","signedTransaction","domain","types","signedTypedData","EmbeddedWallet","deviceShareStored","walletAddress","isIframeStorageEnabled","walletUserId","userStatus","__spreadProps","PaperEmbeddedWalletSdk","styles","authResult"],"mappings":"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","sourcesContent":["export const EMBEDDED_WALLET_PATH = \"/sdk/2022-08-12/embedded-wallet\";\n\nexport const WALLET_USER_ID_LOCAL_STORAGE_NAME = (clientId: string) =>\n  `paperEwsWalletUserId-${clientId}`;\nconst AUTH_TOKEN_LOCAL_STORAGE_PREFIX = \"walletToken\";\nexport const AUTH_TOKEN_LOCAL_STORAGE_NAME = (clientId: string) => {\n  return `${AUTH_TOKEN_LOCAL_STORAGE_PREFIX}-${clientId}`;\n};\nconst DEVICE_SHARE_LOCAL_STORAGE_PREFIX = \"a\";\nexport const DEVICE_SHARE_LOCAL_STORAGE_NAME = (\n  clientId: string,\n  userId: string,\n) => `${DEVICE_SHARE_LOCAL_STORAGE_PREFIX}-${clientId}-${userId}`;\nexport const DEVICE_SHARE_LOCAL_STORAGE_NAME_DEPRECATED = (clientId: string) =>\n  `${DEVICE_SHARE_LOCAL_STORAGE_PREFIX}-${clientId}`;\n","import type {\n  AuthDetails,\n  InitializedUser,\n  SetUpWalletRpcReturnType,\n} from \"./EmbeddedWallets/EmbeddedWallets\";\n\nexport enum RecoveryShareManagement {\n  USER_MANAGED = \"USER_MANAGED\",\n  AWS_MANAGED = \"AWS_MANAGED\",\n}\n\nexport type AdvancedOptions<T extends RecoveryShareManagement > = {\n  // This is a hack to allow us to assign default value to recoveryShareManagement\n  recoveryShareManagement: RecoveryShareManagement | T\n};\n\nexport enum AuthProvider {\n  PAPER_EMAIL_OTP = \"PaperEmailOTP\",\n  GOOGLE = \"Google\",\n  TWITTER = \"Twitter\",\n  COGNITO = \"Cognito\",\n  AUTH0 = \"Auth0\",\n  CUSTOM_JWT = \"CustomJWT\",\n}\n\nexport type GetSocialLoginClientIdReturnType = {\n  clientId: string;\n};\n\n// TODO: Clean up tech debt of random type Objects\n// E.g. StoredTokenType is really not used anywhere but it exists as this object for legacy reason\nexport type StoredTokenType = {\n  jwtToken: string;\n  authProvider: AuthProvider;\n  authDetails: AuthDetails;\n  developerClientId: string;\n};\n\nexport type AuthStoredTokenWithCookieReturnType = {\n  storedToken: StoredTokenType & {\n    cookieString: string;\n    shouldStoreCookieString: boolean;\n    isNewUser: boolean;\n  };\n};\nexport type AuthAndWalletRpcReturnType = AuthStoredTokenWithCookieReturnType & {\n  walletDetails: SetUpWalletRpcReturnType;\n};\n\nexport type AuthLoginReturnType = { user: InitializedUser };\n","import type {\n  Chain,\n  CustomizationOptionsType,\n} from \"@paperxyz/sdk-common-utilities\";\nimport type { EmbeddedWallet } from \"../../lib/EmbeddedWallets/EmbeddedWallet\";\nimport type { EmbeddedWalletIframeCommunicator } from \"../../utils/iFrameCommunication/EmbeddedWalletIframeCommunicator\";\nimport type { AdvancedOptions, RecoveryShareManagement } from \"../Auth\";\n\n// Class constructor types\n// types for class constructors still a little messy right now.\n// Open to PRs from whoever sees this and knows of a cleaner way to handle things\nexport type ClientIdConstructorType = { clientId: string };\nexport type PaperConstructorType<T extends RecoveryShareManagement> = ClientIdConstructorType & {\n  chain: Chain;\n  advancedOptions?: Partial<AdvancedOptions<T>>;\n  styles?: CustomizationOptionsType;\n};\nexport type ClientIdWithQuerierType = ClientIdConstructorType & {\n  querier: EmbeddedWalletIframeCommunicator<any>;\n};\nexport type ClientIdWithQuerierAndChainType = ClientIdWithQuerierType & {\n  chain: Chain;\n};\n\n// Auth Types\nexport type AuthDetails = {\n  email?: string;\n  userWalletId: string;\n  recoveryCode?: string;\n};\n\nexport type InitializedUser = {\n  status: UserStatus.LOGGED_IN_WALLET_INITIALIZED;\n  wallet: EmbeddedWallet;\n  walletAddress: string;\n  authDetails: AuthDetails;\n};\n\n// Embedded Wallet Types\nexport enum UserStatus {\n  LOGGED_OUT = \"Logged Out\",\n  LOGGED_IN_WALLET_INITIALIZED = \"Logged In, Wallet Initialized\",\n}\nexport enum UserWalletStatus {\n  LOGGED_OUT = \"Logged Out\",\n  LOGGED_IN_WALLET_UNINITIALIZED = \"Logged In, Wallet Uninitialized\",\n  LOGGED_IN_NEW_DEVICE = \"Logged In, New Device\",\n  LOGGED_IN_WALLET_INITIALIZED = \"Logged In, Wallet Initialized\",\n}\n\nexport type WalletAddressObjectType = {\n  walletAddress: string;\n};\n\nexport type SetUpWalletRpcReturnType = WalletAddressObjectType & {\n  deviceShareStored: string;\n  isIframeStorageEnabled: boolean;\n};\n\nexport type SendEmailOtpReturnType = {\n  isNewUser: boolean;\n  isNewDevice: boolean;\n};\nexport type LogoutReturnType = { success: boolean };\nexport type GetAuthDetailsReturnType = { authDetails?: AuthDetails };\n\n// ! Types seem repetitive, but the name should identify which goes where\n// this is the return type from the EmbeddedWallet Class getUserWalletStatus method iframe call\nexport type GetUserWalletStatusRpcReturnType =\n  | {\n      status: UserWalletStatus.LOGGED_OUT;\n      user: undefined;\n    }\n  | {\n      status: UserWalletStatus.LOGGED_IN_WALLET_UNINITIALIZED;\n      user: { authDetails: AuthDetails };\n    }\n  | {\n      status: UserWalletStatus.LOGGED_IN_NEW_DEVICE;\n      user: { authDetails: AuthDetails; walletAddress: string };\n    }\n  | {\n      status: UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED;\n      user: Omit<InitializedUser, \"wallet\" | \"status\">;\n    };\n\n// this is the return type from the EmbeddedWallet Class getUserWalletStatus method\nexport type GetUserWalletStatusFnReturnType =\n  | {\n      status: UserWalletStatus.LOGGED_OUT;\n      user: undefined;\n    }\n  | {\n      status: UserWalletStatus.LOGGED_IN_WALLET_UNINITIALIZED;\n      user: { authDetails: AuthDetails };\n    }\n  | {\n      status: UserWalletStatus.LOGGED_IN_NEW_DEVICE;\n      user: { authDetails: AuthDetails; walletAddress: string };\n    }\n  | {\n      status: UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED;\n      user: Omit<InitializedUser, \"status\">;\n    };\n\n// This is returned from the getUser method in PaperEmbeddedWalletSdk\nexport type GetUser =\n  | {\n      status: UserStatus.LOGGED_OUT;\n    }\n  | InitializedUser;\n","import type { CustomizationOptionsType } from \"@paperxyz/sdk-common-utilities\";\nimport { getPaperOriginUrl } from \"@paperxyz/sdk-common-utilities\";\nimport { EMBEDDED_WALLET_PATH } from \"../../constants/settings\";\nimport { LocalStorage } from \"../Storage/LocalStorage\";\nimport { IframeCommunicator } from \"./IframeCommunicator\";\n\nexport class EmbeddedWalletIframeCommunicator<\n  T extends { [key: string]: any },\n> extends IframeCommunicator<T> {\n  clientId: string;\n  constructor({\n    clientId,\n    customizationOptions,\n  }: {\n    clientId: string;\n    customizationOptions?: CustomizationOptionsType;\n  }) {\n    super({\n      iframeId: EMBEDDED_WALLET_IFRAME_ID,\n      link: createEmbeddedWalletIframeLink({\n        clientId,\n        path: EMBEDDED_WALLET_PATH,\n        queryParams: customizationOptions,\n      }).href,\n      container: document.body,\n    });\n    this.clientId = clientId;\n  }\n\n  override async onIframeLoadedInitVariables() {\n    const localStorage = new LocalStorage({\n      clientId: this.clientId,\n    });\n\n    return {\n      authCookie: await localStorage.getAuthCookie(),\n      deviceShareStored: await localStorage.getDeviceShare(),\n      walletUserId: await localStorage.getWalletUserId(),\n      clientId: this.clientId,\n    };\n  }\n}\n\n// This is the URL and ID tag of the iFrame that we communicate with\nexport function createEmbeddedWalletIframeLink({\n  clientId,\n  path,\n  queryParams,\n}: {\n  clientId: string;\n  path: string;\n  queryParams?: { [key: string]: string | number };\n}) {\n  const embeddedWalletUrl = new URL(path, getPaperOriginUrl());\n  if (queryParams) {\n    for (const queryKey of Object.keys(queryParams)) {\n      embeddedWalletUrl.searchParams.set(\n        queryKey,\n        queryParams[queryKey]?.toString() || \"\",\n      );\n    }\n  }\n  embeddedWalletUrl.searchParams.set(\"clientId\", clientId);\n  return embeddedWalletUrl;\n}\nexport const EMBEDDED_WALLET_IFRAME_ID = \"paper-embedded-wallet-iframe\";\n","import {\n  AUTH_TOKEN_LOCAL_STORAGE_NAME,\n  DEVICE_SHARE_LOCAL_STORAGE_NAME,\n  WALLET_USER_ID_LOCAL_STORAGE_NAME,\n} from \"../../constants/settings\";\n\nconst data = new Map<string, string>();\n\nexport class LocalStorage {\n  protected isSupported: boolean;\n  protected clientId: string;\n  constructor({ clientId }: { clientId: string }) {\n    this.isSupported = typeof window !== \"undefined\" && !!window.localStorage;\n    this.clientId = clientId;\n  }\n\n  protected async getItem(key: string): Promise<string | null> {\n    if (this.isSupported) {\n      return window.localStorage.getItem(key);\n    } else {\n      return data.get(key) ?? null;\n    }\n  }\n\n  protected async setItem(key: string, value: string): Promise<void> {\n    if (this.isSupported) {\n      return window.localStorage.setItem(key, value);\n    } else {\n      data.set(key, value);\n    }\n  }\n\n  protected async removeItem(key: string): Promise<boolean> {\n    const item = await this.getItem(key);\n    if (this.isSupported && item) {\n      window.localStorage.removeItem(key);\n      return true;\n    }\n    return false;\n  }\n\n  async saveAuthCookie(cookie: string): Promise<void> {\n    await this.setItem(AUTH_TOKEN_LOCAL_STORAGE_NAME(this.clientId), cookie);\n  }\n  async getAuthCookie(): Promise<string | null> {\n    return this.getItem(AUTH_TOKEN_LOCAL_STORAGE_NAME(this.clientId));\n  }\n  async removeAuthCookie(): Promise<boolean> {\n    return this.removeItem(AUTH_TOKEN_LOCAL_STORAGE_NAME(this.clientId));\n  }\n\n  async saveDeviceShare(share: string, userId: string): Promise<void> {\n    await this.saveWalletUserId(userId);\n    await this.setItem(\n      DEVICE_SHARE_LOCAL_STORAGE_NAME(this.clientId, userId),\n      share,\n    );\n  }\n  async getDeviceShare(): Promise<string | null> {\n    const userId = await this.getWalletUserId();\n    if (userId) {\n      return this.getItem(\n        DEVICE_SHARE_LOCAL_STORAGE_NAME(this.clientId, userId),\n      );\n    }\n    return null;\n  }\n  async removeDeviceShare(): Promise<boolean> {\n    const userId = await this.getWalletUserId();\n    if (userId) {\n      return this.removeItem(\n        DEVICE_SHARE_LOCAL_STORAGE_NAME(this.clientId, userId),\n      );\n    }\n    return false;\n  }\n\n  async getWalletUserId(): Promise<string | null> {\n    return this.getItem(WALLET_USER_ID_LOCAL_STORAGE_NAME(this.clientId));\n  }\n  async saveWalletUserId(userId: string): Promise<void> {\n    await this.setItem(\n      WALLET_USER_ID_LOCAL_STORAGE_NAME(this.clientId),\n      userId,\n    );\n  }\n  async removeWalletUserId(): Promise<boolean> {\n    return this.removeItem(WALLET_USER_ID_LOCAL_STORAGE_NAME(this.clientId));\n  }\n}\n","import type { MessageType, StyleObject } from \"@paperxyz/sdk-common-utilities\";\nimport { getPaperOriginUrl } from \"@paperxyz/sdk-common-utilities\";\nimport { EMBEDDED_WALLET_PATH } from \"../../constants/settings\";\n\ntype IFrameCommunicatorProps = {\n  link: string;\n  iframeId: string;\n  container?: HTMLElement;\n  iframeStyles?: StyleObject;\n  onIframeInitialize?: () => void;\n};\n\nfunction sleep(seconds: number) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, seconds * 1000);\n  });\n}\n\nconst iframeBaseStyle = {\n  height: \"100%\",\n  width: \"100%\",\n  border: \"none\",\n  backgroundColor: \"transparent\",\n  colorScheme: \"light\",\n  position: \"fixed\",\n  top: \"0px\",\n  right: \"0px\",\n  zIndex: \"2147483646\",\n  display: \"none\",\n};\n\n// Global var to help track iframe state\nconst isIframeLoaded = new Map<string, boolean>();\n\nexport class IframeCommunicator<T extends { [key: string]: any }> {\n  private iframe: HTMLIFrameElement;\n  private POLLING_INTERVAL_SECONDS = 1.4;\n  private POST_LOAD_BUFFER_SECONDS = 1;\n\n  constructor({\n    link,\n    iframeId,\n    container = document.body,\n    iframeStyles,\n    onIframeInitialize,\n  }: IFrameCommunicatorProps) {\n    // Creating the IFrame element for communication\n    let iframe = document.getElementById(iframeId) as HTMLIFrameElement | null;\n    const hrefLink = new URL(link);\n    const sdkVersion = process.env.SDK_VERSION;\n    if (!sdkVersion) {\n      throw new Error(\"Missing SDK_VERSION env var\");\n    }\n    hrefLink.searchParams.set(\"sdkVersion\", sdkVersion);\n    if (!iframe || iframe.src != hrefLink.href) {\n      // ! Do not update the hrefLink here or it'll cause multiple re-renders\n      if (!iframe) {\n        iframe = document.createElement(\"iframe\");\n        const mergedIframeStyles = {\n          ...iframeBaseStyle,\n          ...iframeStyles,\n        };\n        Object.assign(iframe.style, mergedIframeStyles);\n        iframe.setAttribute(\"id\", iframeId);\n        iframe.setAttribute(\"fetchpriority\", \"high\");\n        container.appendChild(iframe);\n      }\n      iframe.src = hrefLink.href;\n      iframe.setAttribute(\"data-version\", sdkVersion);\n      iframe.onload = this.onIframeLoadHandler(\n        iframe,\n        this.POST_LOAD_BUFFER_SECONDS,\n        onIframeInitialize,\n      );\n    }\n    this.iframe = iframe;\n  }\n\n  protected async onIframeLoadedInitVariables(): Promise<Record<string, any>> {\n    return {};\n  }\n\n  onIframeLoadHandler(\n    iframe: HTMLIFrameElement,\n    prePostMessageSleepInSeconds: number,\n    onIframeInitialize?: () => void,\n  ) {\n    return async () => {\n      const promise = new Promise<boolean>(async (res, rej) => {\n        const channel = new MessageChannel();\n        channel.port1.onmessage = (event: MessageEvent<MessageType<void>>) => {\n          const { data } = event;\n          channel.port1.close();\n          if (!data.success) {\n            return rej(new Error(data.error));\n          }\n          isIframeLoaded.set(iframe.src, true);\n          if (onIframeInitialize) {\n            onIframeInitialize();\n          }\n          return res(true);\n        };\n        // iFrame takes a bit of time after loading to be ready for message receiving\n        // This is hacky\n        await sleep(prePostMessageSleepInSeconds);\n        const INIT_IFRAME_EVENT = \"initIframe\";\n        iframe?.contentWindow?.postMessage(\n          // ? We initialise the iframe with a bunch\n          // of useful information so that we don't have to pass it\n          // through in each of the future call. This would be where we do it.\n          {\n            eventType: INIT_IFRAME_EVENT,\n            data: await this.onIframeLoadedInitVariables(),\n          },\n          `${getPaperOriginUrl()}${EMBEDDED_WALLET_PATH}`,\n          [channel.port2],\n        );\n      });\n      await promise;\n    };\n  }\n\n  async call<ReturnData>({\n    procedureName,\n    params,\n    showIframe = false,\n    injectRecoveryCode = { isInjectRecoveryCode: false },\n  }: {\n    procedureName: keyof T;\n    params: T[keyof T];\n    showIframe?: boolean;\n    injectRecoveryCode?: {\n      getRecoveryCode?: (userWalletId: string) => Promise<string | undefined>;\n      isInjectRecoveryCode: boolean;\n    };\n  }) {\n    while (!isIframeLoaded.get(this.iframe.src)) {\n      await sleep(this.POLLING_INTERVAL_SECONDS);\n    }\n    if (showIframe) {\n      this.iframe.style.display = \"block\";\n      // magic number to let the display render before performing the animation of the modal in\n      await sleep(0.005);\n    }\n    const promise = new Promise<ReturnData>((res, rej) => {\n      if (injectRecoveryCode.isInjectRecoveryCode) {\n        const injectRecoveryCodeListener = async (\n          e: MessageEvent<{ type: string; userWalletId: string }>,\n        ) => {\n          if (\n            e.origin !== getPaperOriginUrl() ||\n            e.data.type !== \"paper_getRecoveryCode\" ||\n            typeof e.data.userWalletId !== \"string\"\n          ) {\n            return;\n          }\n          const recoveryCode = await injectRecoveryCode.getRecoveryCode?.(\n            e.data.userWalletId,\n          );\n          this.iframe.contentWindow?.postMessage(\n            { type: \"paper_getRecoveryCode_response\", recoveryCode },\n            getPaperOriginUrl(),\n          );\n          window.removeEventListener(\"message\", injectRecoveryCodeListener);\n        };\n        window.addEventListener(\"message\", injectRecoveryCodeListener);\n      }\n\n      const channel = new MessageChannel();\n      channel.port1.onmessage = async (\n        event: MessageEvent<MessageType<ReturnData>>,\n      ) => {\n        const { data } = event;\n        channel.port1.close();\n        if (showIframe) {\n          // magic number to let modal fade out before hiding it\n          await sleep(0.1);\n          this.iframe.style.display = \"none\";\n        }\n        if (!data.success) {\n          rej(new Error(data.error));\n        } else {\n          res(data.data);\n        }\n      };\n      this.iframe.contentWindow?.postMessage(\n        { eventType: procedureName, data: params },\n        `${getPaperOriginUrl()}${EMBEDDED_WALLET_PATH}`,\n        [channel.port2],\n      );\n    });\n    return promise;\n  }\n\n  /**\n   * This has to be called by any iframe that will be removed from the DOM.\n   * Use to make sure that we reset the global loaded state of the particular iframe.src\n   */\n  destroy() {\n    isIframeLoaded.delete(this.iframe.src);\n  }\n}\n","import type {\n  AuthAndWalletRpcReturnType,\n  AuthLoginReturnType,\n  RecoveryShareManagement,\n} from \"../../interfaces/Auth\";\nimport type {\n  ClientIdWithQuerierType,\n  SendEmailOtpReturnType,\n} from \"../../interfaces/EmbeddedWallets/EmbeddedWallets\";\nimport type { EmbeddedWalletIframeCommunicator } from \"../../utils/iFrameCommunication/EmbeddedWalletIframeCommunicator\";\n\ntype LoginQuerierTypes = {\n  loginWithPaperModal:\n    | undefined\n    | { email: string; recoveryCode?: string }\n    | { recoveryShareManagement: RecoveryShareManagement }\n    | { email: string };\n  sendPaperEmailLoginOtp: { email: string; recoveryShareManagement?: RecoveryShareManagement };\n  verifyPaperEmailLoginOtp:\n    | {\n        email: string;\n        otp: string;\n        recoveryCode?: string;\n      }\n    | {\n        email: string;\n        otp: string;\n        recoveryShareManagement: RecoveryShareManagement;\n      };\n};\n\nexport abstract class AbstractLogin<\n  MODAL = void,\n  EMAIL_MODAL extends { email: string } = { email: string },\n  EMAIL_VERIFICATION extends { email: string; otp: string } = {\n    email: string;\n    otp: string;\n  },\n> {\n  protected LoginQuerier: EmbeddedWalletIframeCommunicator<LoginQuerierTypes>;\n  protected preLogin;\n  protected postLogin: (\n    authResults: AuthAndWalletRpcReturnType,\n  ) => Promise<AuthLoginReturnType>;\n\n  /**\n   * Used to manage the user's auth states. This should not be instantiated directly.\n   * Call {@link PaperEmbeddedWalletSdk.auth} instead.\n   *\n   * Authentication settings can be managed via the [authentication settings dashboard](https://withpaper.com/dashboard/embedded-wallets/auth-settings)\n   */\n  constructor({\n    querier,\n    preLogin,\n    postLogin,\n  }: Omit<ClientIdWithQuerierType, \"clientId\"> & {\n    preLogin: () => Promise<void>;\n    postLogin: (\n      authDetails: AuthAndWalletRpcReturnType,\n    ) => Promise<AuthLoginReturnType>;\n  }) {\n    this.LoginQuerier = querier;\n    this.preLogin = preLogin;\n    this.postLogin = postLogin;\n  }\n\n  abstract loginWithPaperModal(args?: MODAL): Promise<AuthLoginReturnType>;\n  abstract loginWithPaperEmailOtp(\n    args: EMAIL_MODAL,\n  ): Promise<AuthLoginReturnType>;\n\n  async sendPaperEmailLoginOtp({\n    email,\n    recoveryShareManagement,\n  }: LoginQuerierTypes[\"sendPaperEmailLoginOtp\"]): Promise<SendEmailOtpReturnType> {\n    await this.preLogin();\n    const { isNewUser, isNewDevice } =\n      await this.LoginQuerier.call<SendEmailOtpReturnType>({\n        procedureName: \"sendPaperEmailLoginOtp\",\n        params: { email, recoveryShareManagement },\n      });\n    return { isNewUser, isNewDevice };\n  }\n\n  abstract verifyPaperEmailLoginOtp(\n    args: EMAIL_VERIFICATION,\n  ): Promise<AuthLoginReturnType>;\n}\n","import type {\n  AuthAndWalletRpcReturnType,\n  AuthLoginReturnType,\n} from \"../../interfaces/Auth\";\nimport { RecoveryShareManagement } from \"../../interfaces/Auth\";\nimport { AbstractLogin } from \"./AbstractLogin\";\n\nexport class AwsManagedLogin extends AbstractLogin<\n  void,\n  { email: string },\n  { email: string; otp: string }\n> {\n  override async loginWithPaperModal(): Promise<AuthLoginReturnType> {\n    await this.preLogin();\n    const result = await this.LoginQuerier.call<AuthAndWalletRpcReturnType>({\n      procedureName: \"loginWithPaperModal\",\n      params: { recoveryShareManagement: RecoveryShareManagement.AWS_MANAGED },\n      showIframe: true,\n      injectRecoveryCode: {\n        isInjectRecoveryCode: true,\n      },\n    });\n    return this.postLogin(result);\n  }\n  override async loginWithPaperEmailOtp({\n    email,\n  }: {\n    email: string;\n  }): Promise<AuthLoginReturnType> {\n    await this.preLogin();\n    const result = await this.LoginQuerier.call<AuthAndWalletRpcReturnType>({\n      procedureName: \"loginWithPaperModal\",\n      params: { email, recoveryShareManagement: RecoveryShareManagement.AWS_MANAGED },\n      showIframe: true,\n      injectRecoveryCode: {\n        isInjectRecoveryCode: true,\n      },\n    });\n    return this.postLogin(result);\n  }\n  override async verifyPaperEmailLoginOtp({\n    email,\n    otp,\n  }: {\n    email: string;\n    otp: string;\n  }): Promise<AuthLoginReturnType> {\n    const result = await this.LoginQuerier.call<AuthAndWalletRpcReturnType>({\n      procedureName: \"verifyPaperEmailLoginOtp\",\n      params: { email, otp, recoveryShareManagement: RecoveryShareManagement.AWS_MANAGED },\n      injectRecoveryCode: {\n        isInjectRecoveryCode: true,\n      },\n    });\n    return this.postLogin(result);\n  }\n}\n","import type {\n  AuthAndWalletRpcReturnType,\n  AuthLoginReturnType,\n} from \"../../interfaces/Auth\";\nimport { AbstractLogin } from \"./AbstractLogin\";\nexport class UserManagedLogin extends AbstractLogin<\n  {\n    getRecoveryCode: (userWalletId: string) => Promise<string | undefined>;\n  },\n  { email: string; recoveryCode?: string },\n  { email: string; otp: string; recoveryCode?: string }\n> {\n  override async loginWithPaperModal(args?: {\n    getRecoveryCode: (userWalletId: string) => Promise<string | undefined>;\n  }): Promise<AuthLoginReturnType> {\n    await this.preLogin();\n    const result = await this.LoginQuerier.call<AuthAndWalletRpcReturnType>({\n      procedureName: \"loginWithPaperModal\",\n      params: undefined,\n      showIframe: true,\n      injectRecoveryCode: {\n        isInjectRecoveryCode: true,\n        getRecoveryCode: args?.getRecoveryCode,\n      },\n    });\n    return this.postLogin(result);\n  }\n  override async loginWithPaperEmailOtp({\n    email,\n    recoveryCode,\n  }: {\n    email: string;\n    recoveryCode?: string | undefined;\n  }): Promise<AuthLoginReturnType> {\n    await this.preLogin();\n    const result = await this.LoginQuerier.call<AuthAndWalletRpcReturnType>({\n      procedureName: \"loginWithPaperModal\",\n      params: { email, recoveryCode },\n      showIframe: true,\n      injectRecoveryCode: {\n        isInjectRecoveryCode: true,\n      },\n    });\n    return this.postLogin(result);\n  }\n  override async verifyPaperEmailLoginOtp({\n    email,\n    otp,\n    recoveryCode,\n  }: {\n    email: string;\n    otp: string;\n    recoveryCode?: string | undefined;\n  }): Promise<AuthLoginReturnType> {\n    const result = await this.LoginQuerier.call<AuthAndWalletRpcReturnType>({\n      procedureName: \"verifyPaperEmailLoginOtp\",\n      params: { email, otp, recoveryCode },\n      injectRecoveryCode: {\n        isInjectRecoveryCode: true,\n      },\n    });\n    return this.postLogin(result);\n  }\n}\n","import type {\n  AdvancedOptions,\n  AuthAndWalletRpcReturnType,\n  AuthLoginReturnType,\n  AuthProvider,\n} from \"../../interfaces/Auth\";\nimport { RecoveryShareManagement } from \"../../interfaces/Auth\";\nimport type {\n  ClientIdWithQuerierType,\n  LogoutReturnType,\n  SendEmailOtpReturnType,\n} from \"../../interfaces/EmbeddedWallets/EmbeddedWallets\";\nimport { LocalStorage } from \"../../utils/Storage/LocalStorage\";\nimport type { EmbeddedWalletIframeCommunicator } from \"../../utils/iFrameCommunication/EmbeddedWalletIframeCommunicator\";\nimport { AwsManagedLogin } from \"./AwsManagedLogin\";\nimport { UserManagedLogin } from \"./UserManagedLogin\";\n\nexport type AuthQuerierTypes = {\n  loginWithJwtAuthCallback: {\n    token: string;\n    authProvider: AuthProvider;\n    recoveryCode?: string;\n  };\n  logout: void;\n  sendPaperEmailLoginOtp: { email: string };\n};\n\nexport class Auth <T extends RecoveryShareManagement = RecoveryShareManagement.USER_MANAGED> {\n  protected advancedOptions: AdvancedOptions<T>;\n  protected clientId: string;\n  protected AuthQuerier: EmbeddedWalletIframeCommunicator<AuthQuerierTypes>;\n  protected localStorage: LocalStorage;\n  protected onAuthSuccess: (\n    authResults: AuthAndWalletRpcReturnType,\n  ) => Promise<AuthLoginReturnType>;\n  public userManagedLogin: UserManagedLogin;\n  public awsManagedLogin: AwsManagedLogin;\n\n  /**\n   * Used to manage the user's auth states. This should not be instantiated directly.\n   * Call {@link PaperEmbeddedWalletSdk.auth} instead.\n   *\n   * Authentication settings can be managed via the [authentication settings dashboard](https://withpaper.com/dashboard/embedded-wallets/auth-settings)\n   * @param {string} params.clientId the clientId associated with the various authentication settings\n   */\n  constructor({\n    clientId,\n    advancedOptions ,\n    querier,\n    onAuthSuccess,\n  }: ClientIdWithQuerierType & {\n    advancedOptions?: Partial<AdvancedOptions<T>>;\n    onAuthSuccess: (\n      authDetails: AuthAndWalletRpcReturnType,\n    ) => Promise<AuthLoginReturnType>;\n  }) {\n    this.clientId = clientId;\n    this.advancedOptions = {\n      recoveryShareManagement : advancedOptions?.recoveryShareManagement ?? RecoveryShareManagement.AWS_MANAGED,\n    };\n    this.AuthQuerier = querier;\n    this.localStorage = new LocalStorage({ clientId });\n    this.onAuthSuccess = onAuthSuccess;\n    this.userManagedLogin = new UserManagedLogin({\n      postLogin: async (result) => {\n        return this.postLogin(result);\n      },\n      preLogin: async () => {\n        await this.preLogin();\n      },\n      querier: querier,\n    });\n    this.awsManagedLogin = new AwsManagedLogin({\n      postLogin: async (result) => {\n        return this.postLogin(result);\n      },\n      preLogin: async () => {\n        await this.preLogin();\n      },\n      querier: querier,\n    });\n  }\n\n  private async preLogin() {\n    await this.logout();\n  }\n\n  private async postLogin({\n    storedToken,\n    walletDetails,\n  }: AuthAndWalletRpcReturnType): Promise<AuthLoginReturnType> {\n    if (storedToken.shouldStoreCookieString) {\n      await this.localStorage.saveAuthCookie(storedToken.cookieString);\n    }\n    const initializedUser = await this.onAuthSuccess({\n      storedToken,\n      walletDetails,\n    });\n    return initializedUser;\n  }\n\n  /**\n   * @description\n   * Used to log the user in with an oauth login flow\n   *\n   * Note that you have to either enable \"Auth0\" or \"Custom JSON Web Token\" in the [auth setting dashboard](https://withpaper.com/dashboard/auth-settings) in order to use this\n   * @param {string} jwtParams.token The associate token from the oauth callback\n   * @param {AuthProvider} jwtParams.provider The Auth provider that is being used\n   * @param {string} jwtParams.recoveryCode This has to be passed in if the user is not logging in for the first time in order for us to decrypt and recover the users wallet\n   * @returns {{user: InitializedUser}} An InitializedUser object containing the user's status, wallet, authDetails, and more\n   */\n  async loginWithJwtAuth({\n    token,\n    authProvider,\n    recoveryCode,\n  }: AuthQuerierTypes[\"loginWithJwtAuthCallback\"]): Promise<AuthLoginReturnType> {\n    await this.preLogin();\n    const result = await this.AuthQuerier.call<AuthAndWalletRpcReturnType>({\n      procedureName: \"loginWithJwtAuthCallback\",\n      params: {\n        token,\n        authProvider,\n        recoveryCode,\n      },\n    });\n    return this.postLogin(result);\n  }\n\n  /**\n   * @description\n   * Used to log the user into their Paper wallet on your platform via a myriad of auth providers\n   *\n   * @example\n   * const Paper = new PaperEmbeddedWalletSdk({clientId: \"YOUR_CLIENT_ID\", chain: \"Polygon\"})\n   * try {\n   *   const user = await Paper.auth.loginWithPaperModal();\n   *   // user is now logged in\n   * } catch (e) {\n   *   // User closed modal or something else went wrong during the authentication process\n   *   console.error(e)\n   * }\n   *\n   * @param {(userWalletId: string) => Promise<string | undefined>} args.getRecoveryCode Only present when using RecoveryShareManagement.USER_MANAGED recovery share management. A function that returns the recovery code for a given userWalletId. \n   * \n   * @returns {{user: InitializedUser}} An InitializedUser object. See {@link PaperEmbeddedWalletSdk.getUser} for more\n   */\n  async loginWithPaperModal(args?: T extends RecoveryShareManagement.AWS_MANAGED? void : Parameters<UserManagedLogin[\"loginWithPaperModal\"]>[0]): Promise<AuthLoginReturnType> {\n    await this.preLogin();\n    if (this.advancedOptions.recoveryShareManagement === RecoveryShareManagement.AWS_MANAGED) {\n      return this.awsManagedLogin.loginWithPaperModal();\n    }\n    return this.userManagedLogin.loginWithPaperModal(args as Parameters<UserManagedLogin[\"loginWithPaperModal\"]>[0]);\n  }\n\n  /**\n   * @description\n   * Used to log the user into their Paper wallet using email OTP\n   *\n   * @example\n   *  // Basic Flow\n   *  const Paper = new PaperEmbeddedWalletSdk({clientId: \"\", chain: \"Polygon\"});\n   *  try {\n   *    // prompts user to enter the code they received\n   *    const user = await Paper.auth.loginWithPaperEmailOtp({ email : \"you@example.com\" });\n   *    // user is now logged in\n   *  } catch (e) {\n   *    // User closed the OTP modal or something else went wrong during the authentication process\n   *    console.error(e)\n   *  }\n   *\n   * @example\n   *  // If you want users to never be prompted for a recovery code.\n   *  const Paper = new PaperEmbeddedWalletSdk({clientId: \"\", chain: \"Polygon\"});\n   *  try {\n   *    const email = \"you@example.com\";\n   *\n   *    // getRecoveryCodeForUser is a function to get a recovery code based on an email\n   *    // you write the function below\n   *    const recoveryCode: string | undefined = await getRecoveryCodeForUser(email);\n   *\n   *    // prompts user to enter the code they received\n   *    // Because you pass in a recovery code wherever possible, for existing users on a new device, they would not be prompted to enter the recovery code flow\n   *    const user = await Paper.auth.loginWithPaperEmailOtp({ email, recoveryCode });\n   *    // user is now logged in\n   *    if (user.authDetails.recoveryCode) {\n   *      // user has a recovery code that you can store to pass in to the function above\n   *      // you write the function below\n   *      await storeRecoveryCodeForUser(email, user.authDetails.recoveryCode);\n   *    }\n   *  } catch (e) {\n   *    // User closed the OTP modal or something else went wrong during the authentication process\n   *    console.error(e)\n   *  }\n   *\n   * @param {string} props.email We will send the email an OTP that needs to be entered in order for them to be logged in.\n   * @param {string} props.recoveryCode Only present when using RecoveryShareManagement.USER_MANAGED recovery share management. Specifies the recoveryCode for the given email. This will set recoveryCode as the code for the user if they are new, or user recoveryCode for the user if they are an existing user\n   * @returns {{user: InitializedUser}} An InitializedUser object. See {@link PaperEmbeddedWalletSdk.getUser} for more\n   */\n  async loginWithPaperEmailOtp(args: T extends RecoveryShareManagement.AWS_MANAGED? Parameters<AwsManagedLogin[\"loginWithPaperEmailOtp\"]>[0] : Parameters<UserManagedLogin[\"loginWithPaperEmailOtp\"]>[0]): Promise<AuthLoginReturnType> {\n    if (this.advancedOptions.recoveryShareManagement === RecoveryShareManagement.AWS_MANAGED) {\n      return this.awsManagedLogin.loginWithPaperEmailOtp({\n        email: args.email,\n      });\n    }\n    return this.userManagedLogin.loginWithPaperEmailOtp(args);\n  }\n\n  /**\n   * @description\n   * A headless way to send the users at {email} an OTP code.\n   * You need to then call {@link Auth.verifyPaperEmailLoginOtp} in order to complete the login process\n   *\n   * @example\n   *  const Paper = new PaperEmbeddedWalletSdk({clientId: \"\", chain: \"Polygon\"});\n   *  // sends user an OTP code\n   * try {\n   *    const { isNewUser } = await Paper.auth.sendPaperEmailLoginOtp({ email : \"you@example.com\" });\n   * } catch(e) {\n   *    // Error Sending user's email an OTP code\n   *    console.error(e);\n   * }\n   *\n   * // Then when your user is ready to verify their OTP\n   * try {\n   *    const user = await Paper.auth.verifyPaperEmailLoginOtp({ email: \"you@example.com\", otp: \"6-DIGIT_CODE_HERE\", recoveryCode: \"Required if user is an existing user. i.e. !isNewUser\"});\n   * } catch(e) {\n   *    // Error verifying the OTP code\n   *    console.error(e)\n   * }\n   *\n   * @param {string} props.email We will send the email an OTP that needs to be entered in order for them to be logged in.\n   * @returns {{ success: boolean, isNewUser: boolean }} Success: indicating if the email was successfully sent (Note the email could still end up in the user's spam folder). IsNewUser indicates if the user is a new user to your platform\n   */\n  async sendPaperEmailLoginOtp({\n    email,\n  }: AuthQuerierTypes[\"sendPaperEmailLoginOtp\"]): Promise<SendEmailOtpReturnType> {\n    if (this.advancedOptions.recoveryShareManagement === RecoveryShareManagement.AWS_MANAGED) {\n      return this.awsManagedLogin.sendPaperEmailLoginOtp({\n        email,\n        recoveryShareManagement: RecoveryShareManagement.AWS_MANAGED,\n      });\n    }\n    return this.userManagedLogin.sendPaperEmailLoginOtp({\n      email,\n    });\n  }\n\n  /**\n   *  @description\n   * Used to verify the otp that the user receives from  Paper\n   *\n   * See {@link Auth.sendPaperEmailLoginOtp} for how the headless call flow looks like. Simply swap out the calls to `loginWithPaperEmailOtp` with `verifyPaperEmailLoginOtp`\n   *\n   * @param {string} props.email We will send the email an OTP that needs to be entered in order for them to be logged in.\n   * @param {string} props.otp The code that the user received in their email\n   * @param {string} props.recoveryCode The code that is first sent to the user when they sign up. Required if user is an existing user. i.e. !isNewUser from return params of {@link Auth.sendPaperEmailLoginOtp}\n   * @returns {{user: InitializedUser}} An InitializedUser object containing the user's status, wallet, authDetails, and more\n   */\n  async verifyPaperEmailLoginOtp(args: T extends RecoveryShareManagement.AWS_MANAGED? Parameters<AwsManagedLogin[\"verifyPaperEmailLoginOtp\"]>[0] : Parameters<UserManagedLogin[\"verifyPaperEmailLoginOtp\"]>[0]) {\n    if (this.advancedOptions.recoveryShareManagement === RecoveryShareManagement.AWS_MANAGED) {\n      return this.awsManagedLogin.verifyPaperEmailLoginOtp(args);\n    }\n    return this.userManagedLogin.verifyPaperEmailLoginOtp(args);\n  }\n\n  /**\n   * @description\n   * Logs any existing user out of their wallet.\n   * @returns {{success: boolean}} true if a user is successfully logged out. false if there's no user currently logged in.\n   */\n  async logout(): Promise<LogoutReturnType> {\n    const { success } = await this.AuthQuerier.call<LogoutReturnType>({\n      procedureName: \"logout\",\n      params: undefined,\n    });\n    const isRemoveAuthCookie = await this.localStorage.removeAuthCookie();\n    const isRemoveUserId = await this.localStorage.removeWalletUserId();\n\n    return {\n      success: success || isRemoveAuthCookie || isRemoveUserId,\n    };\n  }\n}\n","import type { Networkish } from \"@ethersproject/providers\";\nimport { getDefaultProvider } from \"@ethersproject/providers\";\nimport type { Chain } from \"@paperxyz/sdk-common-utilities\";\nimport { ChainToPublicRpc } from \"@paperxyz/sdk-common-utilities\";\nimport type {\n  ClientIdWithQuerierAndChainType,\n  GetUserWalletStatusFnReturnType,\n  GetUserWalletStatusRpcReturnType,\n  SetUpWalletRpcReturnType,\n  WalletAddressObjectType,\n} from \"../../interfaces/EmbeddedWallets/EmbeddedWallets\";\nimport { UserWalletStatus } from \"../../interfaces/EmbeddedWallets/EmbeddedWallets\";\n\nimport type { EmbeddedWalletIframeCommunicator } from \"../../utils/iFrameCommunication/EmbeddedWalletIframeCommunicator\";\nimport { LocalStorage } from \"../../utils/Storage/LocalStorage\";\nimport { GaslessTransactionMaker } from \"./GaslessTransactionMaker\";\nimport { EthersSigner } from \"./Signer\";\n\nexport type WalletManagementTypes = {\n  createWallet: void;\n  setUpNewDevice: void;\n  getUserStatus: void;\n};\nexport type WalletManagementUiTypes = {\n  createWalletUi: void;\n  setUpNewDeviceUi: void;\n};\n\nexport type EmbeddedWalletInternalHelperType = { showUi: boolean };\n\nexport class EmbeddedWallet {\n  protected clientId: string;\n  protected chain: Chain;\n  protected walletManagerQuerier: EmbeddedWalletIframeCommunicator<\n    WalletManagementTypes & WalletManagementUiTypes\n  >;\n  protected localStorage: LocalStorage;\n\n  public gasless: GaslessTransactionMaker;\n\n  /**\n   * Not meant to be initialized directly. Call {@link .initializeUser} to get an instance\n   * @param param0\n   */\n  constructor({ clientId, chain, querier }: ClientIdWithQuerierAndChainType) {\n    this.clientId = clientId;\n    this.chain = chain;\n    this.walletManagerQuerier = querier;\n\n    this.gasless = new GaslessTransactionMaker({\n      chain,\n      clientId,\n      querier,\n    });\n\n    this.localStorage = new LocalStorage({ clientId });\n  }\n\n  /**\n   * @internal\n   * Used to set-up the user device in the case that they are using incognito\n   * @param {string} param.deviceShareStored the value that is saved for the user's device share.\n   * We save this into the localStorage on the site itself if we could not save it within the iframe's localStorage.\n   * This happens in incognito mostly\n   * @param {string} param.walletAddress User's wallet address\n   * @param {boolean} param.isIframeStorageEnabled Tells us if we were able to store values in the localStorage in our iframe.\n   * We need to store it under the dev's domain localStorage if we weren't able to store things in the iframe\n   * @returns {{ walletAddress : string }} The user's wallet details\n   */\n  async postWalletSetUp({\n    deviceShareStored,\n    walletAddress,\n    isIframeStorageEnabled,\n    walletUserId,\n  }: SetUpWalletRpcReturnType & {\n    walletUserId: string;\n  }): Promise<WalletAddressObjectType> {\n    if (!isIframeStorageEnabled) {\n      await this.localStorage.saveDeviceShare(deviceShareStored, walletUserId);\n    }\n    return { walletAddress };\n  }\n\n  /**\n   * @internal\n   * Gets the various status states of the user\n   * @example\n   *  const userStatus = await Paper.getUserWalletStatus();\n   *  switch (userStatus.status) {\n   *  case UserWalletStatus.LOGGED_OUT: {\n   *    // User is logged out, call one of the auth methods on Paper.auth to authenticate the user\n   *    break;\n   *  }\n   *  case UserWalletStatus.LOGGED_IN_WALLET_UNINITIALIZED: {\n   *    // User is logged in, but does not have a wallet associated with it\n   *    // you also have access to the user's details\n   *    userStatus.user.authDetails;\n   *    break;\n   *  }\n   *  case UserWalletStatus.LOGGED_IN_NEW_DEVICE: {\n   *    // User is logged in and created a wallet already, but is missing the device shard\n   *    // You have access to:\n   *    userStatus.user.authDetails;\n   *    userStatus.user.walletAddress;\n   *    break;\n   *  }\n   *  case UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED: {\n   *    // user is logged in and wallet is all set up.\n   *    // You have access to:\n   *    userStatus.user.authDetails;\n   *    userStatus.user.walletAddress;\n   *    userStatus.user.wallet;\n   *    break;\n   *  }\n   *}\n   * @returns {GetUserWalletStatusFnReturnType} an object to containing various information on the user statuses\n   */\n  async getUserWalletStatus(): Promise<GetUserWalletStatusFnReturnType> {\n    const userStatus =\n      await this.walletManagerQuerier.call<GetUserWalletStatusRpcReturnType>({\n        procedureName: \"getUserStatus\",\n        params: undefined,\n      });\n    if (userStatus.status === UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED) {\n      return {\n        status: UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED,\n        user: { ...userStatus.user, wallet: this },\n      };\n    }\n    return userStatus;\n  }\n\n  /**\n   * @description\n   * Switches the chain that the user wallet is currently on.\n   * @example\n   * // user wallet will be set to Polygon\n   * const Paper = new PaperEmbeddedWalletSdk({clientId: \"\", chain: \"Polygon\"});\n   * const user = await Paper.initializeUser();\n   * // Switch the user wallet to Mumbai\n   * await user.wallet.setChain({ chain: \"Mumbai\" });\n   * @param {Chain} params.chain The chain that we are changing the user wallet too\n   */\n  async setChain({ chain }: { chain: Chain }): Promise<void> {\n    this.chain = chain;\n    this.gasless = new GaslessTransactionMaker({\n      chain,\n      clientId: this.clientId,\n      querier: this.walletManagerQuerier,\n    });\n  }\n\n  /**\n   * Returns an Ethers.Js compatible signer that you can use in conjunction with the rest of dApp\n   * @example\n   * const Paper = new PaperEmbeddedWalletSdk({clientId: \"\", chain: \"Polygon\"});\n   * const user = await Paper.getUser();\n   * if (user.status === UserStatus.LOGGED_IN_WALLET_INITIALIZED) {\n   *    // returns a signer on the Polygon mainnet\n   *    const signer = await user.getEthersJsSigner();\n   *    // returns a signer on the specified RPC endpoints\n   *    const signer = await user.getEthersJsSigner({rpcEndpoint: \"https://eth-rpc.gateway.pokt.network\"});\n   * }\n   * @param {Networkish} network.rpcEndpoint the rpc url where calls will be routed through\n   * @throws If attempting to call the function without the user wallet initialize on their current device. This should never happen if call {@link PaperEmbeddedWalletSdk.initializeUser} before accessing this function\n   * @returns A signer that is compatible with Ether.js. Defaults to the public rpc on the chain specified when initializing the {@link PaperEmbeddedWalletSdk} instance\n   */\n  async getEthersJsSigner(network?: {\n    rpcEndpoint: Networkish;\n  }): Promise<EthersSigner> {\n    const signer = new EthersSigner({\n      clientId: this.clientId,\n      provider: getDefaultProvider(\n        network?.rpcEndpoint ?? ChainToPublicRpc[this.chain],\n      ),\n      querier: this.walletManagerQuerier,\n    });\n    return signer;\n  }\n}\n","import type { Chain } from \"@paperxyz/sdk-common-utilities\";\nimport type { ClientIdWithQuerierAndChainType } from \"../../interfaces/EmbeddedWallets/EmbeddedWallets\";\nimport type {\n  CallContractReturnType,\n  ContractCallInputType,\n} from \"../../interfaces/EmbeddedWallets/GaslessTransactionMaker\";\nimport type { EmbeddedWalletIframeCommunicator } from \"../../utils/iFrameCommunication/EmbeddedWalletIframeCommunicator\";\n\nexport type GaslessTransactionQuerierTypes = {\n  callContract: {\n    contractAddress: string;\n    method: {\n      stub: string;\n      args: Array<unknown>;\n    };\n    chain: Chain;\n  };\n};\n\n/**\n * @description GaslessTransactionMaker is used to execute gasless transactions from the embedded wallets\n */\nexport class GaslessTransactionMaker {\n  protected chain: Chain;\n  protected clientId: string;\n  protected gaslessTransactionQuerier: EmbeddedWalletIframeCommunicator<GaslessTransactionQuerierTypes>;\n  constructor({ chain, clientId, querier }: ClientIdWithQuerierAndChainType) {\n    this.chain = chain;\n    this.clientId = clientId;\n    this.gaslessTransactionQuerier = querier;\n  }\n  /**\n   * @description\n   * Use to call arbitrary contracts on the blockchain. Note that you have to enable {@link https://withpaper.com/dashboard/developers Sponsored Fees} in order for this to work.\n   *\n   * @param {string} params.contractAddress The address for which the contract call is directed too.\n   * @param {string} params.methodInterface the function stub on the contract. This looks something like `function myFunctionName(address user, uint256 tokenId) external payable`. Refer to this {@link https://blog.ricmoo.com/human-readable-contract-abis-in-ethers-js-141902f4d917 ethers.js article} for more.\n   * @param {Array} params.methodArgs The arguments that is to be passed to the contract in order that they are to be passed to the contract.\n   * @throws if there is an error calling the contract for whatever reason.\n   * @returns {{ transactionHash: string }} The transaction hash associated with the successful contract call.\n   */\n  async callContract({\n    contractAddress,\n    methodArgs,\n    methodInterface,\n  }: ContractCallInputType): Promise<CallContractReturnType> {\n    return await this.gaslessTransactionQuerier.call<CallContractReturnType>({\n      procedureName: \"callContract\",\n      params: {\n        chain: this.chain,\n        contractAddress,\n        method: {\n          args: methodArgs,\n          stub: methodInterface,\n        },\n      },\n    });\n  }\n}\n","import type {\n  Provider,\n  TransactionRequest,\n} from \"@ethersproject/abstract-provider\";\nimport type {\n  TypedDataDomain,\n  TypedDataField,\n} from \"@ethersproject/abstract-signer\";\nimport { Signer } from \"@ethersproject/abstract-signer\";\nimport type { Bytes } from \"@ethersproject/bytes\";\nimport type { Deferrable } from \"@ethersproject/properties\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport type { ClientIdWithQuerierType } from \"../../interfaces/EmbeddedWallets/EmbeddedWallets\";\nimport type {\n  GetAddressReturnType,\n  SignMessageReturnType,\n  SignTransactionReturnType,\n  SignedTypedDataReturnType,\n} from \"../../interfaces/EmbeddedWallets/Signer\";\n\nimport type { JsonRpcProvider } from \"@ethersproject/providers\";\nimport type { EmbeddedWalletIframeCommunicator } from \"../../utils/iFrameCommunication/EmbeddedWalletIframeCommunicator\";\n\nexport type SignerProcedureTypes = {\n  getAddress: void;\n  signMessage: {\n    message: string | Bytes;\n    chainId: number;\n    rpcEndpoint: string;\n  };\n  signTransaction: {\n    transaction: Deferrable<TransactionRequest>;\n    chainId: number;\n    rpcEndpoint: string;\n  };\n  signTypedDataV4: {\n    domain: TypedDataDomain;\n    types: Record<string, Array<TypedDataField>>;\n    message: Record<string, unknown>;\n    chainId: number;\n    rpcEndpoint: string;\n  };\n  connect: { provider: Provider };\n};\n\nexport class EthersSigner extends Signer {\n  protected querier: EmbeddedWalletIframeCommunicator<SignerProcedureTypes>;\n  protected clientId: string;\n  protected endpoint: string;\n  private DEFAULT_ETHEREUM_CHAIN_ID = 5;\n  constructor({\n    provider,\n    clientId,\n    querier,\n  }: ClientIdWithQuerierType & {\n    provider: Provider;\n  }) {\n    super();\n    this.clientId = clientId;\n    this.querier = querier;\n    // we try to extract a url if possible\n    this.endpoint = (provider as JsonRpcProvider).connection?.url;\n    defineReadOnly(this, \"provider\", provider);\n  }\n\n  override async getAddress(): Promise<string> {\n    const { address } = await this.querier.call<GetAddressReturnType>({\n      procedureName: \"getAddress\",\n      params: undefined,\n    });\n    return address;\n  }\n\n  override async signMessage(message: string | Bytes): Promise<string> {\n    const network = await this.provider?.getNetwork();\n    if (network) {\n      network._defaultProvider;\n    }\n\n    const { signedMessage } = await this.querier.call<SignMessageReturnType>({\n      procedureName: \"signMessage\",\n      params: {\n        message,\n        chainId:\n          (await this.provider?.getNetwork())?.chainId ??\n          this.DEFAULT_ETHEREUM_CHAIN_ID,\n        rpcEndpoint: this.endpoint,\n      },\n    });\n    return signedMessage;\n  }\n\n  override async signTransaction(\n    transaction: TransactionRequest,\n  ): Promise<string> {\n    const { signedTransaction } =\n      await this.querier.call<SignTransactionReturnType>({\n        procedureName: \"signTransaction\",\n        params: {\n          transaction,\n          chainId:\n            (await this.provider?.getNetwork())?.chainId ??\n            this.DEFAULT_ETHEREUM_CHAIN_ID,\n          rpcEndpoint: this.endpoint,\n        },\n      });\n    return signedTransaction;\n  }\n\n  async _signTypedData(\n    domain: SignerProcedureTypes[\"signTypedDataV4\"][\"domain\"],\n    types: SignerProcedureTypes[\"signTypedDataV4\"][\"types\"],\n    message: SignerProcedureTypes[\"signTypedDataV4\"][\"message\"],\n  ): Promise<string> {\n    const { signedTypedData } =\n      await this.querier.call<SignedTypedDataReturnType>({\n        procedureName: \"signTypedDataV4\",\n        params: {\n          domain,\n          types,\n          message,\n          chainId:\n            (await this.provider?.getNetwork())?.chainId ??\n            this.DEFAULT_ETHEREUM_CHAIN_ID,\n          rpcEndpoint: this.endpoint,\n        },\n      });\n    return signedTypedData;\n  }\n\n  override connect(provider: Provider): EthersSigner {\n    return new EthersSigner({\n      clientId: this.clientId,\n      provider,\n      querier: this.querier,\n    });\n  }\n}\n","import { RecoveryShareManagement } from \"../interfaces/Auth\";\nimport type {\n  GetUser,\n  PaperConstructorType,\n} from \"../interfaces/EmbeddedWallets/EmbeddedWallets\";\nimport {\n  UserStatus,\n  UserWalletStatus,\n} from \"../interfaces/EmbeddedWallets/EmbeddedWallets\";\nimport { EmbeddedWalletIframeCommunicator } from \"../utils/iFrameCommunication/EmbeddedWalletIframeCommunicator\";\nimport type { AuthQuerierTypes } from \"./Auth\";\nimport { Auth } from \"./Auth\";\nimport { EmbeddedWallet } from \"./EmbeddedWallets/EmbeddedWallet\";\n\nexport class PaperEmbeddedWalletSdk<T extends RecoveryShareManagement = RecoveryShareManagement.USER_MANAGED> {\n  protected clientId: string;\n  protected querier: EmbeddedWalletIframeCommunicator<AuthQuerierTypes>;\n\n  private wallet: EmbeddedWallet;\n  /**\n   * Used to manage the Auth state of the user.\n   */\n  auth: Auth<T>;\n\n  /**\n   * @example\n   * const Paper = new PaperEmbeddedWalletSdk({ clientId: \"\", chain: \"Goerli\" });\n   * @param {string} initParams.clientId the clientId found on the {@link https://withpaper.com/dashboard/developers developer's dashboard}\n   * @param {Chain} initParams.chain sets the default chain that the EmbeddedWallet will live on.\n   * @param {CustomizationOptionsType} initParams.styles sets the default style override for any modal that pops up asking for user's details when creating wallet or logging in.\n   */\n  constructor({ clientId, chain, styles, advancedOptions }: PaperConstructorType<T>) {\n    this.clientId = clientId;\n    this.querier = new EmbeddedWalletIframeCommunicator({\n      clientId,\n      customizationOptions: styles,\n    });\n    this.wallet = new EmbeddedWallet({\n      clientId,\n      chain,\n      querier: this.querier,\n    });\n    \n    this.auth = new Auth<T>({\n      clientId,\n      advancedOptions: {\n        recoveryShareManagement: RecoveryShareManagement.USER_MANAGED,        \n        ...(advancedOptions ?? {}),\n      },\n      querier: this.querier,\n      onAuthSuccess: async (authResult) => {\n        await this.wallet.postWalletSetUp({\n          ...authResult.walletDetails,\n          walletUserId: authResult.storedToken.authDetails.userWalletId,\n        });\n        return {\n          user: {\n            status: UserStatus.LOGGED_IN_WALLET_INITIALIZED,\n            authDetails: authResult.storedToken.authDetails,\n            wallet: this.wallet,\n            walletAddress: authResult.walletDetails.walletAddress,\n          },\n        };\n      },\n    });\n  }\n\n  /**\n   * Gets the usr if they are logged in\n   * @example\n   *  const user = await Paper.getUser();\n   *  switch (user.status) {\n   *     case UserStatus.LOGGED_OUT: {\n   *       // User is logged out, call one of the auth methods on Paper.auth to authenticate the user\n   *       break;\n   *     }\n   *     case UserStatus.LOGGED_IN_WALLET_INITIALIZED: {\n   *       // user is logged in and wallet is all set up.\n   *       // You have access to:\n   *       user.status;\n   *       user.authDetails;\n   *       user.walletAddress;\n   *       user.wallet;\n   *       break;\n   *     }\n   *}\n   * @returns {GetUser} an object to containing various information on the user statuses\n   */\n  async getUser(): Promise<GetUser> {\n    const userStatus = await this.wallet.getUserWalletStatus();\n    switch (userStatus.status) {\n      // user gets {UserWalletStatus.LOGGED_IN_NEW_DEVICE} when they log in but never complete the recovery flow and exits (close modal, refresh etc)\n      case UserWalletStatus.LOGGED_IN_NEW_DEVICE:\n      // User gets {UserWalletStatus.LOGGED_IN_WALLET_UNINITIALIZED} when they log in but manage to exit the client in the small window between auth completion and sending them their wallet recovery details\n      case UserWalletStatus.LOGGED_IN_WALLET_UNINITIALIZED:\n        // in both case, we simply log them out to reset their state\n        await this.auth.logout();\n        return this.getUser();\n      case UserWalletStatus.LOGGED_OUT:\n        return {\n          status: UserStatus.LOGGED_OUT,\n        };\n      case UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED:\n        return {\n          status: UserStatus.LOGGED_IN_WALLET_INITIALIZED,\n          ...userStatus.user,\n        };\n    }\n  }\n}\n"]}