import { useConnect, useCreateWalletInstance, useWalletContext, useWallet, useChain, useNetworkMismatch, useConnectionStatus, useSwitchChain } from '@thirdweb-dev/react-core';
export * from '@thirdweb-dev/react-core';
import { useCallback, useState, useEffect, useRef } from 'react';
import { LocalWallet, walletIds, SmartWallet, ZerionWallet, assertWindowEthereum } from '@thirdweb-dev/wallets';
import { r as radius, s as spacing, f as fontSize, i as iconSize, S as Spacer, F as FormFooter, B as Button, a as Flex, b as Spinner, L as Label, E as ErrorMessage$1 } from './basic-72632cb3.browser.esm.js';
import { i as isMobile, B as BackButton, I as Img, M as ModalTitle, a as ModalDescription, F as FormFieldWithIconButton, u as useIsHeadlessWallet, H as HelperLink, W as WalletSelection, d as defaultWallets, b as HeadlessConnectUI, S as ScanScreen, C as ConnectingScreen, G as GetStartedScreen } from './headlessConnectUI-cd65fc5e.browser.esm.js';
export { c as coinbaseWallet, m as metamaskWallet, e as useIsWalletModalOpen, f as useSetIsWalletModalOpen, w as walletConnectV1 } from './headlessConnectUI-cd65fc5e.browser.esm.js';
import { UploadIcon, EyeClosedIcon, EyeOpenIcon, ExclamationTriangleIcon } from '@radix-ui/react-icons';
import styled from '@emotion/styled';
import { jsx, jsxs, Fragment } from 'react/jsx-runtime';
import { T as TextDivider } from './InputSelectionUI-df66b9d3.browser.esm.js';
import { S as SecondaryText, E as ExportLocalWallet, s as shortenAddress } from './useWalletConnect-0148bde7.browser.esm.js';
export { C as ConnectWallet, M as MediaRenderer, N as NetworkSelector, i as ThirdwebNftMedia, T as ThirdwebProvider, W as Web3Button, b as useCoinbaseWallet, c as useFrameWallet, u as useInstalledWallets, a as useMetamask, e as usePaperWallet, d as usePaperWalletUserEmail, h as useResolvedMediaType, f as useWalletConnect, g as useWalletConnectV1 } from './useWalletConnect-0148bde7.browser.esm.js';
export { frameWallet } from './frameWallet-5e29b8b4.browser.esm.js';
export { paperWallet } from './paperWallet-6bbe13a1.browser.esm.js';
export { safeWallet } from './safeWallet-73d6199e.browser.esm.js';
export { walletConnect } from './walletConnect-999b71fe.browser.esm.js';
export { magicLink } from './magicLink-8e83a0b4.browser.esm.js';
export { u as useSafe } from './useSafe-089261ec.browser.esm.js';
export { u as useMagic } from './useMagic-b089ccd0.browser.esm.js';
import '@emotion/react';
import '@radix-ui/colors';
import 'detect-browser';
import 'react-qr-code';
import '@radix-ui/react-dialog';
import '@tanstack/react-query';
import '@radix-ui/react-popover';
import 'copy-to-clipboard';
import '@radix-ui/react-tooltip';
import 'ethers';
import '@radix-ui/react-tabs';
import 'fuse.js';
import '@radix-ui/react-dropdown-menu';
import '@thirdweb-dev/chains';
import 'tiny-invariant';

function useSmartWallet() {
  const connect = useConnect();
  return useCallback(async options => {
    const {
      smartWallet
    } = await Promise.resolve().then(function () { return smartWallet$1; });
    return connect(smartWallet(options), options);
  }, [connect]);
}

function useLocalWalletInfo(localWalletConfig, persist) {
  const [walletData, setWalletData] = useState("loading");
  const createWalletInstance = useCreateWalletInstance();
  const [localWallet, setLocalWallet] = useState(null);
  useEffect(() => {
    const wallet = createWalletInstance(localWalletConfig);
    setLocalWallet(wallet);
    if (persist) {
      wallet.getSavedData().then(data => {
        setWalletData(data);
      });
    }
  }, [createWalletInstance, localWalletConfig, persist]);
  return {
    setLocalWallet,
    localWallet,
    walletData,
    meta: localWalletConfig.meta,
    persist: persist
  };
}

const DragNDrop = props => {
  const [error, setError] = useState(false);
  const [uploaded, setUploaded] = useState();
  const [isDragging, setIsDragging] = useState(false);
  const dragIn = e => {
    setError(false);
    setUploaded(undefined);
    setIsDragging(true);
    e.preventDefault();
    e.stopPropagation();
  };
  const dragOut = e => {
    setIsDragging(false);
    e.preventDefault();
    e.stopPropagation();
  };
  const handleFileUpload = file => {
    if (file.type !== props.accept) {
      setError(true);
    } else {
      setUploaded(file);
      props.onUpload(file);
    }
  };
  const drop = e => {
    setIsDragging(false);
    e.preventDefault();
    e.stopPropagation();
    if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
      handleFileUpload(e.dataTransfer.files[0]);
      e.dataTransfer.clearData();
    }
  };
  const message = isMobile() ? "Click to Upload" : "Drop your file here or click to upload";
  return /*#__PURE__*/jsx("div", {
    onDragEnter: dragIn,
    onDragLeave: dragOut,
    onDragOver: e => {
      setIsDragging(true);
      e.preventDefault();
      e.stopPropagation();
    },
    onClick: () => {
      setError(false);
    },
    onDrop: drop,
    style: {
      cursor: "pointer"
    },
    children: /*#__PURE__*/jsxs("label", {
      htmlFor: "file-upload",
      children: [/*#__PURE__*/jsx("input", {
        id: "file-upload",
        type: "file",
        accept: props.accept,
        multiple: false,
        style: {
          display: "none"
        },
        onChange: e => {
          if (e.target.files && e.target.files.length > 0) {
            handleFileUpload(e.target.files[0]);
          }
        }
      }), /*#__PURE__*/jsx(DropContainer, {
        "data-error": error,
        "data-is-dragging": isDragging,
        children: !uploaded ? /*#__PURE__*/jsxs(Fragment, {
          children: [" ", /*#__PURE__*/jsx(UploadIconSecondary, {
            width: iconSize.xl,
            height: iconSize.xl
          }), /*#__PURE__*/jsx(Spacer, {
            y: "md"
          }), /*#__PURE__*/jsx(Message, {
            children: message
          }), /*#__PURE__*/jsx(Spacer, {
            y: "md"
          }), error ? /*#__PURE__*/jsxs(ErrorMessage, {
            children: [" ", "Please upload a ", props.extension, " file", " "]
          }) : /*#__PURE__*/jsxs(ExtensionText, {
            children: [" ", props.extension, " "]
          })]
        }) : /*#__PURE__*/jsxs(Fragment, {
          children: [/*#__PURE__*/jsxs(Message, {
            children: [uploaded.name, " uploaded successfully"]
          }), /*#__PURE__*/jsx(Spacer, {
            y: "md"
          }), /*#__PURE__*/jsx(CheckCircleIcon, {
            size: iconSize.xl
          })]
        })
      })]
    })
  });
};
const UploadIconSecondary = styled(UploadIcon)`
  color: ${props => props.theme.text.secondary};
  transition: transform 200ms ease, color 200ms ease;
`;
const DropContainer = styled.div`
  border: 2px solid ${p => p.theme.bg.elevated};
  border-radius: ${radius.md};
  padding: ${spacing.xl} ${spacing.md};
  display: flex;
  align-items: center;
  flex-direction: column;
  cursor: pointer;
  transition: border-color 200ms ease;

  &:hover,
  &[data-is-dragging="true"] {
    border-color: ${p => p.theme.link.primary};
    svg {
      color: ${p => p.theme.link.primary};
    }
  }

  &[data-error="true"] {
    border-color: ${p => p.theme.input.errorRing};
  }
`;
const ErrorMessage = styled.p`
  color: ${p => p.theme.input.errorRing};
  font-size: ${fontSize.sm};
  margin: 0;
`;
const ExtensionText = styled.span`
  color: ${p => p.theme.text.secondary};
  font-size: ${fontSize.sm};
`;
const CheckCircleIcon = props => /*#__PURE__*/jsxs("svg", {
  width: props.size,
  height: props.size,
  viewBox: "0 0 38 38",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  children: [/*#__PURE__*/jsx("path", {
    d: "M35.6666 17.4671V19.0004C35.6645 22.5945 34.5008 26.0916 32.3488 28.9701C30.1969 31.8487 27.1721 33.9546 23.7255 34.9736C20.279 35.9926 16.5954 35.8703 13.224 34.6247C9.85272 33.3792 6.97434 31.0773 5.01819 28.0622C3.06203 25.0472 2.1329 21.4805 2.36938 17.8943C2.60586 14.308 3.99526 10.8943 6.33039 8.16221C8.66551 5.43012 11.8212 3.52606 15.3269 2.734C18.8326 1.94194 22.5004 2.30432 25.7833 3.76709",
    stroke: "#5BD58C",
    strokeWidth: "3.33333",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /*#__PURE__*/jsx("path", {
    d: "M35.6667 5.66699L19 22.3503L14 17.3503",
    stroke: "#5BD58C",
    strokeWidth: "3.33333",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  })]
});
const Message = styled.p`
  color: ${p => p.theme.text.neutral};
  font-size: ${fontSize.md};
  margin: 0;
  font-weight: 600;
`;

const LocalWalletModalHeader = props => {
  return /*#__PURE__*/jsxs(Fragment, {
    children: [!props.hideBack && /*#__PURE__*/jsx(BackButton, {
      onClick: props.onBack
    }), /*#__PURE__*/jsx(Spacer, {
      y: "md"
    }), /*#__PURE__*/jsx(Img, {
      src: props.meta.iconURL,
      width: iconSize.xl,
      height: iconSize.xl
    }), /*#__PURE__*/jsx(Spacer, {
      y: "sm"
    })]
  });
};

const ImportLocalWallet = props => {
  const [jsonString, setJsonString] = useState();
  const {
    setLocalWallet,
    meta
  } = useLocalWalletInfo(props.localWalletConf, props.persist);
  const createWalletInstance = useCreateWalletInstance();
  const [password, setPassword] = useState("");
  const [isWrongPassword, setIsWrongPassword] = useState(false);
  const [showPassword, setShowPassword] = useState(false);
  const [importedAddress, setImportedAddress] = useState();
  const {
    setConnectedWallet,
    setConnectionStatus
  } = useWalletContext();
  const handleImport = async () => {
    const localWallet = createWalletInstance(props.localWalletConf);
    if (!localWallet || !jsonString) {
      throw new Error("Invalid state");
    }
    try {
      await localWallet.import({
        encryptedJson: jsonString,
        password
      });
    } catch (e) {
      console.error(e);
      setIsWrongPassword(true);
      return;
    }
    setConnectionStatus("connecting");
    await localWallet.connect();
    await localWallet.save({
      strategy: "encryptedJson",
      password
    });
    setConnectedWallet(localWallet);
    setLocalWallet(localWallet);
    props.onConnect();
  };
  return /*#__PURE__*/jsxs(Fragment, {
    children: [/*#__PURE__*/jsx(LocalWalletModalHeader, {
      onBack: props.goBack,
      meta: meta
    }), /*#__PURE__*/jsx(ModalTitle, {
      style: {
        textAlign: "left"
      },
      children: "Import Wallet"
    }), /*#__PURE__*/jsx(Spacer, {
      y: "md"
    }), /*#__PURE__*/jsx(ModalDescription, {
      children: "The application can authorize any transactions on behalf of the wallet without any approvals. We recommend only connecting to trusted applications."
    }), /*#__PURE__*/jsx(Spacer, {
      y: "lg"
    }), /*#__PURE__*/jsx(DragNDrop, {
      extension: "JSON",
      accept: "application/json",
      onUpload: file => {
        const reader = new FileReader();
        reader.onload = event => {
          setJsonString(event.target?.result);
          const obj = JSON.parse(event.target?.result);
          setImportedAddress(obj.address);
        };
        reader.readAsText(file, "utf-8");
      }
    }), /*#__PURE__*/jsx(Spacer, {
      y: "lg"
    }), /*#__PURE__*/jsxs("form", {
      onSubmit: e => {
        e.preventDefault();
        handleImport();
      },
      children: [jsonString && /*#__PURE__*/jsxs(Fragment, {
        children: [/*#__PURE__*/jsx("input", {
          type: "text",
          name: "username",
          autoComplete: "off",
          value: importedAddress || "",
          disabled: true,
          style: {
            display: "none"
          }
        }), /*#__PURE__*/jsx(FormFieldWithIconButton, {
          required: true,
          noSave: true,
          name: "password",
          autocomplete: "off",
          id: "password",
          onChange: value => {
            setPassword(value);
            setIsWrongPassword(false);
          },
          right: {
            onClick: () => setShowPassword(!showPassword),
            icon: showPassword ? /*#__PURE__*/jsx(EyeClosedIcon, {}) : /*#__PURE__*/jsx(EyeOpenIcon, {})
          },
          label: "Password",
          type: showPassword ? "text" : "password",
          value: password,
          error: isWrongPassword ? "Wrong Password" : ""
        }), /*#__PURE__*/jsx(Spacer, {
          y: "xl"
        })]
      }), /*#__PURE__*/jsx(FormFooter, {
        children: /*#__PURE__*/jsx(Button, {
          variant: "inverted",
          type: "submit",
          disabled: !jsonString,
          style: {
            minWidth: "110px",
            opacity: jsonString ? 1 : 0.5
          },
          children: "Import"
        })
      })]
    })]
  });
};

const CreateLocalWallet_Password = props => {
  const [password, setPassword] = useState("");
  const [confirmPassword, setConfirmPassword] = useState("");
  const [showPassword, setShowPassword] = useState(false);
  const passwordMismatch = confirmPassword && password !== confirmPassword;
  const [isConnecting, setIsConnecting] = useState(false);
  const {
    localWallet,
    meta
  } = useLocalWalletInfo(props.localWalletConf, props.persist);
  const {
    setConnectedWallet,
    setConnectionStatus
  } = useWalletContext();
  const [showImportScreen, setShowImportScreen] = useState(false);
  const [generatedAddress, setGeneratedAddress] = useState(null);

  // generating wallet before it's required to render a form with hidden address as username for better autofill
  useEffect(() => {
    if (!localWallet || showImportScreen || localWallet.ethersWallet) {
      return;
    }
    localWallet.generate().then(_address => {
      setGeneratedAddress(_address);
    });
  }, [localWallet, showImportScreen]);
  if (showImportScreen) {
    return /*#__PURE__*/jsx(ImportLocalWallet, {
      localWalletConf: props.localWalletConf,
      onConnect: props.onConnect,
      goBack: () => {
        setShowImportScreen(false);
      },
      persist: props.persist
    });
  }
  const handleConnect = async () => {
    if (passwordMismatch || !localWallet) {
      throw new Error("Invalid state");
    }
    setIsConnecting(true);
    setConnectionStatus("connecting");
    await localWallet.connect();
    await localWallet.save({
      strategy: "encryptedJson",
      password
    });
    setConnectedWallet(localWallet);
    setIsConnecting(false);
    props.onConnect();
  };
  return /*#__PURE__*/jsxs(Fragment, {
    children: [/*#__PURE__*/jsx(LocalWalletModalHeader, {
      onBack: props.goBack,
      meta: meta,
      hideBack: !props.renderBackButton
    }), /*#__PURE__*/jsx(Flex, {
      alignItems: "center",
      gap: "xs",
      children: /*#__PURE__*/jsx(ModalTitle, {
        children: "Guest Wallet"
      })
    }), /*#__PURE__*/jsx(Spacer, {
      y: "sm"
    }), /*#__PURE__*/jsxs(ModalDescription, {
      children: ["Choose a password for your wallet, you", `'`, "ll be able to access and export this wallet with the same password."]
    }), /*#__PURE__*/jsx(Spacer, {
      y: "lg"
    }), /*#__PURE__*/jsxs("form", {
      onSubmit: e => {
        e.preventDefault();
        handleConnect();
      },
      children: [/*#__PURE__*/jsx("input", {
        type: "text",
        name: "username",
        autoComplete: "off",
        value: generatedAddress || "",
        disabled: true,
        style: {
          display: "none"
        }
      }), /*#__PURE__*/jsx(FormFieldWithIconButton, {
        name: "password",
        required: true,
        autocomplete: "new-password",
        id: "new-password",
        onChange: value => setPassword(value),
        right: {
          icon: showPassword ? /*#__PURE__*/jsx(EyeClosedIcon, {}) : /*#__PURE__*/jsx(EyeOpenIcon, {}),
          onClick: () => setShowPassword(!showPassword)
        },
        label: "Password",
        type: showPassword ? "text" : "password",
        value: password,
        dataTest: "new-password"
      }), /*#__PURE__*/jsx(Spacer, {
        y: "lg"
      }), /*#__PURE__*/jsx(FormFieldWithIconButton, {
        name: "confirm-password",
        required: true,
        autocomplete: "new-password",
        id: "confirm-password",
        onChange: value => setConfirmPassword(value),
        right: {
          icon: showPassword ? /*#__PURE__*/jsx(EyeClosedIcon, {}) : /*#__PURE__*/jsx(EyeOpenIcon, {}),
          onClick: () => setShowPassword(!showPassword)
        },
        label: "Confirm Password",
        type: showPassword ? "text" : "password",
        value: confirmPassword,
        error: passwordMismatch ? "Passwords don't match" : "",
        dataTest: "confirm-password"
      }), /*#__PURE__*/jsx(Spacer, {
        y: "xl"
      }), /*#__PURE__*/jsxs(Button, {
        variant: "inverted",
        type: "submit",
        style: {
          width: "100%",
          gap: spacing.sm
        },
        "data-test": "create-new-wallet-button",
        children: [isConnecting ? "Connecting" : "Create new wallet", isConnecting && /*#__PURE__*/jsx(Spinner, {
          size: "sm",
          color: "inverted"
        })]
      })]
    }), /*#__PURE__*/jsx(Spacer, {
      y: "xxl"
    }), /*#__PURE__*/jsx(TextDivider, {
      children: /*#__PURE__*/jsx("span", {
        children: "OR"
      })
    }), /*#__PURE__*/jsx(Spacer, {
      y: "lg"
    }), /*#__PURE__*/jsx(Flex, {
      justifyContent: "center",
      children: /*#__PURE__*/jsx(Button, {
        variant: "link",
        onClick: () => {
          setShowImportScreen(true);
        },
        children: "Import wallet"
      })
    })]
  });
};
const CreateLocalWallet_Guest = props => {
  const {
    localWallet
  } = useLocalWalletInfo(props.localWallet, props.persist);
  const {
    setConnectedWallet,
    setConnectionStatus
  } = useWalletContext();
  const {
    onConnect
  } = props;
  const handleConnect = useCallback(async () => {
    if (!localWallet) {
      throw new Error("Invalid state");
    }
    await localWallet.generate();
    setConnectionStatus("connecting");
    await localWallet.connect();
    setConnectedWallet(localWallet);
    onConnect();
  }, [localWallet, setConnectedWallet, onConnect, setConnectionStatus]);
  const connecting = useRef(false);
  useEffect(() => {
    if (connecting.current || !localWallet) {
      return;
    }
    connecting.current = true;
    handleConnect();
  }, [handleConnect, localWallet]);
  return /*#__PURE__*/jsx(Flex, {
    justifyContent: "center",
    alignItems: "center",
    style: {
      height: "300px"
    },
    children: /*#__PURE__*/jsx(Spinner, {
      size: "lg",
      color: "link"
    })
  });
};

const OverrideConfirmation = props => {
  return /*#__PURE__*/jsxs(Fragment, {
    children: [/*#__PURE__*/jsx(LocalWalletModalHeader, {
      onBack: props.onBack,
      meta: props.meta
    }), /*#__PURE__*/jsx(ModalTitle, {
      children: "Backup your wallet"
    }), /*#__PURE__*/jsx(Spacer, {
      y: "md"
    }), /*#__PURE__*/jsxs("div", {
      style: {
        lineHeight: 1.5
      },
      children: [/*#__PURE__*/jsx(SecondaryText, {
        children: "Your current wallet will be deleted if you create a new wallet. Backup wallet to your device before creating a new wallet"
      }), /*#__PURE__*/jsx(Spacer, {
        y: "xl"
      }), /*#__PURE__*/jsx(FormFooter, {
        children: /*#__PURE__*/jsx(Button, {
          variant: "inverted",
          onClick: props.onBackup,
          children: "Backup wallet"
        })
      })]
    })]
  });
};

/**
 * For No-Credential scenario
 */
const ReconnectLocalWallet = props => {
  const [password, setPassword] = useState("");
  const [showPassword, setShowPassword] = useState(false);
  const [isWrongPassword, setIsWrongPassword] = useState(false);
  const {
    setConnectedWallet,
    setConnectionStatus
  } = useWalletContext();
  const [isConnecting, setIsConnecting] = useState(false);
  const [showCreate, setShowCreate] = useState(false);
  const [showBackupConfirmation, setShowBackupConfirmation] = useState(false);
  const [showExport, setShowExport] = useState(false);
  const {
    localWallet,
    meta,
    walletData
  } = useLocalWalletInfo(props.localWallet, props.persist);
  const savedAddress = walletData ? walletData === "loading" ? "" : walletData.address : "";
  if (showExport) {
    if (!localWallet) {
      throw new Error("Invalid state");
    }
    return /*#__PURE__*/jsx(ExportLocalWallet, {
      localWalletConfig: props.localWallet,
      onBack: () => {
        setShowExport(false);
      },
      onExport: () => {
        setShowExport(false);
        setShowBackupConfirmation(false);
        setShowCreate(true);
      }
    });
  }
  if (showBackupConfirmation) {
    return /*#__PURE__*/jsx(OverrideConfirmation, {
      meta: meta,
      onBackup: () => {
        setShowExport(true);
      },
      onBack: () => {
        setShowBackupConfirmation(false);
      }
    });
  }
  if (showCreate) {
    return /*#__PURE__*/jsx(CreateLocalWallet_Password, {
      renderBackButton: props.supportedWallets.length > 1,
      localWalletConf: props.localWallet,
      goBack: () => {
        setShowCreate(false);
      },
      onConnect: props.onConnect,
      persist: props.persist
    });
  }
  const handleReconnect = async () => {
    if (!localWallet) {
      throw new Error("Invalid state");
    }
    setIsConnecting(true);
    try {
      await localWallet.load({
        strategy: "encryptedJson",
        password
      });
      setConnectionStatus("connecting");
      await localWallet.connect();
      setConnectedWallet(localWallet);
      props.onConnect();
    } catch (e) {
      setIsWrongPassword(true);
    }
    setIsConnecting(false);
  };
  return /*#__PURE__*/jsxs(Fragment, {
    children: [/*#__PURE__*/jsx(LocalWalletModalHeader, {
      onBack: props.goBack,
      meta: meta,
      hideBack: !props.renderBackButton
    }), /*#__PURE__*/jsx(ModalTitle, {
      style: {
        textAlign: "left"
      },
      children: "Guest Wallet"
    }), /*#__PURE__*/jsx(Spacer, {
      y: "xs"
    }), /*#__PURE__*/jsx(ModalDescription, {
      children: "Connect to saved wallet on your device"
    }), /*#__PURE__*/jsx(Spacer, {
      y: "lg"
    }), /*#__PURE__*/jsx(Label, {
      children: "Saved Wallet"
    }), /*#__PURE__*/jsx(Spacer, {
      y: "sm"
    }), /*#__PURE__*/jsx(SecondaryText, {
      children: savedAddress === "" ? "Loading..." : shortenAddress(savedAddress)
    }), /*#__PURE__*/jsx(Spacer, {
      y: "lg"
    }), /*#__PURE__*/jsxs("form", {
      onSubmit: e => {
        e.preventDefault();
        handleReconnect();
      },
      children: [/*#__PURE__*/jsx("input", {
        type: "text",
        name: "username",
        autoComplete: "off",
        value: savedAddress,
        disabled: true,
        style: {
          display: "none"
        }
      }), /*#__PURE__*/jsx(FormFieldWithIconButton, {
        required: true,
        name: "current-password",
        autocomplete: "current-password",
        id: "current-password",
        onChange: value => {
          setPassword(value);
          setIsWrongPassword(false);
        },
        right: {
          onClick: () => setShowPassword(!showPassword),
          icon: showPassword ? /*#__PURE__*/jsx(EyeClosedIcon, {}) : /*#__PURE__*/jsx(EyeOpenIcon, {})
        },
        label: "Password",
        type: showPassword ? "text" : "password",
        value: password,
        error: isWrongPassword ? "Wrong Password" : "",
        dataTest: "current-password"
      }), /*#__PURE__*/jsx(Spacer, {
        y: "lg"
      }), /*#__PURE__*/jsx(FormFooter, {
        children: /*#__PURE__*/jsxs(Button, {
          variant: "inverted",
          type: "submit",
          style: {
            display: "flex",
            gap: spacing.sm
          },
          children: ["Connect", isConnecting && /*#__PURE__*/jsx(Spinner, {
            size: "sm",
            color: "inverted"
          })]
        })
      })]
    }), /*#__PURE__*/jsx(Spacer, {
      y: "xxl"
    }), /*#__PURE__*/jsx(Button, {
      variant: "link",
      style: {
        textAlign: "center",
        width: "100%",
        padding: "2px"
      },
      onClick: () => {
        setShowBackupConfirmation(true);
      },
      children: "Create a new wallet"
    })]
  });
};

const LocalWalletConnectUI = props => {
  const {
    walletData
  } = useLocalWalletInfo(props.walletConfig, props.persist);
  if (!props.persist) {
    return /*#__PURE__*/jsx(CreateLocalWallet_Guest, {
      persist: props.persist,
      localWallet: props.walletConfig,
      goBack: props.goBack,
      onConnect: props.close
    });
  }
  if (walletData === "loading") {
    return /*#__PURE__*/jsx(Flex, {
      justifyContent: "center",
      alignItems: "center",
      style: {
        height: "300px"
      },
      children: /*#__PURE__*/jsx(Spinner, {
        size: "lg",
        color: "primary"
      })
    });
  }
  if (walletData) {
    return /*#__PURE__*/jsx(ReconnectLocalWallet, {
      renderBackButton: props.supportedWallets.length > 1,
      supportedWallets: props.supportedWallets,
      onConnect: props.close,
      goBack: props.goBack,
      localWallet: props.walletConfig,
      persist: props.persist
    });
  }
  return /*#__PURE__*/jsx(CreateLocalWallet_Password, {
    goBack: props.goBack,
    localWalletConf: props.walletConfig,
    onConnect: props.close,
    renderBackButton: props.supportedWallets.length > 1,
    persist: props.persist
  });
};

const localWallet = config => {
  return {
    id: LocalWallet.id,
    meta: {
      ...LocalWallet.meta,
      name: "Guest Wallet"
    },
    create: options => new LocalWallet(options),
    connectUI(props) {
      return /*#__PURE__*/jsx(LocalWalletConnectUI, {
        ...props,
        persist: config && config.persist !== undefined ? config.persist : true
      });
    }
  };
};

const SmartWalletConnecting = props => {
  const activeWallet = useWallet(); // personal wallet

  const connect = useConnect();
  const connectedChain = useChain();
  const targetChain = useWalletContext().activeChain;
  const mismatch = useNetworkMismatch();
  const [connectError, setConnectError] = useState(false);
  const [switchError, setSwitchError] = useState(false);
  const [switchingNetwork, setSwitchingNetwork] = useState(false);
  const connectionStatus = useConnectionStatus();
  const requiresConfirmation = !useIsHeadlessWallet();
  const {
    onConnect
  } = props;
  const connectStarted = useRef(false);
  const switchChain = useSwitchChain();
  const handleConnect = useCallback(async () => {
    if (!activeWallet || !connectedChain || connectStarted.current) {
      return;
    }
    setConnectError(false);
    try {
      connectStarted.current = true;
      await connect(props.smartWallet, {
        personalWallet: activeWallet
      });
      onConnect();
    } catch (e) {
      console.error(e);
      setConnectError(true);
    }
  }, [activeWallet, connectedChain, connect, props.smartWallet, onConnect]);
  useEffect(() => {
    if (!mismatch) {
      handleConnect();
    }
  }, [mismatch, handleConnect, activeWallet, connectedChain]);
  if (connectionStatus === "connecting" || !mismatch) {
    return /*#__PURE__*/jsxs(Flex, {
      style: {
        height: "300px",
        justifyContent: "center",
        flexDirection: "column",
        gap: spacing.xl,
        alignItems: "center"
      },
      children: [/*#__PURE__*/jsx(ModalTitle, {
        children: "Connecting to Smart Wallet "
      }), /*#__PURE__*/jsx(Spinner, {
        color: "link",
        size: "lg"
      })]
    });
  }
  return /*#__PURE__*/jsxs(Fragment, {
    children: [/*#__PURE__*/jsx(BackButton, {
      onClick: props.onBack
    }), /*#__PURE__*/jsx(Spacer, {
      y: "md"
    }), /*#__PURE__*/jsx(Img, {
      src: props.smartWallet.meta.iconURL,
      width: iconSize.xl,
      height: iconSize.xl
    }), /*#__PURE__*/jsx(Spacer, {
      y: "lg"
    }), /*#__PURE__*/jsx(ModalTitle, {
      children: "Network Mismatch"
    }), /*#__PURE__*/jsx(Spacer, {
      y: "md"
    }), /*#__PURE__*/jsx(ModalDescription, {
      children: "Selected wallet is not connected to the required network"
    }), /*#__PURE__*/jsx(Spacer, {
      y: "lg"
    }), connectError && /*#__PURE__*/jsxs(ErrorMessage$1, {
      style: {
        display: "flex",
        gap: spacing.sm,
        alignItems: "center",
        fontSize: fontSize.sm
      },
      children: [/*#__PURE__*/jsx(ExclamationTriangleIcon, {
        width: iconSize.sm,
        height: iconSize.sm
      }), /*#__PURE__*/jsxs("span", {
        children: ["Could not connect to Smart Wallet. ", /*#__PURE__*/jsx("br", {})]
      })]
    }), /*#__PURE__*/jsxs(Button, {
      type: "button",
      variant: "secondary",
      style: {
        display: "flex",
        alignItems: "center",
        gap: spacing.sm
      },
      onClick: async () => {
        if (!activeWallet) {
          throw new Error("No active wallet");
        }
        setConnectError(false);
        setSwitchError(false);
        setSwitchingNetwork(true);
        try {
          await switchChain(targetChain.chainId);
        } catch (e) {
          setSwitchError(true);
        } finally {
          setSwitchingNetwork(false);
        }
      },
      children: [" ", switchingNetwork ? "Switching" : "Switch Network", switchingNetwork && /*#__PURE__*/jsx(Spinner, {
        size: "sm",
        color: "primary"
      })]
    }), /*#__PURE__*/jsx(Spacer, {
      y: "md"
    }), switchingNetwork && requiresConfirmation && /*#__PURE__*/jsx(ConfirmMessage, {
      children: " Confirm in your wallet "
    }), switchError && /*#__PURE__*/jsxs(ErrorMessage$1, {
      style: {
        display: "flex",
        gap: spacing.sm,
        alignItems: "center",
        fontSize: fontSize.sm
      },
      children: [/*#__PURE__*/jsx(ExclamationTriangleIcon, {
        width: iconSize.sm,
        height: iconSize.sm
      }), /*#__PURE__*/jsx("span", {
        children: "Failed to switch network."
      })]
    })]
  });
};
const ConfirmMessage = styled.p`
  font-size: ${fontSize.sm};
  margin: 0;
  color: ${p => p.theme.link.primary};
`;

const SelectPersonalWallet = props => {
  const guestWallet = props.personalWallets.find(w => w.id === walletIds.localWallet);
  const personalWallets = props.personalWallets.filter(w => w.id !== walletIds.localWallet);
  return /*#__PURE__*/jsxs(Fragment, {
    children: [props.renderBackButton && /*#__PURE__*/jsx(BackButton, {
      onClick: props.onBack
    }), /*#__PURE__*/jsx(IconContainer, {
      children: /*#__PURE__*/jsx(Img, {
        src: props.smartWallet.meta.iconURL,
        width: iconSize.xl,
        height: iconSize.xl
      })
    }), /*#__PURE__*/jsx(Spacer, {
      y: "lg"
    }), /*#__PURE__*/jsx(ModalTitle, {
      children: "Link Personal Wallet"
    }), /*#__PURE__*/jsx(Spacer, {
      y: "sm"
    }), /*#__PURE__*/jsxs(ModalDescription, {
      children: ["Select a personal wallet to access your account.", " ", /*#__PURE__*/jsxs(HelperLink, {
        md: true,
        href: "https://portal.thirdweb.com/wallet/smart-wallet",
        target: "_blank",
        style: {
          display: "inline",
          whiteSpace: "nowrap"
        },
        children: [" ", "Learn More", " "]
      })]
    }), /*#__PURE__*/jsx(Spacer, {
      y: "lg"
    }), /*#__PURE__*/jsx(WalletSelection, {
      walletConfigs: personalWallets,
      selectWallet: props.selectWallet
    }), guestWallet && /*#__PURE__*/jsxs(Fragment, {
      children: [/*#__PURE__*/jsx(Spacer, {
        y: "xl"
      }), /*#__PURE__*/jsx(Flex, {
        justifyContent: "center",
        children: /*#__PURE__*/jsx(Button, {
          variant: "link",
          onClick: () => {
            props.selectWallet(guestWallet);
          },
          "data-test": "continue-as-guest-button",
          children: "Continue as guest"
        })
      })]
    })]
  });
};
const IconContainer = styled.div`
  margin-top: ${spacing.lg};
`;

const smartWallet = config => {
  const personalWallets = config?.personalWallets || defaultWallets;
  return {
    id: SmartWallet.id,
    meta: SmartWallet.meta,
    create: options => new SmartWallet({
      ...options,
      ...config
    }),
    connectUI(props) {
      return /*#__PURE__*/jsx(SmartConnectUI, {
        ...props,
        personalWallets: personalWallets
      });
    },
    personalWallets
  };
};
const SmartConnectUI = props => {
  const activeWallet = useWallet();
  const {
    walletConfig
  } = props;
  const [personalWalletConfig, setPersonalWalletConfig] = useState();
  if (personalWalletConfig) {
    const _props = {
      close: () => {
        setPersonalWalletConfig(undefined);
        props.close(false); // do not reset UI
      },

      goBack: () => {
        setPersonalWalletConfig(undefined);
      },
      isOpen: props.isOpen,
      open: props.open,
      theme: props.theme,
      walletConfig: personalWalletConfig,
      supportedWallets: props.personalWallets,
      selectionData: props.selectionData,
      setSelectionData: props.setSelectionData
    };
    if (personalWalletConfig.connectUI) {
      return /*#__PURE__*/jsx(personalWalletConfig.connectUI, {
        ..._props
      });
    }
    return /*#__PURE__*/jsx(HeadlessConnectUI, {
      ..._props
    });
  }
  if (!activeWallet) {
    return /*#__PURE__*/jsx(SelectPersonalWallet, {
      personalWallets: props.personalWallets,
      onBack: props.goBack,
      smartWallet: walletConfig,
      selectWallet: setPersonalWalletConfig,
      renderBackButton: props.supportedWallets.length > 1
    });
  }
  return /*#__PURE__*/jsx(SmartWalletConnecting, {
    onBack: props.goBack,
    onConnect: props.close,
    smartWallet: walletConfig
  });
};

var smartWallet$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  smartWallet: smartWallet,
  SmartConnectUI: SmartConnectUI
});

const ZerionScan = _ref => {
  let {
    onBack,
    onConnected,
    onGetStarted,
    walletConfig
  } = _ref;
  const createInstance = useCreateWalletInstance();
  const [qrCodeUri, setQrCodeUri] = useState();
  const {
    setConnectedWallet,
    chainToConnect,
    setConnectionStatus
  } = useWalletContext();
  const scanStarted = useRef(false);
  useEffect(() => {
    if (scanStarted.current) {
      return;
    }
    scanStarted.current = true;
    const zerion = createInstance(walletConfig);
    setConnectionStatus("connecting");
    zerion.connectWithQrCode({
      chainId: chainToConnect?.chainId,
      onQrCodeUri(uri) {
        setQrCodeUri(uri);
      },
      onConnected() {
        setConnectedWallet(zerion);
        onConnected();
      }
    });
  }, [createInstance, setConnectedWallet, chainToConnect, onConnected, walletConfig, setConnectionStatus]);
  return /*#__PURE__*/jsx(ScanScreen, {
    onBack: onBack,
    onGetStarted: onGetStarted,
    qrCodeUri: qrCodeUri,
    walletName: walletConfig.meta.name,
    walletIconURL: walletConfig.meta.iconURL
  });
};

const ZerionConnectUI = props => {
  const [screen, setScreen] = useState("connecting");
  const {
    walletConfig,
    close
  } = props;
  const connect = useConnect();
  const {
    goBack
  } = props;
  const connectPrompted = useRef(false);
  useEffect(() => {
    if (connectPrompted.current) {
      return;
    }
    const isInstalled = walletConfig.isInstalled ? walletConfig.isInstalled() : false;

    // if loading
    (async () => {
      if (isInstalled) {
        try {
          connectPrompted.current = true;
          setScreen("connecting");
          await connect(walletConfig);
          close();
        } catch (e) {
          goBack();
        }
      }

      // if zerion is not injected
      else {
        // on mobile, open zerion app link
        if (isMobile()) {
          window.open("https://link.zerion.io/pt3gdRP0njb");
        } else {
          // on desktop, show the metamask scan qr code
          setScreen("scanning");
        }
      }
    })();
  }, [walletConfig, close, connect, goBack]);
  if (screen === "connecting") {
    return /*#__PURE__*/jsx(ConnectingScreen, {
      onBack: props.goBack,
      walletName: walletConfig.meta.name,
      walletIconURL: walletConfig.meta.iconURL,
      supportLink: "https://help.zerion.io/en/"
    });
  }
  if (screen === "get-started") {
    return /*#__PURE__*/jsx(GetStartedScreen, {
      walletIconURL: walletConfig.meta.iconURL,
      walletName: walletConfig.meta.name,
      chromeExtensionLink: walletConfig.meta.urls?.chrome,
      googlePlayStoreLink: walletConfig.meta.urls?.android,
      appleStoreLink: walletConfig.meta.urls?.ios,
      onBack: props.goBack
    });
  }
  if (screen === "scanning") {
    return /*#__PURE__*/jsx(ZerionScan, {
      onBack: props.goBack,
      onConnected: close,
      onGetStarted: () => {
        setScreen("get-started");
      },
      walletConfig: walletConfig
    });
  }
  return null;
};

const zerionWallet = () => {
  return {
    id: ZerionWallet.id,
    meta: ZerionWallet.meta,
    create: options => {
      return new ZerionWallet(options);
    },
    connectUI: ZerionConnectUI,
    isInstalled() {
      if (assertWindowEthereum(globalThis.window)) {
        return !!globalThis.window.ethereum.isZerion;
      }
      return false;
    }
  };
};

export { localWallet, smartWallet, useSmartWallet, zerionWallet };
