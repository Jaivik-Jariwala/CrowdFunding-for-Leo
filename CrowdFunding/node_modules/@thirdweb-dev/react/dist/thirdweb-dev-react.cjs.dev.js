'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var reactCore = require('@thirdweb-dev/react-core');
var React = require('react');
var wallets = require('@thirdweb-dev/wallets');
var basic = require('./basic-cf8743c1.cjs.dev.js');
var coinbaseWallet = require('./headlessConnectUI-37c9fce2.cjs.dev.js');
var reactIcons = require('@radix-ui/react-icons');
var styled = require('@emotion/styled');
var jsxRuntime = require('react/jsx-runtime');
var InputSelectionUI = require('./InputSelectionUI-1c98eb97.cjs.dev.js');
var useWalletConnect = require('./useWalletConnect-65d0b2ff.cjs.dev.js');
var frameWallet = require('./frameWallet-43e8289b.cjs.dev.js');
var paperWallet = require('./paperWallet-3db9ec91.cjs.dev.js');
var safeWallet = require('./safeWallet-4c9dd5f9.cjs.dev.js');
var walletConnect = require('./walletConnect-cf0210b5.cjs.dev.js');
var magicLink = require('./magicLink-e00fef8a.cjs.dev.js');
var useSafe = require('./useSafe-b05b8fc7.cjs.dev.js');
var useMagic = require('./useMagic-d914d0f0.cjs.dev.js');
require('@emotion/react');
require('@radix-ui/colors');
require('detect-browser');
require('react-qr-code');
require('@radix-ui/react-dialog');
require('@tanstack/react-query');
require('@radix-ui/react-popover');
require('copy-to-clipboard');
require('@radix-ui/react-tooltip');
require('ethers');
require('@radix-ui/react-tabs');
require('fuse.js');
require('@radix-ui/react-dropdown-menu');
require('@thirdweb-dev/chains');
require('tiny-invariant');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var styled__default = /*#__PURE__*/_interopDefault(styled);

function useSmartWallet() {
  const connect = reactCore.useConnect();
  return React.useCallback(async options => {
    const {
      smartWallet
    } = await Promise.resolve().then(function () { return smartWallet$1; });
    return connect(smartWallet(options), options);
  }, [connect]);
}

function useLocalWalletInfo(localWalletConfig, persist) {
  const [walletData, setWalletData] = React.useState("loading");
  const createWalletInstance = reactCore.useCreateWalletInstance();
  const [localWallet, setLocalWallet] = React.useState(null);
  React.useEffect(() => {
    const wallet = createWalletInstance(localWalletConfig);
    setLocalWallet(wallet);
    if (persist) {
      wallet.getSavedData().then(data => {
        setWalletData(data);
      });
    }
  }, [createWalletInstance, localWalletConfig, persist]);
  return {
    setLocalWallet,
    localWallet,
    walletData,
    meta: localWalletConfig.meta,
    persist: persist
  };
}

const DragNDrop = props => {
  const [error, setError] = React.useState(false);
  const [uploaded, setUploaded] = React.useState();
  const [isDragging, setIsDragging] = React.useState(false);
  const dragIn = e => {
    setError(false);
    setUploaded(undefined);
    setIsDragging(true);
    e.preventDefault();
    e.stopPropagation();
  };
  const dragOut = e => {
    setIsDragging(false);
    e.preventDefault();
    e.stopPropagation();
  };
  const handleFileUpload = file => {
    if (file.type !== props.accept) {
      setError(true);
    } else {
      setUploaded(file);
      props.onUpload(file);
    }
  };
  const drop = e => {
    setIsDragging(false);
    e.preventDefault();
    e.stopPropagation();
    if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
      handleFileUpload(e.dataTransfer.files[0]);
      e.dataTransfer.clearData();
    }
  };
  const message = coinbaseWallet.isMobile() ? "Click to Upload" : "Drop your file here or click to upload";
  return /*#__PURE__*/jsxRuntime.jsx("div", {
    onDragEnter: dragIn,
    onDragLeave: dragOut,
    onDragOver: e => {
      setIsDragging(true);
      e.preventDefault();
      e.stopPropagation();
    },
    onClick: () => {
      setError(false);
    },
    onDrop: drop,
    style: {
      cursor: "pointer"
    },
    children: /*#__PURE__*/jsxRuntime.jsxs("label", {
      htmlFor: "file-upload",
      children: [/*#__PURE__*/jsxRuntime.jsx("input", {
        id: "file-upload",
        type: "file",
        accept: props.accept,
        multiple: false,
        style: {
          display: "none"
        },
        onChange: e => {
          if (e.target.files && e.target.files.length > 0) {
            handleFileUpload(e.target.files[0]);
          }
        }
      }), /*#__PURE__*/jsxRuntime.jsx(DropContainer, {
        "data-error": error,
        "data-is-dragging": isDragging,
        children: !uploaded ? /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
          children: [" ", /*#__PURE__*/jsxRuntime.jsx(UploadIconSecondary, {
            width: basic.iconSize.xl,
            height: basic.iconSize.xl
          }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
            y: "md"
          }), /*#__PURE__*/jsxRuntime.jsx(Message, {
            children: message
          }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
            y: "md"
          }), error ? /*#__PURE__*/jsxRuntime.jsxs(ErrorMessage, {
            children: [" ", "Please upload a ", props.extension, " file", " "]
          }) : /*#__PURE__*/jsxRuntime.jsxs(ExtensionText, {
            children: [" ", props.extension, " "]
          })]
        }) : /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
          children: [/*#__PURE__*/jsxRuntime.jsxs(Message, {
            children: [uploaded.name, " uploaded successfully"]
          }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
            y: "md"
          }), /*#__PURE__*/jsxRuntime.jsx(CheckCircleIcon, {
            size: basic.iconSize.xl
          })]
        })
      })]
    })
  });
};
const UploadIconSecondary = styled__default["default"](reactIcons.UploadIcon)`
  color: ${props => props.theme.text.secondary};
  transition: transform 200ms ease, color 200ms ease;
`;
const DropContainer = styled__default["default"].div`
  border: 2px solid ${p => p.theme.bg.elevated};
  border-radius: ${basic.radius.md};
  padding: ${basic.spacing.xl} ${basic.spacing.md};
  display: flex;
  align-items: center;
  flex-direction: column;
  cursor: pointer;
  transition: border-color 200ms ease;

  &:hover,
  &[data-is-dragging="true"] {
    border-color: ${p => p.theme.link.primary};
    svg {
      color: ${p => p.theme.link.primary};
    }
  }

  &[data-error="true"] {
    border-color: ${p => p.theme.input.errorRing};
  }
`;
const ErrorMessage = styled__default["default"].p`
  color: ${p => p.theme.input.errorRing};
  font-size: ${basic.fontSize.sm};
  margin: 0;
`;
const ExtensionText = styled__default["default"].span`
  color: ${p => p.theme.text.secondary};
  font-size: ${basic.fontSize.sm};
`;
const CheckCircleIcon = props => /*#__PURE__*/jsxRuntime.jsxs("svg", {
  width: props.size,
  height: props.size,
  viewBox: "0 0 38 38",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  children: [/*#__PURE__*/jsxRuntime.jsx("path", {
    d: "M35.6666 17.4671V19.0004C35.6645 22.5945 34.5008 26.0916 32.3488 28.9701C30.1969 31.8487 27.1721 33.9546 23.7255 34.9736C20.279 35.9926 16.5954 35.8703 13.224 34.6247C9.85272 33.3792 6.97434 31.0773 5.01819 28.0622C3.06203 25.0472 2.1329 21.4805 2.36938 17.8943C2.60586 14.308 3.99526 10.8943 6.33039 8.16221C8.66551 5.43012 11.8212 3.52606 15.3269 2.734C18.8326 1.94194 22.5004 2.30432 25.7833 3.76709",
    stroke: "#5BD58C",
    strokeWidth: "3.33333",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /*#__PURE__*/jsxRuntime.jsx("path", {
    d: "M35.6667 5.66699L19 22.3503L14 17.3503",
    stroke: "#5BD58C",
    strokeWidth: "3.33333",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  })]
});
const Message = styled__default["default"].p`
  color: ${p => p.theme.text.neutral};
  font-size: ${basic.fontSize.md};
  margin: 0;
  font-weight: 600;
`;

const LocalWalletModalHeader = props => {
  return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [!props.hideBack && /*#__PURE__*/jsxRuntime.jsx(coinbaseWallet.BackButton, {
      onClick: props.onBack
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
      y: "md"
    }), /*#__PURE__*/jsxRuntime.jsx(coinbaseWallet.Img, {
      src: props.meta.iconURL,
      width: basic.iconSize.xl,
      height: basic.iconSize.xl
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
      y: "sm"
    })]
  });
};

const ImportLocalWallet = props => {
  const [jsonString, setJsonString] = React.useState();
  const {
    setLocalWallet,
    meta
  } = useLocalWalletInfo(props.localWalletConf, props.persist);
  const createWalletInstance = reactCore.useCreateWalletInstance();
  const [password, setPassword] = React.useState("");
  const [isWrongPassword, setIsWrongPassword] = React.useState(false);
  const [showPassword, setShowPassword] = React.useState(false);
  const [importedAddress, setImportedAddress] = React.useState();
  const {
    setConnectedWallet,
    setConnectionStatus
  } = reactCore.useWalletContext();
  const handleImport = async () => {
    const localWallet = createWalletInstance(props.localWalletConf);
    if (!localWallet || !jsonString) {
      throw new Error("Invalid state");
    }
    try {
      await localWallet.import({
        encryptedJson: jsonString,
        password
      });
    } catch (e) {
      console.error(e);
      setIsWrongPassword(true);
      return;
    }
    setConnectionStatus("connecting");
    await localWallet.connect();
    await localWallet.save({
      strategy: "encryptedJson",
      password
    });
    setConnectedWallet(localWallet);
    setLocalWallet(localWallet);
    props.onConnect();
  };
  return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [/*#__PURE__*/jsxRuntime.jsx(LocalWalletModalHeader, {
      onBack: props.goBack,
      meta: meta
    }), /*#__PURE__*/jsxRuntime.jsx(coinbaseWallet.ModalTitle, {
      style: {
        textAlign: "left"
      },
      children: "Import Wallet"
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
      y: "md"
    }), /*#__PURE__*/jsxRuntime.jsx(coinbaseWallet.ModalDescription, {
      children: "The application can authorize any transactions on behalf of the wallet without any approvals. We recommend only connecting to trusted applications."
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
      y: "lg"
    }), /*#__PURE__*/jsxRuntime.jsx(DragNDrop, {
      extension: "JSON",
      accept: "application/json",
      onUpload: file => {
        const reader = new FileReader();
        reader.onload = event => {
          setJsonString(event.target?.result);
          const obj = JSON.parse(event.target?.result);
          setImportedAddress(obj.address);
        };
        reader.readAsText(file, "utf-8");
      }
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
      y: "lg"
    }), /*#__PURE__*/jsxRuntime.jsxs("form", {
      onSubmit: e => {
        e.preventDefault();
        handleImport();
      },
      children: [jsonString && /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
        children: [/*#__PURE__*/jsxRuntime.jsx("input", {
          type: "text",
          name: "username",
          autoComplete: "off",
          value: importedAddress || "",
          disabled: true,
          style: {
            display: "none"
          }
        }), /*#__PURE__*/jsxRuntime.jsx(coinbaseWallet.FormFieldWithIconButton, {
          required: true,
          noSave: true,
          name: "password",
          autocomplete: "off",
          id: "password",
          onChange: value => {
            setPassword(value);
            setIsWrongPassword(false);
          },
          right: {
            onClick: () => setShowPassword(!showPassword),
            icon: showPassword ? /*#__PURE__*/jsxRuntime.jsx(reactIcons.EyeClosedIcon, {}) : /*#__PURE__*/jsxRuntime.jsx(reactIcons.EyeOpenIcon, {})
          },
          label: "Password",
          type: showPassword ? "text" : "password",
          value: password,
          error: isWrongPassword ? "Wrong Password" : ""
        }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
          y: "xl"
        })]
      }), /*#__PURE__*/jsxRuntime.jsx(basic.FormFooter, {
        children: /*#__PURE__*/jsxRuntime.jsx(basic.Button, {
          variant: "inverted",
          type: "submit",
          disabled: !jsonString,
          style: {
            minWidth: "110px",
            opacity: jsonString ? 1 : 0.5
          },
          children: "Import"
        })
      })]
    })]
  });
};

const CreateLocalWallet_Password = props => {
  const [password, setPassword] = React.useState("");
  const [confirmPassword, setConfirmPassword] = React.useState("");
  const [showPassword, setShowPassword] = React.useState(false);
  const passwordMismatch = confirmPassword && password !== confirmPassword;
  const [isConnecting, setIsConnecting] = React.useState(false);
  const {
    localWallet,
    meta
  } = useLocalWalletInfo(props.localWalletConf, props.persist);
  const {
    setConnectedWallet,
    setConnectionStatus
  } = reactCore.useWalletContext();
  const [showImportScreen, setShowImportScreen] = React.useState(false);
  const [generatedAddress, setGeneratedAddress] = React.useState(null);

  // generating wallet before it's required to render a form with hidden address as username for better autofill
  React.useEffect(() => {
    if (!localWallet || showImportScreen || localWallet.ethersWallet) {
      return;
    }
    localWallet.generate().then(_address => {
      setGeneratedAddress(_address);
    });
  }, [localWallet, showImportScreen]);
  if (showImportScreen) {
    return /*#__PURE__*/jsxRuntime.jsx(ImportLocalWallet, {
      localWalletConf: props.localWalletConf,
      onConnect: props.onConnect,
      goBack: () => {
        setShowImportScreen(false);
      },
      persist: props.persist
    });
  }
  const handleConnect = async () => {
    if (passwordMismatch || !localWallet) {
      throw new Error("Invalid state");
    }
    setIsConnecting(true);
    setConnectionStatus("connecting");
    await localWallet.connect();
    await localWallet.save({
      strategy: "encryptedJson",
      password
    });
    setConnectedWallet(localWallet);
    setIsConnecting(false);
    props.onConnect();
  };
  return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [/*#__PURE__*/jsxRuntime.jsx(LocalWalletModalHeader, {
      onBack: props.goBack,
      meta: meta,
      hideBack: !props.renderBackButton
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Flex, {
      alignItems: "center",
      gap: "xs",
      children: /*#__PURE__*/jsxRuntime.jsx(coinbaseWallet.ModalTitle, {
        children: "Guest Wallet"
      })
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
      y: "sm"
    }), /*#__PURE__*/jsxRuntime.jsxs(coinbaseWallet.ModalDescription, {
      children: ["Choose a password for your wallet, you", `'`, "ll be able to access and export this wallet with the same password."]
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
      y: "lg"
    }), /*#__PURE__*/jsxRuntime.jsxs("form", {
      onSubmit: e => {
        e.preventDefault();
        handleConnect();
      },
      children: [/*#__PURE__*/jsxRuntime.jsx("input", {
        type: "text",
        name: "username",
        autoComplete: "off",
        value: generatedAddress || "",
        disabled: true,
        style: {
          display: "none"
        }
      }), /*#__PURE__*/jsxRuntime.jsx(coinbaseWallet.FormFieldWithIconButton, {
        name: "password",
        required: true,
        autocomplete: "new-password",
        id: "new-password",
        onChange: value => setPassword(value),
        right: {
          icon: showPassword ? /*#__PURE__*/jsxRuntime.jsx(reactIcons.EyeClosedIcon, {}) : /*#__PURE__*/jsxRuntime.jsx(reactIcons.EyeOpenIcon, {}),
          onClick: () => setShowPassword(!showPassword)
        },
        label: "Password",
        type: showPassword ? "text" : "password",
        value: password,
        dataTest: "new-password"
      }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
        y: "lg"
      }), /*#__PURE__*/jsxRuntime.jsx(coinbaseWallet.FormFieldWithIconButton, {
        name: "confirm-password",
        required: true,
        autocomplete: "new-password",
        id: "confirm-password",
        onChange: value => setConfirmPassword(value),
        right: {
          icon: showPassword ? /*#__PURE__*/jsxRuntime.jsx(reactIcons.EyeClosedIcon, {}) : /*#__PURE__*/jsxRuntime.jsx(reactIcons.EyeOpenIcon, {}),
          onClick: () => setShowPassword(!showPassword)
        },
        label: "Confirm Password",
        type: showPassword ? "text" : "password",
        value: confirmPassword,
        error: passwordMismatch ? "Passwords don't match" : "",
        dataTest: "confirm-password"
      }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
        y: "xl"
      }), /*#__PURE__*/jsxRuntime.jsxs(basic.Button, {
        variant: "inverted",
        type: "submit",
        style: {
          width: "100%",
          gap: basic.spacing.sm
        },
        "data-test": "create-new-wallet-button",
        children: [isConnecting ? "Connecting" : "Create new wallet", isConnecting && /*#__PURE__*/jsxRuntime.jsx(basic.Spinner, {
          size: "sm",
          color: "inverted"
        })]
      })]
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
      y: "xxl"
    }), /*#__PURE__*/jsxRuntime.jsx(InputSelectionUI.TextDivider, {
      children: /*#__PURE__*/jsxRuntime.jsx("span", {
        children: "OR"
      })
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
      y: "lg"
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Flex, {
      justifyContent: "center",
      children: /*#__PURE__*/jsxRuntime.jsx(basic.Button, {
        variant: "link",
        onClick: () => {
          setShowImportScreen(true);
        },
        children: "Import wallet"
      })
    })]
  });
};
const CreateLocalWallet_Guest = props => {
  const {
    localWallet
  } = useLocalWalletInfo(props.localWallet, props.persist);
  const {
    setConnectedWallet,
    setConnectionStatus
  } = reactCore.useWalletContext();
  const {
    onConnect
  } = props;
  const handleConnect = React.useCallback(async () => {
    if (!localWallet) {
      throw new Error("Invalid state");
    }
    await localWallet.generate();
    setConnectionStatus("connecting");
    await localWallet.connect();
    setConnectedWallet(localWallet);
    onConnect();
  }, [localWallet, setConnectedWallet, onConnect, setConnectionStatus]);
  const connecting = React.useRef(false);
  React.useEffect(() => {
    if (connecting.current || !localWallet) {
      return;
    }
    connecting.current = true;
    handleConnect();
  }, [handleConnect, localWallet]);
  return /*#__PURE__*/jsxRuntime.jsx(basic.Flex, {
    justifyContent: "center",
    alignItems: "center",
    style: {
      height: "300px"
    },
    children: /*#__PURE__*/jsxRuntime.jsx(basic.Spinner, {
      size: "lg",
      color: "link"
    })
  });
};

const OverrideConfirmation = props => {
  return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [/*#__PURE__*/jsxRuntime.jsx(LocalWalletModalHeader, {
      onBack: props.onBack,
      meta: props.meta
    }), /*#__PURE__*/jsxRuntime.jsx(coinbaseWallet.ModalTitle, {
      children: "Backup your wallet"
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
      y: "md"
    }), /*#__PURE__*/jsxRuntime.jsxs("div", {
      style: {
        lineHeight: 1.5
      },
      children: [/*#__PURE__*/jsxRuntime.jsx(useWalletConnect.SecondaryText, {
        children: "Your current wallet will be deleted if you create a new wallet. Backup wallet to your device before creating a new wallet"
      }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
        y: "xl"
      }), /*#__PURE__*/jsxRuntime.jsx(basic.FormFooter, {
        children: /*#__PURE__*/jsxRuntime.jsx(basic.Button, {
          variant: "inverted",
          onClick: props.onBackup,
          children: "Backup wallet"
        })
      })]
    })]
  });
};

/**
 * For No-Credential scenario
 */
const ReconnectLocalWallet = props => {
  const [password, setPassword] = React.useState("");
  const [showPassword, setShowPassword] = React.useState(false);
  const [isWrongPassword, setIsWrongPassword] = React.useState(false);
  const {
    setConnectedWallet,
    setConnectionStatus
  } = reactCore.useWalletContext();
  const [isConnecting, setIsConnecting] = React.useState(false);
  const [showCreate, setShowCreate] = React.useState(false);
  const [showBackupConfirmation, setShowBackupConfirmation] = React.useState(false);
  const [showExport, setShowExport] = React.useState(false);
  const {
    localWallet,
    meta,
    walletData
  } = useLocalWalletInfo(props.localWallet, props.persist);
  const savedAddress = walletData ? walletData === "loading" ? "" : walletData.address : "";
  if (showExport) {
    if (!localWallet) {
      throw new Error("Invalid state");
    }
    return /*#__PURE__*/jsxRuntime.jsx(useWalletConnect.ExportLocalWallet, {
      localWalletConfig: props.localWallet,
      onBack: () => {
        setShowExport(false);
      },
      onExport: () => {
        setShowExport(false);
        setShowBackupConfirmation(false);
        setShowCreate(true);
      }
    });
  }
  if (showBackupConfirmation) {
    return /*#__PURE__*/jsxRuntime.jsx(OverrideConfirmation, {
      meta: meta,
      onBackup: () => {
        setShowExport(true);
      },
      onBack: () => {
        setShowBackupConfirmation(false);
      }
    });
  }
  if (showCreate) {
    return /*#__PURE__*/jsxRuntime.jsx(CreateLocalWallet_Password, {
      renderBackButton: props.supportedWallets.length > 1,
      localWalletConf: props.localWallet,
      goBack: () => {
        setShowCreate(false);
      },
      onConnect: props.onConnect,
      persist: props.persist
    });
  }
  const handleReconnect = async () => {
    if (!localWallet) {
      throw new Error("Invalid state");
    }
    setIsConnecting(true);
    try {
      await localWallet.load({
        strategy: "encryptedJson",
        password
      });
      setConnectionStatus("connecting");
      await localWallet.connect();
      setConnectedWallet(localWallet);
      props.onConnect();
    } catch (e) {
      setIsWrongPassword(true);
    }
    setIsConnecting(false);
  };
  return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [/*#__PURE__*/jsxRuntime.jsx(LocalWalletModalHeader, {
      onBack: props.goBack,
      meta: meta,
      hideBack: !props.renderBackButton
    }), /*#__PURE__*/jsxRuntime.jsx(coinbaseWallet.ModalTitle, {
      style: {
        textAlign: "left"
      },
      children: "Guest Wallet"
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
      y: "xs"
    }), /*#__PURE__*/jsxRuntime.jsx(coinbaseWallet.ModalDescription, {
      children: "Connect to saved wallet on your device"
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
      y: "lg"
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Label, {
      children: "Saved Wallet"
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
      y: "sm"
    }), /*#__PURE__*/jsxRuntime.jsx(useWalletConnect.SecondaryText, {
      children: savedAddress === "" ? "Loading..." : useWalletConnect.shortenAddress(savedAddress)
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
      y: "lg"
    }), /*#__PURE__*/jsxRuntime.jsxs("form", {
      onSubmit: e => {
        e.preventDefault();
        handleReconnect();
      },
      children: [/*#__PURE__*/jsxRuntime.jsx("input", {
        type: "text",
        name: "username",
        autoComplete: "off",
        value: savedAddress,
        disabled: true,
        style: {
          display: "none"
        }
      }), /*#__PURE__*/jsxRuntime.jsx(coinbaseWallet.FormFieldWithIconButton, {
        required: true,
        name: "current-password",
        autocomplete: "current-password",
        id: "current-password",
        onChange: value => {
          setPassword(value);
          setIsWrongPassword(false);
        },
        right: {
          onClick: () => setShowPassword(!showPassword),
          icon: showPassword ? /*#__PURE__*/jsxRuntime.jsx(reactIcons.EyeClosedIcon, {}) : /*#__PURE__*/jsxRuntime.jsx(reactIcons.EyeOpenIcon, {})
        },
        label: "Password",
        type: showPassword ? "text" : "password",
        value: password,
        error: isWrongPassword ? "Wrong Password" : "",
        dataTest: "current-password"
      }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
        y: "lg"
      }), /*#__PURE__*/jsxRuntime.jsx(basic.FormFooter, {
        children: /*#__PURE__*/jsxRuntime.jsxs(basic.Button, {
          variant: "inverted",
          type: "submit",
          style: {
            display: "flex",
            gap: basic.spacing.sm
          },
          children: ["Connect", isConnecting && /*#__PURE__*/jsxRuntime.jsx(basic.Spinner, {
            size: "sm",
            color: "inverted"
          })]
        })
      })]
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
      y: "xxl"
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Button, {
      variant: "link",
      style: {
        textAlign: "center",
        width: "100%",
        padding: "2px"
      },
      onClick: () => {
        setShowBackupConfirmation(true);
      },
      children: "Create a new wallet"
    })]
  });
};

const LocalWalletConnectUI = props => {
  const {
    walletData
  } = useLocalWalletInfo(props.walletConfig, props.persist);
  if (!props.persist) {
    return /*#__PURE__*/jsxRuntime.jsx(CreateLocalWallet_Guest, {
      persist: props.persist,
      localWallet: props.walletConfig,
      goBack: props.goBack,
      onConnect: props.close
    });
  }
  if (walletData === "loading") {
    return /*#__PURE__*/jsxRuntime.jsx(basic.Flex, {
      justifyContent: "center",
      alignItems: "center",
      style: {
        height: "300px"
      },
      children: /*#__PURE__*/jsxRuntime.jsx(basic.Spinner, {
        size: "lg",
        color: "primary"
      })
    });
  }
  if (walletData) {
    return /*#__PURE__*/jsxRuntime.jsx(ReconnectLocalWallet, {
      renderBackButton: props.supportedWallets.length > 1,
      supportedWallets: props.supportedWallets,
      onConnect: props.close,
      goBack: props.goBack,
      localWallet: props.walletConfig,
      persist: props.persist
    });
  }
  return /*#__PURE__*/jsxRuntime.jsx(CreateLocalWallet_Password, {
    goBack: props.goBack,
    localWalletConf: props.walletConfig,
    onConnect: props.close,
    renderBackButton: props.supportedWallets.length > 1,
    persist: props.persist
  });
};

const localWallet = config => {
  return {
    id: wallets.LocalWallet.id,
    meta: {
      ...wallets.LocalWallet.meta,
      name: "Guest Wallet"
    },
    create: options => new wallets.LocalWallet(options),
    connectUI(props) {
      return /*#__PURE__*/jsxRuntime.jsx(LocalWalletConnectUI, {
        ...props,
        persist: config && config.persist !== undefined ? config.persist : true
      });
    }
  };
};

const SmartWalletConnecting = props => {
  const activeWallet = reactCore.useWallet(); // personal wallet

  const connect = reactCore.useConnect();
  const connectedChain = reactCore.useChain();
  const targetChain = reactCore.useWalletContext().activeChain;
  const mismatch = reactCore.useNetworkMismatch();
  const [connectError, setConnectError] = React.useState(false);
  const [switchError, setSwitchError] = React.useState(false);
  const [switchingNetwork, setSwitchingNetwork] = React.useState(false);
  const connectionStatus = reactCore.useConnectionStatus();
  const requiresConfirmation = !coinbaseWallet.useIsHeadlessWallet();
  const {
    onConnect
  } = props;
  const connectStarted = React.useRef(false);
  const switchChain = reactCore.useSwitchChain();
  const handleConnect = React.useCallback(async () => {
    if (!activeWallet || !connectedChain || connectStarted.current) {
      return;
    }
    setConnectError(false);
    try {
      connectStarted.current = true;
      await connect(props.smartWallet, {
        personalWallet: activeWallet
      });
      onConnect();
    } catch (e) {
      console.error(e);
      setConnectError(true);
    }
  }, [activeWallet, connectedChain, connect, props.smartWallet, onConnect]);
  React.useEffect(() => {
    if (!mismatch) {
      handleConnect();
    }
  }, [mismatch, handleConnect, activeWallet, connectedChain]);
  if (connectionStatus === "connecting" || !mismatch) {
    return /*#__PURE__*/jsxRuntime.jsxs(basic.Flex, {
      style: {
        height: "300px",
        justifyContent: "center",
        flexDirection: "column",
        gap: basic.spacing.xl,
        alignItems: "center"
      },
      children: [/*#__PURE__*/jsxRuntime.jsx(coinbaseWallet.ModalTitle, {
        children: "Connecting to Smart Wallet "
      }), /*#__PURE__*/jsxRuntime.jsx(basic.Spinner, {
        color: "link",
        size: "lg"
      })]
    });
  }
  return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [/*#__PURE__*/jsxRuntime.jsx(coinbaseWallet.BackButton, {
      onClick: props.onBack
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
      y: "md"
    }), /*#__PURE__*/jsxRuntime.jsx(coinbaseWallet.Img, {
      src: props.smartWallet.meta.iconURL,
      width: basic.iconSize.xl,
      height: basic.iconSize.xl
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
      y: "lg"
    }), /*#__PURE__*/jsxRuntime.jsx(coinbaseWallet.ModalTitle, {
      children: "Network Mismatch"
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
      y: "md"
    }), /*#__PURE__*/jsxRuntime.jsx(coinbaseWallet.ModalDescription, {
      children: "Selected wallet is not connected to the required network"
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
      y: "lg"
    }), connectError && /*#__PURE__*/jsxRuntime.jsxs(basic.ErrorMessage, {
      style: {
        display: "flex",
        gap: basic.spacing.sm,
        alignItems: "center",
        fontSize: basic.fontSize.sm
      },
      children: [/*#__PURE__*/jsxRuntime.jsx(reactIcons.ExclamationTriangleIcon, {
        width: basic.iconSize.sm,
        height: basic.iconSize.sm
      }), /*#__PURE__*/jsxRuntime.jsxs("span", {
        children: ["Could not connect to Smart Wallet. ", /*#__PURE__*/jsxRuntime.jsx("br", {})]
      })]
    }), /*#__PURE__*/jsxRuntime.jsxs(basic.Button, {
      type: "button",
      variant: "secondary",
      style: {
        display: "flex",
        alignItems: "center",
        gap: basic.spacing.sm
      },
      onClick: async () => {
        if (!activeWallet) {
          throw new Error("No active wallet");
        }
        setConnectError(false);
        setSwitchError(false);
        setSwitchingNetwork(true);
        try {
          await switchChain(targetChain.chainId);
        } catch (e) {
          setSwitchError(true);
        } finally {
          setSwitchingNetwork(false);
        }
      },
      children: [" ", switchingNetwork ? "Switching" : "Switch Network", switchingNetwork && /*#__PURE__*/jsxRuntime.jsx(basic.Spinner, {
        size: "sm",
        color: "primary"
      })]
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
      y: "md"
    }), switchingNetwork && requiresConfirmation && /*#__PURE__*/jsxRuntime.jsx(ConfirmMessage, {
      children: " Confirm in your wallet "
    }), switchError && /*#__PURE__*/jsxRuntime.jsxs(basic.ErrorMessage, {
      style: {
        display: "flex",
        gap: basic.spacing.sm,
        alignItems: "center",
        fontSize: basic.fontSize.sm
      },
      children: [/*#__PURE__*/jsxRuntime.jsx(reactIcons.ExclamationTriangleIcon, {
        width: basic.iconSize.sm,
        height: basic.iconSize.sm
      }), /*#__PURE__*/jsxRuntime.jsx("span", {
        children: "Failed to switch network."
      })]
    })]
  });
};
const ConfirmMessage = styled__default["default"].p`
  font-size: ${basic.fontSize.sm};
  margin: 0;
  color: ${p => p.theme.link.primary};
`;

const SelectPersonalWallet = props => {
  const guestWallet = props.personalWallets.find(w => w.id === wallets.walletIds.localWallet);
  const personalWallets = props.personalWallets.filter(w => w.id !== wallets.walletIds.localWallet);
  return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [props.renderBackButton && /*#__PURE__*/jsxRuntime.jsx(coinbaseWallet.BackButton, {
      onClick: props.onBack
    }), /*#__PURE__*/jsxRuntime.jsx(IconContainer, {
      children: /*#__PURE__*/jsxRuntime.jsx(coinbaseWallet.Img, {
        src: props.smartWallet.meta.iconURL,
        width: basic.iconSize.xl,
        height: basic.iconSize.xl
      })
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
      y: "lg"
    }), /*#__PURE__*/jsxRuntime.jsx(coinbaseWallet.ModalTitle, {
      children: "Link Personal Wallet"
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
      y: "sm"
    }), /*#__PURE__*/jsxRuntime.jsxs(coinbaseWallet.ModalDescription, {
      children: ["Select a personal wallet to access your account.", " ", /*#__PURE__*/jsxRuntime.jsxs(coinbaseWallet.HelperLink, {
        md: true,
        href: "https://portal.thirdweb.com/wallet/smart-wallet",
        target: "_blank",
        style: {
          display: "inline",
          whiteSpace: "nowrap"
        },
        children: [" ", "Learn More", " "]
      })]
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
      y: "lg"
    }), /*#__PURE__*/jsxRuntime.jsx(coinbaseWallet.WalletSelection, {
      walletConfigs: personalWallets,
      selectWallet: props.selectWallet
    }), guestWallet && /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
      children: [/*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
        y: "xl"
      }), /*#__PURE__*/jsxRuntime.jsx(basic.Flex, {
        justifyContent: "center",
        children: /*#__PURE__*/jsxRuntime.jsx(basic.Button, {
          variant: "link",
          onClick: () => {
            props.selectWallet(guestWallet);
          },
          "data-test": "continue-as-guest-button",
          children: "Continue as guest"
        })
      })]
    })]
  });
};
const IconContainer = styled__default["default"].div`
  margin-top: ${basic.spacing.lg};
`;

const smartWallet = config => {
  const personalWallets = config?.personalWallets || coinbaseWallet.defaultWallets;
  return {
    id: wallets.SmartWallet.id,
    meta: wallets.SmartWallet.meta,
    create: options => new wallets.SmartWallet({
      ...options,
      ...config
    }),
    connectUI(props) {
      return /*#__PURE__*/jsxRuntime.jsx(SmartConnectUI, {
        ...props,
        personalWallets: personalWallets
      });
    },
    personalWallets
  };
};
const SmartConnectUI = props => {
  const activeWallet = reactCore.useWallet();
  const {
    walletConfig
  } = props;
  const [personalWalletConfig, setPersonalWalletConfig] = React.useState();
  if (personalWalletConfig) {
    const _props = {
      close: () => {
        setPersonalWalletConfig(undefined);
        props.close(false); // do not reset UI
      },

      goBack: () => {
        setPersonalWalletConfig(undefined);
      },
      isOpen: props.isOpen,
      open: props.open,
      theme: props.theme,
      walletConfig: personalWalletConfig,
      supportedWallets: props.personalWallets,
      selectionData: props.selectionData,
      setSelectionData: props.setSelectionData
    };
    if (personalWalletConfig.connectUI) {
      return /*#__PURE__*/jsxRuntime.jsx(personalWalletConfig.connectUI, {
        ..._props
      });
    }
    return /*#__PURE__*/jsxRuntime.jsx(coinbaseWallet.HeadlessConnectUI, {
      ..._props
    });
  }
  if (!activeWallet) {
    return /*#__PURE__*/jsxRuntime.jsx(SelectPersonalWallet, {
      personalWallets: props.personalWallets,
      onBack: props.goBack,
      smartWallet: walletConfig,
      selectWallet: setPersonalWalletConfig,
      renderBackButton: props.supportedWallets.length > 1
    });
  }
  return /*#__PURE__*/jsxRuntime.jsx(SmartWalletConnecting, {
    onBack: props.goBack,
    onConnect: props.close,
    smartWallet: walletConfig
  });
};

var smartWallet$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  smartWallet: smartWallet,
  SmartConnectUI: SmartConnectUI
});

const ZerionScan = _ref => {
  let {
    onBack,
    onConnected,
    onGetStarted,
    walletConfig
  } = _ref;
  const createInstance = reactCore.useCreateWalletInstance();
  const [qrCodeUri, setQrCodeUri] = React.useState();
  const {
    setConnectedWallet,
    chainToConnect,
    setConnectionStatus
  } = reactCore.useWalletContext();
  const scanStarted = React.useRef(false);
  React.useEffect(() => {
    if (scanStarted.current) {
      return;
    }
    scanStarted.current = true;
    const zerion = createInstance(walletConfig);
    setConnectionStatus("connecting");
    zerion.connectWithQrCode({
      chainId: chainToConnect?.chainId,
      onQrCodeUri(uri) {
        setQrCodeUri(uri);
      },
      onConnected() {
        setConnectedWallet(zerion);
        onConnected();
      }
    });
  }, [createInstance, setConnectedWallet, chainToConnect, onConnected, walletConfig, setConnectionStatus]);
  return /*#__PURE__*/jsxRuntime.jsx(coinbaseWallet.ScanScreen, {
    onBack: onBack,
    onGetStarted: onGetStarted,
    qrCodeUri: qrCodeUri,
    walletName: walletConfig.meta.name,
    walletIconURL: walletConfig.meta.iconURL
  });
};

const ZerionConnectUI = props => {
  const [screen, setScreen] = React.useState("connecting");
  const {
    walletConfig,
    close
  } = props;
  const connect = reactCore.useConnect();
  const {
    goBack
  } = props;
  const connectPrompted = React.useRef(false);
  React.useEffect(() => {
    if (connectPrompted.current) {
      return;
    }
    const isInstalled = walletConfig.isInstalled ? walletConfig.isInstalled() : false;

    // if loading
    (async () => {
      if (isInstalled) {
        try {
          connectPrompted.current = true;
          setScreen("connecting");
          await connect(walletConfig);
          close();
        } catch (e) {
          goBack();
        }
      }

      // if zerion is not injected
      else {
        // on mobile, open zerion app link
        if (coinbaseWallet.isMobile()) {
          window.open("https://link.zerion.io/pt3gdRP0njb");
        } else {
          // on desktop, show the metamask scan qr code
          setScreen("scanning");
        }
      }
    })();
  }, [walletConfig, close, connect, goBack]);
  if (screen === "connecting") {
    return /*#__PURE__*/jsxRuntime.jsx(coinbaseWallet.ConnectingScreen, {
      onBack: props.goBack,
      walletName: walletConfig.meta.name,
      walletIconURL: walletConfig.meta.iconURL,
      supportLink: "https://help.zerion.io/en/"
    });
  }
  if (screen === "get-started") {
    return /*#__PURE__*/jsxRuntime.jsx(coinbaseWallet.GetStartedScreen, {
      walletIconURL: walletConfig.meta.iconURL,
      walletName: walletConfig.meta.name,
      chromeExtensionLink: walletConfig.meta.urls?.chrome,
      googlePlayStoreLink: walletConfig.meta.urls?.android,
      appleStoreLink: walletConfig.meta.urls?.ios,
      onBack: props.goBack
    });
  }
  if (screen === "scanning") {
    return /*#__PURE__*/jsxRuntime.jsx(ZerionScan, {
      onBack: props.goBack,
      onConnected: close,
      onGetStarted: () => {
        setScreen("get-started");
      },
      walletConfig: walletConfig
    });
  }
  return null;
};

const zerionWallet = () => {
  return {
    id: wallets.ZerionWallet.id,
    meta: wallets.ZerionWallet.meta,
    create: options => {
      return new wallets.ZerionWallet(options);
    },
    connectUI: ZerionConnectUI,
    isInstalled() {
      if (wallets.assertWindowEthereum(globalThis.window)) {
        return !!globalThis.window.ethereum.isZerion;
      }
      return false;
    }
  };
};

exports.coinbaseWallet = coinbaseWallet.coinbaseWallet;
exports.metamaskWallet = coinbaseWallet.metamaskWallet;
exports.useIsWalletModalOpen = coinbaseWallet.useIsWalletModalOpen;
exports.useSetIsWalletModalOpen = coinbaseWallet.useSetIsWalletModalOpen;
exports.walletConnectV1 = coinbaseWallet.walletConnectV1;
exports.ConnectWallet = useWalletConnect.ConnectWallet;
exports.MediaRenderer = useWalletConnect.MediaRenderer;
exports.NetworkSelector = useWalletConnect.NetworkSelector;
exports.ThirdwebNftMedia = useWalletConnect.ThirdwebNftMedia;
exports.ThirdwebProvider = useWalletConnect.ThirdwebProvider;
exports.Web3Button = useWalletConnect.Web3Button;
exports.useCoinbaseWallet = useWalletConnect.useCoinbaseWallet;
exports.useFrameWallet = useWalletConnect.useFrameWallet;
exports.useInstalledWallets = useWalletConnect.useInstalledWallets;
exports.useMetamask = useWalletConnect.useMetamask;
exports.usePaperWallet = useWalletConnect.usePaperWallet;
exports.usePaperWalletUserEmail = useWalletConnect.usePaperWalletUserEmail;
exports.useResolvedMediaType = useWalletConnect.useResolvedMediaType;
exports.useWalletConnect = useWalletConnect.useWalletConnect;
exports.useWalletConnectV1 = useWalletConnect.useWalletConnectV1;
exports.frameWallet = frameWallet.frameWallet;
exports.paperWallet = paperWallet.paperWallet;
exports.safeWallet = safeWallet.safeWallet;
exports.walletConnect = walletConnect.walletConnect;
exports.magicLink = magicLink.magicLink;
exports.useSafe = useSafe.useSafe;
exports.useMagic = useMagic.useMagic;
exports.localWallet = localWallet;
exports.smartWallet = smartWallet;
exports.useSmartWallet = useSmartWallet;
exports.zerionWallet = zerionWallet;
Object.keys(reactCore).forEach(function (k) {
  if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () { return reactCore[k]; }
  });
});
