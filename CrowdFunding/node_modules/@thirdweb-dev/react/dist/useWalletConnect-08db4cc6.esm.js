import React, { useState, useRef, useEffect, useCallback, useDeferredValue, useContext, useMemo, memo, Suspense, lazy } from 'react';
import { jsx, jsxs, Fragment } from 'react/jsx-runtime';
import { useQuery, useQueryClient, useMutation } from '@tanstack/react-query';
import { useWallet, useAddress, useCreateWalletInstance, resolveIpfsUri, ThirdwebThemeContext, useSupportedChains, useSwitchChain, useChainId, useDisconnect, useBalance, useWalletConfig, useWalletContext, useChain, useSDK, useConnectionStatus, useThirdwebAuthContext, useUser, useLogin, useLogout, useStorage, resolveMimeType, useSDKChainId, useNetworkMismatch, useContract, useWallets, ThirdwebProviderCore, useConnect } from '@thirdweb-dev/react-core';
import { f as fontSize, a as Flex, b as Spinner, i as iconSize, S as Spacer, L as Label, F as FormFooter, B as Button, r as radius, s as spacing, g as shadow, m as media, e as IconButton, I as Input, h as darkTheme, l as lightTheme, E as ErrorMessage$1 } from './basic-d06569f8.esm.js';
import { keyframes, ThemeProvider } from '@emotion/react';
import styled from '@emotion/styled';
import * as RXPopover from '@radix-ui/react-popover';
import copy from 'copy-to-clipboard';
import * as RadixTooltip from '@radix-ui/react-tooltip';
import { EyeClosedIcon, EyeOpenIcon, CheckIcon, CopyIcon as CopyIcon$1, Cross2Icon, MagnifyingGlassIcon, ChevronRightIcon, ShuffleIcon, PinBottomIcon, EnterIcon } from '@radix-ui/react-icons';
import { I as Img, M as ModalTitle, a as ModalDescription, F as FormFieldWithIconButton, i as isMobile, j as fadeInAnimation, k as Skeleton, H as HelperLink, f as useSetIsWalletModalOpen, l as SetModalConfigCtx, u as useIsHeadlessWallet, G as GetStartedScreen, n as ModalConfigCtx, e as useIsWalletModalOpen, b as HeadlessConnectUI, o as WalletSelector, p as WalletUIStatesProvider, d as defaultWallets } from './headlessConnectUI-d4e74332.esm.js';
import { utils } from 'ethers';
import * as Tabs from '@radix-ui/react-tabs';
import Fuse from 'fuse.js';
import * as DropdownMenu from '@radix-ui/react-dropdown-menu';
import { Localhost } from '@thirdweb-dev/chains';
import { LocalWallet, walletIds, assertWindowEthereum } from '@thirdweb-dev/wallets';
import invariant from 'tiny-invariant';
import * as Dialog from '@radix-ui/react-dialog';

function shortenString(str, extraShort) {
  return `${str.substring(0, extraShort ? 4 : 6)}...${str.substring(str.length - (extraShort ? 3 : 4))}`;
}
function shortenAddress(address, extraShort) {
  try {
    const formattedAddress = utils.getAddress(address);
    return shortenString(formattedAddress, extraShort);
  } catch {
    return address;
  }
}

const SecondaryText = styled.span`
  font-size: ${fontSize.md};
  color: ${p => p.theme.text.secondary};
  margin: 0;
`;
styled.span`
  font-size: ${fontSize.md};
  color: ${p => p.theme.text.neutral};
  margin: 0;
`;
styled.span`
  font-size: ${fontSize.md};
  color: ${p => p.theme.text.danger};
  margin: 0;
`;

const localWalletIcon = "ipfs://QmbQzSNGvmNYZzem9jZRuYeLe9K2W4pqbdnVUp7Y6edQ8Y/local-wallet.svg";
const ExportLocalWallet = props => {
  const [password, setPassword] = useState("");
  const [showPassword, setShowPassword] = useState(false);
  const [isWrongPassword, setIsWrongPassword] = useState(false);
  const [passwordIsRequired, setPasswordIsRequired] = useState(false);
  const wallet = useWallet();
  const address = useAddress();
  const [savedAddress, setSavedAddress] = useState("");
  const createWalletInstance = useCreateWalletInstance();

  // set savedAddress and passwordIsRequired on mount
  const mounted = useRef(false);
  useEffect(() => {
    if (mounted.current) {
      return;
    }
    mounted.current = true;
    (async () => {
      // if local wallet is connected - show the address of the connected wallet
      if (wallet && wallet instanceof LocalWallet) {
        if (address) {
          setSavedAddress(address);
        }

        // if walletData of it is not already saved - password is required
        const savedData = await wallet.getSavedData();
        if (savedData?.address !== address) {
          setPasswordIsRequired(true);
        }
      }

      // if localWallet is not connected - get address from storage, password is not required
      else {
        const localWallet = createWalletInstance(props.localWalletConfig);
        const data = await localWallet.getSavedData();
        if (data) {
          setSavedAddress(data.address);
        }
      }
    })();
  }, [wallet, props.localWalletConfig, createWalletInstance, password, address]);
  const exportFromLocalStorage = async () => {
    // if a local wallet is connected - export it
    if (wallet && wallet instanceof LocalWallet) {
      const savedData = await wallet.getSavedData();

      // if already saved - no password required
      if (savedData && savedData.address === address) {
        downloadJsonWalletFile(savedData.data);
        props.onExport();
      }

      // if not already saved - password is required
      else {
        try {
          const dataStr = await wallet.export({
            password,
            strategy: "encryptedJson"
          });
          downloadJsonWalletFile(dataStr);
          props.onExport();
        } catch (e) {
          console.error(e);
          setIsWrongPassword(true);
        }
      }
    }

    // if local wallet is not connected - get data from storage
    else {
      const localWallet = createWalletInstance(props.localWalletConfig);
      const savedData = await localWallet.getSavedData();
      downloadJsonWalletFile(savedData.data);
      props.onExport();
    }
  };
  if (!savedAddress) {
    return /*#__PURE__*/jsx(Flex, {
      justifyContent: "center",
      alignItems: "center",
      style: {
        height: "300px"
      },
      children: /*#__PURE__*/jsx(Spinner, {
        size: "md",
        color: "link"
      })
    });
  }
  const exportDisabled = isWrongPassword;
  return /*#__PURE__*/jsxs(Fragment, {
    children: [/*#__PURE__*/jsx(Img, {
      src: localWalletIcon,
      width: iconSize.xl,
      height: iconSize.xl
    }), /*#__PURE__*/jsx(Spacer, {
      y: "lg"
    }), /*#__PURE__*/jsx(ModalTitle, {
      style: {
        textAlign: "left"
      },
      children: "Backup Wallet"
    }), /*#__PURE__*/jsx(Spacer, {
      y: "md"
    }), /*#__PURE__*/jsx(ModalDescription, {
      children: "This will download a JSON file containing the wallet information onto your device encrypted with the password"
    }), /*#__PURE__*/jsx(Spacer, {
      y: "sm"
    }), /*#__PURE__*/jsx(ModalDescription, {
      children: "You can use this JSON file to import the account in MetaMask using the same password"
    }), /*#__PURE__*/jsx(Spacer, {
      y: "xl"
    }), /*#__PURE__*/jsxs("form", {
      onSubmit: e => {
        e.preventDefault();
        exportFromLocalStorage();
      },
      children: [/*#__PURE__*/jsx(Label, {
        children: "Wallet Address"
      }), /*#__PURE__*/jsx(Spacer, {
        y: "sm"
      }), /*#__PURE__*/jsx(SavedWalletAddress, {
        children: shortenAddress(savedAddress)
      }), /*#__PURE__*/jsx(Spacer, {
        y: "lg"
      }), passwordIsRequired && /*#__PURE__*/jsxs(Fragment, {
        children: [/*#__PURE__*/jsx("input", {
          type: "text",
          name: "username",
          autoComplete: "off",
          value: address,
          disabled: true,
          style: {
            display: "none"
          }
        }), /*#__PURE__*/jsx(FormFieldWithIconButton, {
          noSave: true,
          required: true,
          name: "current-password",
          autocomplete: "current-password",
          id: "current-password",
          onChange: value => {
            setPassword(value);
            setIsWrongPassword(false);
          },
          right: {
            onClick: () => setShowPassword(!showPassword),
            icon: showPassword ? /*#__PURE__*/jsx(EyeClosedIcon, {}) : /*#__PURE__*/jsx(EyeOpenIcon, {})
          },
          label: "Password",
          type: showPassword ? "text" : "password",
          value: password,
          error: isWrongPassword ? "Wrong Password" : "",
          dataTest: "current-password"
        }), /*#__PURE__*/jsx(Spacer, {
          y: "xl"
        })]
      }), /*#__PURE__*/jsx(FormFooter, {
        children: /*#__PURE__*/jsx(Button, {
          disabled: exportDisabled,
          variant: "inverted",
          style: {
            opacity: exportDisabled ? 0.5 : 1
          },
          type: "submit",
          children: "Backup"
        })
      })]
    })]
  });
};
function downloadJsonWalletFile(data) {
  const dataObj = JSON.parse(data);
  const blob = new Blob([JSON.stringify(dataObj, null, 2)], {
    type: "application/json"
  });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "wallet.json";
  document.body.appendChild(a);
  a.style.display = "none";
  a.click();
  URL.revokeObjectURL(a.href);
}
const SavedWalletAddress = styled.p`
  font-size: ${fontSize.md};
  color: ${props => props.theme.text.secondary};
  margin: 0;
`;

const defaultChainIcon = /* @__PURE__ */resolveIpfsUri("ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/ethereum/512.png");
const ChainIcon = props => {
  const url = props.chain?.icon?.url;
  const src = url ? resolveIpfsUri(url) : defaultChainIcon;
  return /*#__PURE__*/jsxs("div", {
    style: {
      position: "relative",
      display: "flex",
      flexShrink: 0,
      alignItems: "center"
    },
    children: [/*#__PURE__*/jsx("img", {
      src: src || defaultChainIcon,
      onError: e => {
        if (defaultChainIcon && e.currentTarget.src !== defaultChainIcon) {
          e.currentTarget.src = defaultChainIcon;
        }
      },
      alt: "",
      width: props.size,
      height: props.size,
      className: props.className,
      loading: props.loading,
      style: {
        objectFit: "contain",
        width: props.size + "px",
        height: props.size + "px"
      }
    }), props.active && /*#__PURE__*/jsx(ActiveDot, {})]
  });
};
const ActiveDot = styled.div`
  width: 28%;
  height: 28%;
  border-radius: 50%;
  position: absolute;
  top: 60%;
  right: 0px;
  background-color: #00d395;
  box-shadow: 0 0 0 2px ${p => p.theme.bg.elevated};
`;

// extracted from chakra-ui
/**
 * React hook to copy content to clipboard
 *
 */
function useClipboard(text) {
  let optionsOrTimeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const [hasCopied, setHasCopied] = useState(false);
  const {
    timeout = 1500,
    ...copyOptions
  } = typeof optionsOrTimeout === "number" ? {
    timeout: optionsOrTimeout
  } : optionsOrTimeout;
  const onCopy = useCallback(() => {
    const didCopy = copy(text, copyOptions);
    setHasCopied(didCopy);
  }, [text, copyOptions]);
  useEffect(() => {
    let timeoutId = null;
    if (hasCopied) {
      timeoutId = window.setTimeout(() => {
        setHasCopied(false);
      }, timeout);
    }
    return () => {
      if (timeoutId) {
        window.clearTimeout(timeoutId);
      }
    };
  }, [timeout, hasCopied]);
  return {
    value: text,
    onCopy,
    hasCopied
  };
}

const ToolTip = props => {
  return /*#__PURE__*/jsx(RadixTooltip.Provider, {
    delayDuration: 200,
    children: /*#__PURE__*/jsxs(RadixTooltip.Root, {
      children: [/*#__PURE__*/jsx(RadixTooltip.Trigger, {
        asChild: true,
        children: props.children
      }), /*#__PURE__*/jsx(RadixTooltip.Portal, {
        children: /*#__PURE__*/jsxs(TooltipContent, {
          sideOffset: props.sideOffset || 6,
          align: props.align,
          side: props.side,
          children: [props.tip, /*#__PURE__*/jsx(TooltipArrow, {})]
        })
      })]
    })
  });
};
const slideUpAndFade$1 = keyframes`
from {
  opacity: 0;
  transform: translateY(2px);
}
to {
  opacity: 1;
  transform: translateY(0);
}
`;
const TooltipContent = styled( RadixTooltip.Content)`
  background: ${p => p.theme.tooltip.bg};
  color: ${p => p.theme.tooltip.text};
  border-radius: ${radius.sm};
  line-height: 1;
  padding: ${spacing.sm} ${spacing.md};
  font-size: ${fontSize.sm};
  box-shadow: ${shadow.sm};
  user-select: none;
  will-change: transform, opacity;
  animation: ${slideUpAndFade$1} 200ms cubic-bezier(0.16, 1, 0.3, 1);
  z-index: 999999999999999;
  max-width: 300px;
  line-height: 1.5;
`;
const TooltipArrow = styled( RadixTooltip.Arrow)`
  fill: ${p => p.theme.tooltip.bg};
`;

const CopyIcon = props => {
  const {
    hasCopied,
    onCopy
  } = useClipboard(props.text);
  return /*#__PURE__*/jsx("div", {
    onClick: onCopy,
    style: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center"
    },
    children: /*#__PURE__*/jsx(ToolTip, {
      tip: props.tip,
      side: props.side,
      align: props.align,
      children: hasCopied ? /*#__PURE__*/jsx(CheckIconStyled, {}) : /*#__PURE__*/jsx(CopyIcon$1, {})
    })
  });
};
const CheckIconStyled = styled(CheckIcon)`
  color: ${p => p.theme.icon.success};
`;

const scrollbar = _ref => {
  let {
    track,
    thumb,
    hover
  } = _ref;
  return `
&::-webkit-scrollbar {
  width: 6px;
}

&::-webkit-scrollbar-track {
  box-shadow: inset 0 0 5px ${track};
  border-radius: ${radius.md};
}

&::-webkit-scrollbar-thumb {
  background: ${thumb};
  border-radius: ${radius.md};
}

&::-webkit-scrollbar-thumb:hover {
  background: ${hover};
}`;
};

const overlayEnter = keyframes`
 from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
`;
const Overlay = styled.div`
  background-color: ${p => p.theme.overlay.subdued};
  z-index: 9999;
  position: fixed;
  inset: 0;
  animation: ${overlayEnter} 400ms cubic-bezier(0.16, 1, 0.3, 1);
`;

const Modal = props => {
  return /*#__PURE__*/jsxs(Dialog.Root, {
    open: props.open,
    onOpenChange: props.setOpen,
    children: [props.trigger && /*#__PURE__*/jsx(Dialog.Trigger, {
      asChild: true,
      children: props.trigger
    }), /*#__PURE__*/jsxs(Dialog.Portal, {
      children: [/*#__PURE__*/jsx(Dialog.Overlay, {
        asChild: true,
        children: /*#__PURE__*/jsx(Overlay, {})
      }), /*#__PURE__*/jsx(Dialog.Content, {
        asChild: true,
        children: /*#__PURE__*/jsxs(DialogContent, {
          style: props.style,
          children: [props.title && /*#__PURE__*/jsxs(DialogTitle, {
            children: [" ", props.title]
          }), props.children, !props.hideCloseIcon && /*#__PURE__*/jsx(CrossContainer, {
            children: /*#__PURE__*/jsx(Dialog.Close, {
              asChild: true,
              children: /*#__PURE__*/jsx(IconButton, {
                variant: "secondary",
                type: "button",
                "aria-label": "Close",
                children: /*#__PURE__*/jsx(Cross2Icon, {
                  style: {
                    width: iconSize.md,
                    height: iconSize.md,
                    color: "inherit"
                  }
                })
              })
            })
          })]
        })
      })]
    })]
  });
};
const CrossContainer = styled.div`
  position: absolute;
  top: ${spacing.lg};
  right: ${spacing.lg};

  ${media.mobile} {
    right: ${spacing.md};
  }
`;
const modalAnimationDesktop = keyframes`
  from {
    opacity: 0;
    transform: translate(-50%, -48%) scale(0.96);
  }
  to {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1);
  }
`;
const modalAnimationMobile = keyframes`
  from {
    opacity: 0;
    transform: translate(0, 50%);
  }
  to {
    opacity: 1;
    transform: translate(0, 0);
  }
`;
const DialogContent = styled.div`
  z-index: 10000;
  background-color: ${p => p.theme.bg.base};
  border-radius: ${radius.xl};
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: calc(100vw - 40px);
  box-sizing: border-box;
  overflow-y: auto;
  padding: ${spacing.lg};
  padding-bottom: ${spacing.xl};
  animation: ${modalAnimationDesktop} 200ms ease;
  box-shadow: ${shadow.lg};
  line-height: 1;

  &:focus {
    outline: none;
  }

  ${p => scrollbar({
  track: "transparent",
  thumb: p.theme.bg.elevated,
  hover: p.theme.bg.highlighted
})}

  /* open from bottom on mobile */
  ${media.mobile} {
    top: auto;
    bottom: 0;
    left: 0;
    right: 0;
    max-width: 100vw;
    transform: none;
    width: 100vw;
    animation: ${modalAnimationMobile} 0.35s cubic-bezier(0.15, 1.15, 0.6, 1);
    border-radius: ${radius.xxl};
    border-bottom-right-radius: 0;
    border-bottom-left-radius: 0;
    max-width: none !important;
  }

  & *::selection {
    background-color: ${p => p.theme.bg.inverted};
    color: ${p => p.theme.text.inverted};
  }
`;
const DialogTitle = styled( Dialog.Title)`
  margin: 0;
  font-weight: 500;
  color: ${p => p.theme.text.neutral};
  font-size: ${fontSize.lg};
`;

const fuseConfig = {
  threshold: 0.4,
  keys: [{
    name: "name",
    weight: 1
  }, {
    name: "chainId",
    weight: 1
  }]
};
const NetworkSelector = props => {
  const [searchTerm, setSearchTerm] = useState("");
  const deferredSearchTerm = useDeferredValue(searchTerm);
  const themeFromProvider = useContext(ThirdwebThemeContext);
  const theme = props.theme || themeFromProvider || "dark";
  const supportedChains = useSupportedChains();
  const chains = props.chains || supportedChains;
  const _recentChains = props.recentChains;

  // remove recent chains from popular chains
  const cleanedPopularChains = !_recentChains ? props.popularChains : props.popularChains?.filter(chain => {
    return !_recentChains.some(recentChain => recentChain.chainId === chain.chainId);
  });

  // fuse instances
  const fuseAllChains = useMemo(() => {
    return new Fuse(chains, fuseConfig);
  }, [chains]);
  const fusePopularChains = useMemo(() => {
    return new Fuse(cleanedPopularChains || [], fuseConfig);
  }, [cleanedPopularChains]);
  const fuseRecentChains = useMemo(() => {
    return new Fuse(props.recentChains || [], fuseConfig);
  }, [props.recentChains]);

  // chains filtered by search term
  const allChains = useMemo(() => {
    if (deferredSearchTerm === "") {
      return chains;
    }
    return fuseAllChains.search(deferredSearchTerm).map(r => r.item);
  }, [fuseAllChains, deferredSearchTerm, chains]);
  const popularChains = useMemo(() => {
    if (deferredSearchTerm === "") {
      return cleanedPopularChains || [];
    }
    return fusePopularChains.search(deferredSearchTerm).map(r => r.item);
  }, [fusePopularChains, deferredSearchTerm, cleanedPopularChains]);
  const recentChains = useMemo(() => {
    if (deferredSearchTerm === "") {
      return props.recentChains || [];
    }
    return fuseRecentChains.search(deferredSearchTerm).map(r => r.item);
  }, [fuseRecentChains, deferredSearchTerm, props.recentChains]);
  const {
    onClose,
    onSwitch,
    onCustomClick
  } = props;
  const handleSwitch = useCallback(chain => {
    if (onSwitch) {
      onSwitch(chain);
    }
    if (onClose) {
      onClose();
    }
  }, [onSwitch, onClose]);
  return /*#__PURE__*/jsx(ThemeProvider, {
    theme: theme === "dark" ? darkTheme : lightTheme,
    children: /*#__PURE__*/jsxs(Modal, {
      open: true,
      setOpen: value => {
        if (!value && onClose) {
          onClose();
        }
      },
      title: "Select Network",
      style: {
        maxWidth: "480px",
        paddingBottom: props.onCustomClick ? spacing.md : "0px"
      },
      children: [/*#__PURE__*/jsx(Spacer, {
        y: "xl"
      }), /*#__PURE__*/jsxs(Tabs.Root, {
        className: "TabsRoot",
        defaultValue: "all",
        children: [/*#__PURE__*/jsxs(Tabs.List, {
          className: "TabsList",
          "aria-label": "Manage your account",
          style: {
            display: "flex",
            gap: spacing.xxs
          },
          children: [/*#__PURE__*/jsx(TabButton, {
            className: "TabsTrigger",
            value: "all",
            children: "All"
          }), /*#__PURE__*/jsx(TabButton, {
            className: "TabsTrigger",
            value: "mainnet",
            children: "Mainnets"
          }), /*#__PURE__*/jsx(TabButton, {
            className: "TabsTrigger",
            value: "testnet",
            children: "Testnets"
          })]
        }), /*#__PURE__*/jsx(Spacer, {
          y: "lg"
        }), /*#__PURE__*/jsxs("div", {
          style: {
            display: "flex",
            alignItems: "center",
            position: "relative"
          },
          children: [/*#__PURE__*/jsx(StyledMagnifyingGlassIcon, {
            width: iconSize.md,
            height: iconSize.md
          }), /*#__PURE__*/jsx(SearchInput, {
            style: {
              boxShadow: "none"
            },
            tabIndex: isMobile() ? -1 : 0,
            variant: "secondary",
            placeholder: "Search Network or Chain ID",
            value: searchTerm,
            onChange: e => {
              setSearchTerm(e.target.value);
            }
          }), deferredSearchTerm !== searchTerm && /*#__PURE__*/jsx("div", {
            style: {
              position: "absolute",
              right: spacing.md
            },
            children: /*#__PURE__*/jsx(Spinner, {
              size: "md",
              color: "link"
            })
          })]
        }), /*#__PURE__*/jsx(Spacer, {
          y: "lg"
        }), /*#__PURE__*/jsx(Tabs.Content, {
          className: "TabsContent",
          value: "all",
          children: /*#__PURE__*/jsx(NetworkTab, {
            allChains: allChains,
            type: "all",
            popularChains: popularChains,
            recentChains: recentChains,
            onSwitch: handleSwitch,
            renderChain: props.renderChain,
            close: props.onClose
          })
        }), /*#__PURE__*/jsx(Tabs.Content, {
          className: "TabsContent",
          value: "mainnet",
          children: /*#__PURE__*/jsx(NetworkTab, {
            allChains: allChains,
            type: "mainnet",
            popularChains: popularChains,
            recentChains: recentChains,
            onSwitch: handleSwitch,
            renderChain: props.renderChain,
            close: props.onClose
          })
        }), /*#__PURE__*/jsx(Tabs.Content, {
          className: "TabsContent",
          value: "testnet",
          children: /*#__PURE__*/jsx(NetworkTab, {
            allChains: allChains,
            type: "testnet",
            popularChains: popularChains,
            recentChains: recentChains,
            onSwitch: handleSwitch,
            renderChain: props.renderChain,
            close: props.onClose
          })
        }), onCustomClick && /*#__PURE__*/jsxs(Fragment, {
          children: [/*#__PURE__*/jsx(Spacer, {
            y: "sm"
          }), /*#__PURE__*/jsx(Button, {
            variant: "link",
            onClick: () => {
              onCustomClick();
              if (onClose) {
                onClose();
              }
            },
            style: {
              display: "flex",
              width: "100%",
              fontSize: fontSize.sm,
              boxShadow: "none"
            },
            children: "Add Custom Network"
          })]
        })]
      })]
    })
  });
};
const filterChainByType = (chains, type) => {
  if (type === "all") {
    return chains;
  }
  if (type === "testnet") {
    return chains.filter(c => c.testnet);
  }
  return chains.filter(c => !c.testnet);
};
const NetworkTab = props => {
  const allChains = useMemo(() => filterChainByType(props.allChains, props.type), [props.type, props.allChains]);
  const recentChains = useMemo(() => filterChainByType(props.recentChains || [], props.type), [props.type, props.recentChains]);
  const popularChains = useMemo(() => filterChainByType(props.popularChains || [], props.type), [props.type, props.popularChains]);
  return /*#__PURE__*/jsxs(ScrollContainer, {
    style: {
      height: "330px"
    },
    children: [recentChains.length > 0 && /*#__PURE__*/jsxs("div", {
      children: [/*#__PURE__*/jsx(SectionLabel, {
        children: "Recently Used"
      }), /*#__PURE__*/jsx(Spacer, {
        y: "sm"
      }), /*#__PURE__*/jsx(NetworkList, {
        chains: recentChains,
        onSwitch: props.onSwitch,
        renderChain: props.renderChain,
        close: props.close
      }), /*#__PURE__*/jsx(Spacer, {
        y: "lg"
      })]
    }), popularChains.length > 0 && /*#__PURE__*/jsxs("div", {
      children: [/*#__PURE__*/jsx(SectionLabel, {
        children: "Popular"
      }), /*#__PURE__*/jsx(Spacer, {
        y: "sm"
      }), /*#__PURE__*/jsx(NetworkList, {
        chains: popularChains,
        onSwitch: props.onSwitch,
        renderChain: props.renderChain,
        close: props.close
      }), /*#__PURE__*/jsx(Spacer, {
        y: "lg"
      })]
    }), (popularChains.length > 0 || recentChains.length > 0) && /*#__PURE__*/jsxs(Fragment, {
      children: [/*#__PURE__*/jsx(SectionLabel, {
        children: "All Networks"
      }), /*#__PURE__*/jsx(Spacer, {
        y: "sm"
      })]
    }), /*#__PURE__*/jsx(NetworkList, {
      chains: allChains,
      onSwitch: props.onSwitch,
      renderChain: props.renderChain,
      close: props.close
    })]
  });
};
const NetworkList = /* @__PURE__ */memo(function NetworkList(props) {
  const switchChain = useSwitchChain();
  const activeChainId = useChainId();
  const [switchingChainId, setSwitchingChainId] = useState(-1);
  const [errorSwitchingChainId, setErrorSwitchingChainId] = useState(-1);
  const handleSwitch = async chain => {
    setErrorSwitchingChainId(-1);
    setSwitchingChainId(chain.chainId);
    try {
      await switchChain(chain.chainId);
      props.onSwitch(chain);
    } catch (e) {
      setErrorSwitchingChainId(chain.chainId);
      console.error(e);
    } finally {
      setSwitchingChainId(-1);
    }
  };
  const RenderChain = props.renderChain;
  const [isLoading, setIsLoading] = useState(props.chains.length > 100);
  useEffect(() => {
    if (isLoading) {
      setIsLoading(false);
    }
  }, [isLoading]);
  if (isLoading) {
    return /*#__PURE__*/jsx(Flex, {
      justifyContent: "center",
      alignItems: "center",
      style: {
        height: "250px"
      },
      children: /*#__PURE__*/jsx(SecondaryText, {
        children: "Loading"
      })
    });
  }
  return /*#__PURE__*/jsx(NetworkListUl, {
    children: props.chains.map(chain => {
      const confirming = switchingChainId === chain.chainId;
      const switchingFailed = errorSwitchingChainId === chain.chainId;
      const chainName = /*#__PURE__*/jsxs("span", {
        children: [chain.name, " "]
      });
      if (RenderChain) {
        return /*#__PURE__*/jsx("li", {
          children: /*#__PURE__*/jsx(RenderChain, {
            switchChain: () => {
              handleSwitch(chain);
            },
            chain: chain,
            switching: switchingChainId === chain.chainId,
            switchFailed: errorSwitchingChainId === chain.chainId,
            close: props.close
          })
        }, chain.chainId);
      }
      return /*#__PURE__*/jsx("li", {
        children: /*#__PURE__*/jsxs(NetworkButton, {
          "data-active": activeChainId === chain.chainId,
          onClick: () => {
            handleSwitch(chain);
          },
          children: [/*#__PURE__*/jsx(ChainIcon, {
            chain: chain,
            size: iconSize.lg,
            active: activeChainId === chain.chainId,
            loading: "lazy"
          }), confirming || switchingFailed ? /*#__PURE__*/jsxs("div", {
            style: {
              display: "flex",
              flexDirection: "column",
              gap: spacing.xs
            },
            children: [chainName, /*#__PURE__*/jsxs("div", {
              style: {
                display: "flex",
                gap: spacing.xs
              },
              children: [confirming && /*#__PURE__*/jsxs(Fragment, {
                children: [/*#__PURE__*/jsx(ConfirmMessage, {
                  children: "Confirm in Wallet"
                }), /*#__PURE__*/jsx(Spinner, {
                  size: "sm",
                  color: "link"
                })]
              }), switchingFailed && /*#__PURE__*/jsx(ErrorMessage, {
                children: "Error: Could not Switch Network"
              })]
            })]
          }) : chainName]
        })
      }, chain.chainId);
    })
  });
});
const TabButton = styled( Tabs.Trigger)`
  all: unset;
  font-size: ${fontSize.md};
  font-weight: 500;
  color: ${p => p.theme.text.secondary};
  cursor: pointer;
  padding: ${spacing.sm} ${spacing.sm};
  -webkit-tap-highlight-color: transparent;
  border-radius: ${radius.lg};
  transition: background 0.2s ease, color 0.2s ease;
  &[data-state="active"] {
    background: ${p => p.theme.bg.elevated};
    color: ${p => p.theme.text.neutral};
  }
`;
const SectionLabel = styled.p`
  font-size: ${fontSize.sm};
  color: ${p => p.theme.text.secondary};
  margin: 0;
`;
const ScrollContainer = styled.div`
  box-sizing: border-box;
  overflow: auto;
  padding-right: 10px;
  padding-bottom: ${spacing.lg};
  width: calc(100% + 16px);
  -webkit-mask-image: linear-gradient(to bottom, black 90%, transparent 100%);
  mask-image: linear-gradient(to bottom, black 90%, transparent 100%);
  ${p => scrollbar({
  track: "transparent",
  thumb: p.theme.bg.elevated,
  hover: p.theme.bg.highlighted
})}
`;
const NetworkListUl = styled.ul`
  padding: 0;
  margin: 0;
  list-style: none;
  display: flex;
  flex-direction: column;
  gap: ${spacing.xs};
  box-sizing: border-box;
`;
const NetworkButton = styled.button`
  all: unset;
  display: flex;
  width: 100%;
  box-sizing: border-box;
  align-items: center;
  gap: ${spacing.md};
  padding: ${spacing.sm} ${spacing.md};
  border-radius: ${radius.md};
  cursor: pointer;
  transition: background 0.2s ease;
  background: ${p => p.theme.bg.elevated};
  color: ${p => p.theme.text.neutral};
  font-weight: 600;
  font-size: ${fontSize.md};
  &:hover {
    background: ${p => p.theme.bg.highlighted};
  }

  ${media.mobile} {
    font-size: ${fontSize.sm};
  }
`;
const StyledMagnifyingGlassIcon = styled(MagnifyingGlassIcon)`
  color: ${p => p.theme.text.secondary};
  position: absolute;
  left: 18px;
`;
const SearchInput = styled(Input)`
  padding: ${spacing.sm} ${spacing.md} ${spacing.sm} 60px;
`;
const ConfirmMessage = styled.div`
  font-size: ${fontSize.sm};
  color: ${p => p.theme.link.primary};
`;
const ErrorMessage = styled.div`
  font-size: ${fontSize.sm};
  color: ${p => p.theme.text.danger};
`;

const ExitIcon = _ref => {
  let {
    size
  } = _ref;
  return /*#__PURE__*/jsx("svg", {
    width: size,
    height: size,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: /*#__PURE__*/jsx("path", {
      fill: "currentColor",
      d: "M10.79 16.29C11.18 16.68 11.81 16.68 12.2 16.29L15.79 12.7C15.8827 12.6075 15.9563 12.4976 16.0064 12.3766C16.0566 12.2557 16.0824 12.126 16.0824 11.995C16.0824 11.864 16.0566 11.7343 16.0064 11.6134C15.9563 11.4924 15.8827 11.3825 15.79 11.29L12.2 7.7C12.013 7.51302 11.7594 7.40798 11.495 7.40798C11.2306 7.40798 10.977 7.51302 10.79 7.7C10.603 7.88698 10.498 8.14057 10.498 8.405C10.498 8.66943 10.603 8.92302 10.79 9.11L12.67 11H4C3.45 11 3 11.45 3 12C3 12.55 3.45 13 4 13H12.67L10.79 14.88C10.4 15.27 10.41 15.91 10.79 16.29ZM19 3H5C4.46957 3 3.96086 3.21071 3.58579 3.58579C3.21071 3.96086 3 4.46957 3 5V8C3 8.55 3.45 9 4 9C4.55 9 5 8.55 5 8V6C5 5.45 5.45 5 6 5H18C18.55 5 19 5.45 19 6V18C19 18.55 18.55 19 18 19H6C5.45 19 5 18.55 5 18V16C5 15.45 4.55 15 4 15C3.45 15 3 15.45 3 16V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3Z"
    })
  });
};

const FundsIcon = _ref => {
  let {
    size
  } = _ref;
  return /*#__PURE__*/jsxs("svg", {
    width: size,
    height: size,
    viewBox: "0 0 12 12",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: [/*#__PURE__*/jsx("circle", {
      cx: "6",
      cy: "6",
      r: "5.335",
      stroke: "currentColor",
      strokeWidth: "1.33"
    }), /*#__PURE__*/jsx("path", {
      fill: "currentColor",
      d: "M5.85378 8.54545V3.09091H6.20321V8.54545H5.85378ZM6.78063 4.89134C6.76358 4.71946 6.69043 4.58594 6.56117 4.49077C6.43191 4.3956 6.25648 4.34801 6.03489 4.34801C5.88432 4.34801 5.75719 4.36932 5.6535 4.41193C5.5498 4.45312 5.47026 4.51065 5.41486 4.58452C5.36088 4.65838 5.3339 4.74219 5.3339 4.83594C5.33105 4.91406 5.34739 4.98224 5.3829 5.04048C5.41983 5.09872 5.47026 5.14915 5.53418 5.19176C5.5981 5.23295 5.67196 5.26918 5.75577 5.30043C5.83958 5.33026 5.92907 5.35582 6.02424 5.37713L6.41628 5.47088C6.60662 5.51349 6.78134 5.57031 6.94043 5.64134C7.09952 5.71236 7.2373 5.79972 7.35378 5.90341C7.47026 6.0071 7.56046 6.12926 7.62438 6.26989C7.68972 6.41051 7.7231 6.57173 7.72452 6.75355C7.7231 7.0206 7.65492 7.25213 7.51998 7.44815C7.38645 7.64276 7.19327 7.79403 6.94043 7.90199C6.68901 8.00852 6.38574 8.06179 6.03063 8.06179C5.67836 8.06179 5.37154 8.00781 5.11017 7.89986C4.85023 7.7919 4.64711 7.6321 4.5008 7.42045C4.35591 7.20739 4.27992 6.94389 4.27282 6.62997H5.16557C5.17551 6.77628 5.21742 6.89844 5.29128 6.99645C5.36657 7.09304 5.46671 7.16619 5.59171 7.21591C5.71813 7.2642 5.86088 7.28835 6.01998 7.28835C6.17623 7.28835 6.31188 7.26562 6.42694 7.22017C6.54341 7.17472 6.63361 7.11151 6.69753 7.03054C6.76145 6.94957 6.79341 6.85653 6.79341 6.75142C6.79341 6.65341 6.76429 6.57102 6.70605 6.50426C6.64924 6.4375 6.56543 6.38068 6.45463 6.33381C6.34526 6.28693 6.21103 6.24432 6.05194 6.20597L5.57679 6.08665C5.2089 5.99716 4.91841 5.85724 4.70534 5.6669C4.49228 5.47656 4.38645 5.22017 4.38787 4.89773C4.38645 4.63352 4.45676 4.4027 4.59881 4.20526C4.74228 4.00781 4.93901 3.85369 5.18901 3.7429C5.43901 3.6321 5.7231 3.5767 6.04128 3.5767C6.36515 3.5767 6.64782 3.6321 6.88929 3.7429C7.13219 3.85369 7.32111 4.00781 7.45605 4.20526C7.591 4.4027 7.6606 4.63139 7.66486 4.89134H6.78063Z"
    })]
  });
};

const TW_CONNECTED_WALLET = "tw-connected-wallet";
const ConnectedWalletDetails = props => {
  const disconnect = useDisconnect();
  const chains = useSupportedChains();
  const walletChainId = useChainId();
  const address = useAddress();
  const balanceQuery = useBalance();
  const activeWallet = useWallet();
  const activeWalletConfig = useWalletConfig();
  const [showExportModal, setShowExportModal] = useState(false);
  const [wrapperWallet, setWrapperWallet] = useState();
  const walletContext = useWalletContext();
  const chain = useChain();
  const activeWalletIconURL = activeWalletConfig?.meta.iconURL || "";
  const [showNetworkSelector, setShowNetworkSelector] = useState(false);
  const [open, setOpen] = useState(false);
  const sdk = useSDK();
  const personalWallet = activeWallet?.getPersonalWallet();
  const personalWalletConfig = personalWallet && walletContext.getWalletConfig(personalWallet);
  const wrapperWalletConfig = wrapperWallet && walletContext.getWalletConfig(wrapperWallet);
  const disableSwitchChain = !!personalWallet;
  const trigger = props.detailsBtn ? /*#__PURE__*/jsx("div", {
    children: /*#__PURE__*/jsx(props.detailsBtn, {})
  }) : /*#__PURE__*/jsxs(WalletInfoButton, {
    type: "button",
    className: `${TW_CONNECTED_WALLET} ${props.className || ""}`,
    "data-theme": props.theme,
    style: props.style,
    "data-test": "connected-wallet-details",
    children: [/*#__PURE__*/jsx(ChainIcon, {
      chain: chain,
      size: iconSize.lg,
      className: `${TW_CONNECTED_WALLET}__network-icon`
    }), /*#__PURE__*/jsxs(ColFlex, {
      children: [balanceQuery.data ? /*#__PURE__*/jsxs(WalletBalance, {
        className: `${TW_CONNECTED_WALLET}__balance`,
        children: [Number(balanceQuery.data.displayValue).toFixed(3), " ", balanceQuery.data.symbol]
      }) : /*#__PURE__*/jsx(Skeleton, {
        height: fontSize.sm,
        width: "82px"
      }), /*#__PURE__*/jsx(Spacer, {
        y: "xs"
      }), activeWallet?.walletId === walletIds.localWallet ? /*#__PURE__*/jsx(ErrorMessage$1, {
        style: {
          lineHeight: 1,
          minWidth: "70px",
          fontSize: fontSize.xs
        },
        children: "Guest"
      }) : address ? /*#__PURE__*/jsx(WalletAddress, {
        className: `${TW_CONNECTED_WALLET}__address`,
        children: shortenString(address || "")
      }) : /*#__PURE__*/jsx(Skeleton, {
        height: fontSize.xs,
        width: "88px"
      })]
    }), /*#__PURE__*/jsx(Img, {
      width: iconSize.lg,
      height: iconSize.lg,
      src: activeWalletIconURL,
      className: `${TW_CONNECTED_WALLET}__wallet-icon`
    })]
  });
  const networkSwitcherButton = /*#__PURE__*/jsx(ToolTip, {
    tip: disableSwitchChain ? "Network Switching is disabled" : "Switch Network",
    children: /*#__PURE__*/jsxs(MenuButton, {
      type: "button",
      disabled: disableSwitchChain,
      onClick: () => {
        setOpen(false);
        setShowNetworkSelector(true);
      },
      children: [/*#__PURE__*/jsx("div", {
        style: {
          display: "flex",
          alignItems: "center",
          position: "relative"
        },
        children: /*#__PURE__*/jsx(ChainIcon, {
          chain: chain,
          size: iconSize.lg,
          active: true
        })
      }), chain?.name || `Unknown chain #${walletChainId}`, /*#__PURE__*/jsx(StyledChevronRightIcon, {
        width: iconSize.sm,
        height: iconSize.sm,
        style: {
          flexShrink: 0,
          marginLeft: "auto"
        }
      })]
    })
  });
  const content = /*#__PURE__*/jsxs("div", {
    children: [/*#__PURE__*/jsxs(Flex, {
      gap: "md",
      children: [/*#__PURE__*/jsx(Img, {
        width: iconSize.xl,
        height: iconSize.xl,
        src: activeWalletIconURL,
        alt: ""
      }), /*#__PURE__*/jsxs("div", {
        style: {
          flexGrow: 1
        },
        children: [/*#__PURE__*/jsxs(Flex, {
          gap: "xs",
          alignItems: "center",
          children: [/*#__PURE__*/jsxs("div", {
            style: {
              display: "flex",
              gap: spacing.xs,
              alignItems: "center"
            },
            "data-test": "connected-wallet-address",
            "data-address": address,
            children: [/*#__PURE__*/jsxs(AccountAddress, {
              children: [" ", shortenString(address || "")]
            }), /*#__PURE__*/jsx(IconButton, {
              variant: "secondary",
              style: {
                padding: "3px"
              },
              "data-test": "copy-address",
              children: /*#__PURE__*/jsx(CopyIcon, {
                text: address || "",
                tip: "Copy Address",
                side: "bottom"
              })
            })]
          }), /*#__PURE__*/jsx(ToolTip, {
            tip: "Disconnect Wallet",
            side: "bottom",
            align: "end",
            sideOffset: 10,
            children: /*#__PURE__*/jsx(DisconnectIconButton, {
              type: "button",
              variant: "secondary",
              onClick: () => {
                disconnect();
                props.onDisconnect();
              },
              children: /*#__PURE__*/jsx(ExitIcon, {
                size: iconSize.md
              })
            })
          })]
        }), /*#__PURE__*/jsxs(AccountBalance, {
          children: [" ", balanceQuery.data ? Number(balanceQuery.data.displayValue).toFixed(3) : /*#__PURE__*/jsx(Skeleton, {
            height: "1em",
            width: "100px"
          }), " ", balanceQuery.data?.symbol, " "]
        })]
      })]
    }), /*#__PURE__*/jsx(Spacer, {
      y: "lg"
    }), /*#__PURE__*/jsxs("div", {
      children: [/*#__PURE__*/jsx(DropdownLabel, {
        children: "Current Network"
      }), /*#__PURE__*/jsx(Spacer, {
        y: "xs"
      }), networkSwitcherButton]
    }), /*#__PURE__*/jsx(Spacer, {
      y: "md"
    }), /*#__PURE__*/jsxs(Flex, {
      flexDirection: "column",
      gap: "sm",
      children: [personalWallet && personalWalletConfig && /*#__PURE__*/jsx(WalletSwitcher, {
        wallet: personalWallet,
        name: "Personal Wallet",
        onSwitch: () => {
          setWrapperWallet(activeWallet);
        }
      }), wrapperWalletConfig && wrapperWallet && /*#__PURE__*/jsx(WalletSwitcher, {
        name: wrapperWalletConfig.meta.name,
        wallet: wrapperWallet,
        onSwitch: () => {
          setWrapperWallet(undefined);
        }
      }), activeWalletConfig && activeWalletConfig.id === walletIds.metamask && activeWalletConfig.isInstalled && activeWalletConfig.isInstalled() && /*#__PURE__*/jsxs(MenuButton, {
        type: "button",
        onClick: () => {
          activeWallet.switchAccount();
          setOpen(false);
        },
        style: {
          fontSize: fontSize.sm
        },
        children: [/*#__PURE__*/jsx(ShuffleIcon, {
          width: iconSize.sm,
          height: iconSize.sm
        }), "Switch Account"]
      }), (chain?.faucets && chain.faucets.length > 0 || chain?.chainId === Localhost.chainId) && /*#__PURE__*/jsxs(MenuLink, {
        href: chain?.faucets ? chain.faucets[0] : "#",
        target: "_blank",
        as: "a",
        onClick: async e => {
          if (chain.chainId === Localhost.chainId) {
            e.preventDefault();
            setOpen(false);
            await sdk?.wallet.requestFunds(10);
            await balanceQuery.refetch();
          }
        },
        style: {
          textDecoration: "none",
          color: "inherit",
          fontSize: fontSize.sm
        },
        children: [/*#__PURE__*/jsx(SecondaryIconContainer, {
          children: /*#__PURE__*/jsx(FundsIcon, {
            size: iconSize.sm
          })
        }), "Request Testnet Funds"]
      }), activeWallet?.walletId === walletIds.localWallet && /*#__PURE__*/jsxs("div", {
        children: [/*#__PURE__*/jsxs(MenuButton, {
          onClick: () => {
            setShowExportModal(true);
            setOpen(false);
          },
          style: {
            fontSize: fontSize.sm
          },
          children: [/*#__PURE__*/jsx(SecondaryIconContainer, {
            children: /*#__PURE__*/jsx(PinBottomIcon, {
              width: iconSize.sm,
              height: iconSize.sm
            })
          }), "Backup wallet", " "]
        }), /*#__PURE__*/jsx(Spacer, {
          y: "sm"
        }), /*#__PURE__*/jsxs(ErrorMessage$1, {
          style: {
            fontSize: fontSize.xs,
            textAlign: "center"
          },
          children: ["This is a temporary guest wallet ", /*#__PURE__*/jsx("br", {}), "Backup if you ", `don't `, "want to lose access to it"]
        })]
      })]
    })]
  });
  return /*#__PURE__*/jsxs(Fragment, {
    children: [isMobile() ? /*#__PURE__*/jsx(Modal, {
      trigger: trigger,
      open: open,
      setOpen: setOpen,
      hideCloseIcon: true,
      children: /*#__PURE__*/jsx("div", {
        style: {
          minHeight: "200px"
        },
        children: content
      })
    }) : /*#__PURE__*/jsxs(DropdownMenu.Root, {
      open: open,
      onOpenChange: setOpen,
      children: [/*#__PURE__*/jsx(DropdownMenu.Trigger, {
        asChild: true,
        children: trigger
      }), /*#__PURE__*/jsx(DropdownMenu.Portal, {
        children: /*#__PURE__*/jsx(DropDownContent, {
          asChild: true,
          side: props.dropdownPosition?.side || "bottom",
          align: props.dropdownPosition?.align || "end",
          sideOffset: 10,
          children: content
        })
      })]
    }), showNetworkSelector && /*#__PURE__*/jsx(NetworkSelector, {
      theme: props.theme,
      chains: chains,
      ...props.networkSelector,
      onClose: () => setShowNetworkSelector(false)
    }), showExportModal && /*#__PURE__*/jsx(Modal, {
      open: true,
      setOpen: setShowExportModal,
      style: {
        maxWidth: "480px"
      },
      children: /*#__PURE__*/jsx(ExportLocalWallet, {
        localWalletConfig: activeWalletConfig,
        onBack: () => {
          setShowExportModal(false);
        },
        onExport: () => {
          setShowExportModal(false);
        }
      })
    })]
  });
};
const dropdownContentFade = keyframes`
  from {
    opacity: 0;
    transform: scale(0.95);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
`;
const DropDownContent = styled( DropdownMenu.Content)`
  width: 360px;
  box-sizing: border-box;
  max-width: 100%;
  border-radius: ${radius.lg};
  padding: ${spacing.lg};
  animation: ${dropdownContentFade} 400ms cubic-bezier(0.16, 1, 0.3, 1);
  will-change: transform, opacity;
  border: 1px solid ${props => props.theme.border.base};
  background-color: ${props => props.theme.bg.base};
  z-index: 1000000;
  line-height: 1;
`;
const WalletInfoButton = styled.button`
  all: unset;
  background: ${props => props.theme.bg.base};
  border: 1px solid ${props => props.theme.border.base};
  padding: ${spacing.sm} ${spacing.sm};
  border-radius: ${radius.lg};
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  gap: ${spacing.md};
  box-sizing: border-box;
  -webkit-tap-highlight-color: transparent;
  line-height: 1;
  animation: ${fadeInAnimation} 300ms ease;

  ${media.mobile} {
    gap: ${spacing.sm};
    padding: ${spacing.xs} ${spacing.sm};
    img {
      width: ${iconSize.md}px;
      height: ${iconSize.md}px;
    }
  }

  &:hover {
    transition: background 250ms ease;
    background: ${props => props.theme.bg.baseHover};
    border-color: ${props => props.theme.bg.highlighted};
  }
`;
const WalletAddress = styled.span`
  color: ${props => props.theme.text.secondary};
  font-size: ${fontSize.xs};
  font-weight: 500;
`;
const ColFlex = styled.div`
  display: flex;
  flex-direction: column;
`;
const WalletBalance = styled.span`
  color: ${props => props.theme.text.neutral};
  font-size: ${fontSize.sm};
  font-weight: 500;
`;
const AccountAddress = styled.span`
  font-size: ${fontSize.md};
  color: ${props => props.theme.text.neutral};
  font-weight: 500;
`;
const AccountBalance = styled.span`
  font-size: ${fontSize.sm};
  color: ${props => props.theme.text.secondary};
  font-weight: 500;
`;
const DropdownLabel = styled.label`
  font-size: ${fontSize.sm};
  color: ${props => props.theme.text.secondary};
  font-weight: 500;
`;
const MenuButton = styled.button`
  all: unset;
  padding: ${spacing.sm} ${spacing.sm};
  border-radius: ${radius.md};
  background-color: ${props => props.theme.bg.base};
  border: 1px solid ${props => props.theme.border.elevated};
  box-sizing: border-box;
  display: flex;
  align-items: center;
  width: 100%;
  cursor: pointer;
  font-size: ${fontSize.md};
  font-weight: 500;
  color: ${props => props.theme.text.neutral} !important;
  gap: ${spacing.sm};
  -webkit-tap-highlight-color: transparent;
  line-height: 1.3;

  &:not([disabled]):hover {
    transition: box-shadow 250ms ease, border-color 250ms ease;
    border: 1px solid ${props => props.theme.link.primary};
    box-shadow: 0 0 0 1px ${props => props.theme.link.primary};
  }

  &[disabled] {
    cursor: not-allowed;
    svg {
      display: none;
    }
  }

  &[disabled]:hover {
    transition: box-shadow 250ms ease, border-color 250ms ease;
    border: 1px solid ${props => props.theme.text.danger};
    box-shadow: 0 0 0 1px ${props => props.theme.text.danger};
  }
`;
const MenuLink = /* @__PURE__ */MenuButton.withComponent("a");
styled( DropdownMenu.Item)`
  outline: none;
`;
const StyledChevronRightIcon = styled( ChevronRightIcon)`
  color: ${props => props.theme.text.secondary};
`;
const DisconnectIconButton = styled(IconButton)`
  margin-right: -${spacing.xxs};
  margin-left: auto;
  color: ${props => props.theme.icon.secondary};
  &:hover {
    color: ${props => props.theme.icon.danger};
    background: none;
  }
`;
const SecondaryIconContainer = styled.div`
  display: flex;
  align-items: center;
  justify-content: center;
  color: ${props => props.theme.icon.secondary};
`;
function WalletSwitcher(_ref) {
  let {
    wallet,
    onSwitch,
    name
  } = _ref;
  const walletContext = useWalletContext();
  return /*#__PURE__*/jsxs(MenuButton, {
    type: "button",
    onClick: () => {
      walletContext.setConnectedWallet(wallet);
      onSwitch();
    },
    style: {
      fontSize: fontSize.sm
    },
    children: [/*#__PURE__*/jsx(EnterIcon, {
      width: iconSize.sm,
      height: iconSize.sm
    }), "Switch to ", name]
  });
}

const LockIcon = props => {
  return /*#__PURE__*/jsx("svg", {
    width: props.size,
    height: props.size,
    viewBox: "0 0 16 21",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: /*#__PURE__*/jsx("path", {
      d: "M2 21C1.45 21 0.979333 20.8043 0.588 20.413C0.196 20.021 0 19.55 0 19V9C0 8.45 0.196 7.979 0.588 7.587C0.979333 7.19567 1.45 7 2 7H3V5C3 3.61667 3.48767 2.43733 4.463 1.462C5.43767 0.487333 6.61667 0 8 0C9.38333 0 10.5627 0.487333 11.538 1.462C12.5127 2.43733 13 3.61667 13 5V7H14C14.55 7 15.021 7.19567 15.413 7.587C15.8043 7.979 16 8.45 16 9V19C16 19.55 15.8043 20.021 15.413 20.413C15.021 20.8043 14.55 21 14 21H2ZM8 16C8.55 16 9.021 15.8043 9.413 15.413C9.80433 15.021 10 14.55 10 14C10 13.45 9.80433 12.979 9.413 12.587C9.021 12.1957 8.55 12 8 12C7.45 12 6.97933 12.1957 6.588 12.587C6.196 12.979 6 13.45 6 14C6 14.55 6.196 15.021 6.588 15.413C6.97933 15.8043 7.45 16 8 16ZM5 7H11V5C11 4.16667 10.7083 3.45833 10.125 2.875C9.54167 2.29167 8.83333 2 8 2C7.16667 2 6.45833 2.29167 5.875 2.875C5.29167 3.45833 5 4.16667 5 5V7Z",
      fill: "currentColor"
    })
  });
};

const SignatureModal = props => {
  const walletConfig = useWalletConfig();
  return /*#__PURE__*/jsx(Modal, {
    open: props.open,
    style: {
      maxWidth: "450px"
    },
    setOpen: props.setOpen,
    children: /*#__PURE__*/jsxs(Container, {
      children: [walletConfig && /*#__PURE__*/jsx(Img, {
        height: iconSize.xl,
        src: walletConfig.meta.iconURL,
        width: iconSize.xl
      }), /*#__PURE__*/jsx(Spacer, {
        y: "xl"
      }), /*#__PURE__*/jsxs(TitleContainer, {
        children: [/*#__PURE__*/jsx(ModalTitle, {
          children: "Signature Request"
        }), /*#__PURE__*/jsx(Spinner, {
          size: "md",
          color: "link"
        })]
      }), /*#__PURE__*/jsx(Spacer, {
        y: "md"
      }), /*#__PURE__*/jsx(Desc, {
        children: "Sign the signature request pop-up in your wallet"
      }), /*#__PURE__*/jsx(Spacer, {
        y: "xxl"
      }), /*#__PURE__*/jsx(HelperLink, {
        target: "_blank",
        href: "https://support.thirdweb.com/contact",
        children: "Having troubles connecting to wallet"
      })]
    })
  });
};
const TitleContainer = styled.div`
  display: flex;
  align-items: center;
  gap: ${spacing.sm};

  ${media.mobile} {
    justify-content: center;
    flex-direction: column;
    gap: ${spacing.md};
  }
`;
const Desc = styled(ModalDescription)`
  ${media.mobile} {
    max-width: 240px;
    margin: 0 auto;
  }
`;
const Container = styled.div`
  ${media.mobile} {
    display: flex;
    flex-direction: column;
    align-items: center;
  }
`;

const TW_CONNECT_WALLET = "tw-connect-wallet";

/**
 * A component that allows the user to connect their wallet.
 *
 * The button must be descendant of `ThirdwebProvider` in order to function.
 */
const ConnectWallet = props => {
  const activeWallet = useWallet();
  const themeFromProvider = useContext(ThirdwebThemeContext);
  const theme = props.theme || themeFromProvider || "dark";
  const connectionStatus = useConnectionStatus();
  const isLoading = connectionStatus === "connecting" || connectionStatus === "unknown";
  const btnTitle = props.btnTitle || "Connect Wallet";
  const setIsWalletModalOpen = useSetIsWalletModalOpen();
  const setModalConfig = useContext(SetModalConfigCtx);
  const address = useAddress();
  const [showSignatureModal, setShowSignatureModal] = useState(false);
  const authConfig = useThirdwebAuthContext();
  const {
    user
  } = useUser();
  const {
    login
  } = useLogin();
  const {
    logout
  } = useLogout();
  const requiresSignIn = props.auth?.loginOptional ? false : !!authConfig?.authUrl && !!address && !user?.address;
  const signIn = async () => {
    try {
      setShowSignatureModal(true);
      const token = await login();
      props?.auth?.onLogin?.(token);
    } catch (err) {
      console.error("failed to log in", err);
    }
    setShowSignatureModal(false);
  };
  return /*#__PURE__*/jsxs(ThemeProvider, {
    theme: theme === "dark" ? darkTheme : lightTheme,
    children: [showSignatureModal && /*#__PURE__*/jsx(SignatureModal, {
      open: showSignatureModal,
      setOpen: setShowSignatureModal
    }), requiresSignIn && /*#__PURE__*/jsxs(Button, {
      variant: "inverted",
      onClick: signIn,
      "data-theme": theme,
      className: `${TW_CONNECT_WALLET}--sign-in ${props.className || ""}}`,
      style: props.style,
      children: [/*#__PURE__*/jsxs(Flex, {
        alignItems: "center",
        gap: "sm",
        style: {
          paddingRight: spacing.xs,
          borderRight: "1px solid",
          marginRight: spacing.xs
        },
        children: [/*#__PURE__*/jsx(LockIcon, {
          size: iconSize.sm
        }), /*#__PURE__*/jsx("span", {
          children: " Sign in "
        })]
      }), /*#__PURE__*/jsx("span", {
        children: shortenAddress(address || "", true)
      })]
    }), !requiresSignIn && (!activeWallet ?
    /*#__PURE__*/
    // connect wallet button
    jsx(AnimatedButton, {
      disabled: isLoading,
      className: `${props.className || ""} ${TW_CONNECT_WALLET}`,
      "data-theme": theme,
      "data-is-loading": isLoading,
      variant: "inverted",
      type: "button",
      style: {
        minWidth: "140px",
        ...props.style
      },
      "aria-label": connectionStatus === "connecting" ? "Connecting" : btnTitle,
      onClick: () => {
        setModalConfig({
          title: props.modalTitle || "Choose your wallet",
          theme,
          data: undefined
        });
        setIsWalletModalOpen(true);
      },
      "data-test": "connect-wallet-button",
      children: isLoading ? /*#__PURE__*/jsx(Spinner, {
        size: "sm",
        color: "inverted"
      }) : btnTitle
    }) : /*#__PURE__*/jsx(ConnectedWalletDetails, {
      networkSelector: props.networkSelector,
      dropdownPosition: props.dropdownPosition,
      className: props.className,
      theme: theme,
      style: props.style,
      detailsBtn: props.detailsBtn,
      onDisconnect: () => {
        if (authConfig?.authUrl) {
          logout();
          props?.auth?.onLogout?.();
        }
      }
    }))]
  });
};
const AnimatedButton = styled(Button)`
  animation: ${fadeInAnimation} 300ms ease;
`;

let video;
function supportsVideoType(mimeType) {
  if (typeof window === "undefined" || !mimeType || !mimeType.startsWith("video/")) {
    return "";
  }
  if (!video) {
    video = document.createElement("video");
  }
  return video.canPlayType(mimeType);
}
function shouldRenderVideoTag(mimeType) {
  return !!supportsVideoType(mimeType);
}
let audio;
function supportsAudioType(mimeType) {
  if (typeof window === "undefined" || !mimeType || !mimeType.startsWith("audio/")) {
    return "";
  }
  if (!audio) {
    audio = document.createElement("audio");
  }
  return audio.canPlayType(mimeType);
}
function shouldRenderAudioTag(mimeType) {
  return !!supportsAudioType(mimeType);
}

function mergeRefs(refs) {
  return value => {
    refs.forEach(ref => {
      if (typeof ref === "function") {
        ref(value);
        // eslint-disable-next-line eqeqeq
      } else if (ref != null) {
        ref.current = value;
      }
    });
  };
}

const CarbonDocumentUnknown = props => {
  return /*#__PURE__*/jsxs("svg", {
    width: "1em",
    height: "1em",
    viewBox: "0 0 32 32",
    ...props,
    children: [/*#__PURE__*/jsx("circle", {
      cx: "9",
      cy: "28.5",
      r: "1.5",
      fill: "currentColor"
    }), /*#__PURE__*/jsx("path", {
      fill: "currentColor",
      d: "M10 25H8v-4h2a2 2 0 0 0 0-4H8a2.002 2.002 0 0 0-2 2v.5H4V19a4.005 4.005 0 0 1 4-4h2a4 4 0 0 1 0 8Z"
    }), /*#__PURE__*/jsx("path", {
      fill: "currentColor",
      d: "m27.7 9.3l-7-7A.908.908 0 0 0 20 2H10a2.006 2.006 0 0 0-2 2v8h2V4h8v6a2.006 2.006 0 0 0 2 2h6v16H14v2h12a2.006 2.006 0 0 0 2-2V10a.91.91 0 0 0-.3-.7ZM20 10V4.4l5.6 5.6Z"
    })]
  });
};
const CarbonDocumentAudio = props => {
  return /*#__PURE__*/jsxs("svg", {
    width: "1em",
    height: "1em",
    viewBox: "0 0 32 32",
    ...props,
    children: [/*#__PURE__*/jsx("path", {
      fill: "currentColor",
      d: "M29 31a.999.999 0 0 1-.625-.22L23.65 27H20a1 1 0 0 1-1-1v-5a1 1 0 0 1 1-1h3.65l4.726-3.78A1 1 0 0 1 30 17v13a1 1 0 0 1-1 1Zm-8-6h3a1 1 0 0 1 .625.22L28 27.92v-8.84l-3.376 2.7A1 1 0 0 1 24 22h-3Z"
    }), /*#__PURE__*/jsx("path", {
      fill: "currentColor",
      d: "M16 28H8V4h8v6a2.006 2.006 0 0 0 2 2h6v3h2v-5a.91.91 0 0 0-.3-.7l-7-7A.909.909 0 0 0 18 2H8a2.006 2.006 0 0 0-2 2v24a2.006 2.006 0 0 0 2 2h8Zm2-23.6l5.6 5.6H18Z"
    })]
  });
};
const CarbonPauseFilled = props => {
  return /*#__PURE__*/jsx("svg", {
    width: "1em",
    height: "1em",
    viewBox: "0 0 32 32",
    ...props,
    children: /*#__PURE__*/jsx("path", {
      fill: "currentColor",
      d: "M12 6h-2a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2zm10 0h-2a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2z"
    })
  });
};
const CarbonPlayFilledAlt = props => {
  return /*#__PURE__*/jsx("svg", {
    width: "1em",
    height: "1em",
    viewBox: "0 0 32 32",
    ...props,
    children: /*#__PURE__*/jsx("path", {
      fill: "currentColor",
      d: "M7 28a1 1 0 0 1-1-1V5a1 1 0 0 1 1.482-.876l20 11a1 1 0 0 1 0 1.752l-20 11A1 1 0 0 1 7 28Z"
    })
  });
};

const ModelViewer = /* @__PURE__ */lazy(() => import('./ModelViewer-fa8fcf0b.esm.js'));
const PlayButton = _ref => {
  let {
    onClick,
    isPlaying
  } = _ref;
  const [isHovering, setIsHovering] = useState(false);
  const onMouseEnter = () => setIsHovering(true);
  const onMouseLeave = () => setIsHovering(false);
  const onMouseDown = () => setIsHovering(false);
  const onMouseUp = () => setIsHovering(true);
  return /*#__PURE__*/jsx("button", {
    style: {
      position: "absolute",
      bottom: 0,
      right: 0,
      transform: "translate(-25%, -25%)",
      maxWidth: "32px",
      width: "8%",
      minWidth: "24px",
      aspectRatio: "1",
      zIndex: 3,
      backgroundColor: "#fff",
      color: "rgb(138, 147, 155)",
      display: "grid",
      placeItems: "center",
      borderRadius: "50%",
      border: "1px solid rgb(229, 232, 235)",
      cursor: "pointer",
      ...(isHovering ? {
        color: "rgb(53, 56, 64)",
        boxShadow: "rgb(4 17 29 / 25%) 0px 0px 8px 0px"
      } : {})
    },
    onClick: onClick,
    onMouseEnter: onMouseEnter,
    onMouseLeave: onMouseLeave,
    onMouseDown: onMouseDown,
    onMouseUp: onMouseUp,
    children: !isPlaying ? /*#__PURE__*/jsx(CarbonPlayFilledAlt, {
      style: {
        width: "66%",
        height: "66%"
      }
    }) : /*#__PURE__*/jsx(CarbonPauseFilled, {
      style: {
        width: "66%",
        height: "66%"
      }
    })
  });
};
const VideoPlayer = /* @__PURE__ */React.forwardRef((_ref2, ref) => {
  let {
    src,
    alt,
    poster,
    requireInteraction,
    style,
    width,
    height,
    controls,
    ...restProps
  } = _ref2;
  const videoRef = useRef(null);
  const [playing, setPlaying] = useState(!requireInteraction);
  const [muted, setMuted] = useState(true);
  useEffect(() => {
    if (videoRef.current) {
      if (playing) {
        try {
          videoRef.current.play();
        } catch (err) {
          console.error("error playing video", err);
        }
      } else {
        try {
          videoRef.current.pause();
          videoRef.current.currentTime = 0;
        } catch (err) {
          console.error("error pausing video", err);
        }
      }
    }
  }, [playing]);
  return /*#__PURE__*/jsxs("div", {
    style: {
      position: "relative",
      ...style
    },
    ...restProps,
    children: [/*#__PURE__*/jsx("video", {
      ref: mergeRefs([videoRef, ref]),
      src: src ?? undefined,
      poster: poster ?? undefined,
      loop: true,
      playsInline: true,
      controlsList: "nodownload",
      muted: muted,
      preload: poster ? "metadata" : "auto",
      onCanPlay: () => {
        if (playing) {
          videoRef.current?.play();
        }
      },
      width: width,
      height: height,
      controls: controls,
      style: {
        height: "100%",
        width: "100%",
        objectFit: "contain",
        zIndex: 1,
        transition: "opacity .5s",
        opacity: !poster ? 1 : playing ? 1 : 0
      }
    }), poster && /*#__PURE__*/jsx("img", {
      src: poster,
      style: {
        objectFit: "contain",
        pointerEvents: "none",
        position: "absolute",
        width: "100%",
        height: "100%",
        zIndex: 2,
        transition: "opacity .5s",
        opacity: playing ? 0 : 1,
        top: 0,
        left: 0,
        right: 0,
        bottom: 0
      },
      alt: alt
    }), /*#__PURE__*/jsx(PlayButton, {
      onClick: () => {
        setPlaying(prev => !prev);
        setMuted(false);
      },
      isPlaying: playing
    })]
  });
});
VideoPlayer.displayName = "VideoPlayer";
const AudioPlayer = /* @__PURE__ */React.forwardRef((_ref3, ref) => {
  let {
    src,
    alt,
    poster,
    style,
    height,
    width,
    ...restProps
  } = _ref3;
  const audioRef = useRef(null);
  const [playing, setPlaying] = useState(false);
  const [muted, setMuted] = useState(true);
  useEffect(() => {
    if (audioRef.current) {
      if (playing) {
        audioRef.current.play();
      } else {
        audioRef.current.pause();
        audioRef.current.currentTime = 0;
      }
    }
  }, [playing]);
  return /*#__PURE__*/jsxs("div", {
    style: {
      position: "relative",
      ...style
    },
    ...restProps,
    children: [poster ? /*#__PURE__*/jsx("img", {
      height: height,
      width: width,
      src: poster,
      style: {
        height: "100%",
        width: "100%",
        pointerEvents: "none",
        objectFit: "contain"
      },
      alt: alt
    }) : /*#__PURE__*/jsx("div", {
      style: {
        width: "100%",
        height: "100%",
        display: "grid",
        placeItems: "center",
        pointerEvents: "none",
        backgroundColor: "#fff",
        color: "rgb(138, 147, 155)"
      },
      children: /*#__PURE__*/jsx(CarbonDocumentAudio, {
        style: {
          height: "64px",
          width: "64px"
        }
      })
    }), /*#__PURE__*/jsx(PlayButton, {
      onClick: () => {
        setPlaying(prev => !prev);
        setMuted(false);
      },
      isPlaying: playing
    }), /*#__PURE__*/jsx("audio", {
      ref: mergeRefs([audioRef, ref]),
      src: src ?? undefined,
      loop: true,
      playsInline: true,
      muted: muted,
      preload: "none",
      controlsList: "nodownload",
      style: {
        position: "absolute",
        opacity: 0,
        pointerEvents: "none",
        zIndex: -1,
        visibility: "hidden"
      }
    })]
  });
});
AudioPlayer.displayName = "AudioPlayer";
const IframePlayer = /* @__PURE__ */React.forwardRef((_ref4, ref) => {
  let {
    src,
    alt,
    poster,
    requireInteraction,
    style,
    ...restProps
  } = _ref4;
  const [playing, setPlaying] = useState(!requireInteraction);
  return /*#__PURE__*/jsxs("div", {
    style: {
      position: "relative",
      ...style
    },
    ...restProps,
    children: [/*#__PURE__*/jsx("iframe", {
      src: playing ? src ?? undefined : undefined,
      ref: ref,
      style: {
        objectFit: "contain",
        zIndex: 1,
        height: "100%",
        width: "100%",
        transition: "opacity .5s",
        opacity: !poster ? 1 : playing ? 1 : 0
      },
      sandbox: "allow-scripts",
      allow: "accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
    }), poster && /*#__PURE__*/jsx("img", {
      src: poster,
      style: {
        objectFit: "contain",
        pointerEvents: "none",
        position: "absolute",
        width: "100%",
        height: "100%",
        zIndex: 2,
        transition: "opacity .5s",
        opacity: playing ? 0 : 1,
        top: 0,
        left: 0,
        right: 0,
        bottom: 0
      },
      alt: alt
    }), /*#__PURE__*/jsx(PlayButton, {
      onClick: () => {
        setPlaying(prev => !prev);
      },
      isPlaying: playing
    })]
  });
});
IframePlayer.displayName = "IframePlayer";
const LinkPlayer = /* @__PURE__ */React.forwardRef((_ref5, ref) => {
  let {
    src,
    alt,
    style,
    ...restProps
  } = _ref5;
  return /*#__PURE__*/jsx("div", {
    style: {
      position: "relative",
      ...style
    },
    ...restProps,
    children: /*#__PURE__*/jsx("div", {
      style: {
        width: "100%",
        height: "100%",
        display: "grid",
        placeItems: "center",
        backgroundColor: "#fff",
        color: "rgb(138, 147, 155)"
      },
      children: /*#__PURE__*/jsxs("div", {
        style: {
          display: "flex",
          flexDirection: "column",
          gap: "8px",
          alignItems: "center",
          flexWrap: "nowrap"
        },
        children: [/*#__PURE__*/jsx(CarbonDocumentUnknown, {
          style: {
            maxWidth: "128px",
            minWidth: "48px",
            width: "50%",
            aspectRatio: "1"
          }
        }), /*#__PURE__*/jsx("a", {
          rel: "noopener noreferrer",
          style: {
            textDecoration: "underline",
            color: "rgb(138, 147, 155)"
          },
          href: src ?? undefined,
          target: "_blank",
          ref: ref,
          children: alt || "File"
        })]
      })
    })
  });
});
LinkPlayer.displayName = "LinkPlayer";

/**
 * This component can be used to render any media type, including image, audio, video, and html files.
 * Its convenient for rendering NFT media files, as these can be a variety of different types.
 * The component falls back to a external link if the media type is not supported.
 * The default size is 300px by 300px, but this can be changed using the `width` and `height` props.
 *
 * Props: {@link MediaRendererProps}
 *
 * @example
 * We can take a video file hosted on IPFS and render it using this component as follows
 * ```jsx
 * const Component = () => {
 *   return <MediaRenderer
 *     src="ipfs://Qmb9ZV5yznE4C4YvyJe8DVFv1LSVkebdekY6HjLVaKmHZi"
 *     alt="A mp4 video"
 *   />
 * }
 * ```
 *
 * You can try switching out the `src` prop to different types of URLs and media types to explore the possibilities.
 */
const MediaRenderer = /* @__PURE__ */React.forwardRef((_ref6, ref) => {
  let {
    src,
    poster,
    alt,
    gatewayUrl,
    requireInteraction = false,
    width = "300px",
    height = "300px",
    style,
    mimeType,
    ...restProps
  } = _ref6;
  const mergedStyle = {
    objectFit: "contain",
    width,
    height,
    ...style
  };
  const videoOrImageSrc = useResolvedMediaType(src ?? undefined, mimeType, gatewayUrl);
  const possiblePosterSrc = useResolvedMediaType(poster ?? undefined, undefined, gatewayUrl);
  if (!videoOrImageSrc.mimeType) {
    return /*#__PURE__*/jsx("img", {
      style: mergedStyle,
      ...restProps,
      ref: ref,
      alt: alt
    });
  } else if (videoOrImageSrc.mimeType === "text/html") {
    return /*#__PURE__*/jsx(IframePlayer, {
      style: mergedStyle,
      src: videoOrImageSrc.url,
      poster: possiblePosterSrc.url,
      requireInteraction: requireInteraction,
      ...restProps
    });
  } else if (videoOrImageSrc.mimeType.startsWith("model")) {
    return /*#__PURE__*/jsx(Suspense, {
      fallback: poster ? /*#__PURE__*/jsx("img", {
        style: mergedStyle,
        src: poster,
        alt: alt,
        ref: ref,
        ...restProps
      }) : null,
      children: /*#__PURE__*/jsx(ModelViewer, {
        style: mergedStyle,
        src: videoOrImageSrc.url || "",
        poster: poster,
        alt: alt,
        ...restProps
      })
    });
  } else if (shouldRenderVideoTag(videoOrImageSrc.mimeType)) {
    return /*#__PURE__*/jsx(VideoPlayer, {
      style: mergedStyle,
      src: videoOrImageSrc.url,
      poster: possiblePosterSrc.url,
      requireInteraction: requireInteraction,
      ...restProps
    });
  } else if (shouldRenderAudioTag(videoOrImageSrc.mimeType)) {
    return /*#__PURE__*/jsx(AudioPlayer, {
      style: mergedStyle,
      src: videoOrImageSrc.url,
      poster: possiblePosterSrc.url,
      requireInteraction: requireInteraction,
      ...restProps
    });
  } else if (videoOrImageSrc.mimeType.startsWith("image/")) {
    return /*#__PURE__*/jsx("img", {
      style: mergedStyle,
      src: videoOrImageSrc.url,
      alt: alt,
      ref: ref,
      ...restProps
    });
  }
  return /*#__PURE__*/jsx(LinkPlayer, {
    style: mergedStyle,
    src: videoOrImageSrc.url,
    alt: alt,
    ref: ref,
    ...restProps
  });
});
MediaRenderer.displayName = "MediaRenderer";
/**
 * @param uri - the uri to resolve (can be a url or a ipfs://\<cid\>)
 * @returns the fully resolved url + mime type of the media
 *
 * @example
 * Usage with fully formed url:
 * ```jsx
 * const Component = () => {
 *   const resolved = useResolvedMediaType("https://example.com/video.mp4");
 *   console.log("mime type", resolved.data.mimeType);
 *   console.log("url", resolved.data.url);
 *   return null;
 * }
 * ```
 *
 * Usage with ipfs cid:
 * ```jsx
 * const Component = () => {
 *   const resolved = useResolvedMediaType("ipfs://QmWATWQ7fVPP2EFGu71UkfnqhYXDYH566qy47CnJDgvsd");
 *   console.log("mime type", resolved.data.mimeType);
 *   console.log("url", resolved.data.url);
 *   return null;
 * }
 * ```
 */
function useResolvedMediaType(uri, mimeType, gatewayUrl) {
  const storage = useStorage();
  const resolvedUrl = useMemo(() => resolveIpfsUri(uri, gatewayUrl ? {
    gatewayUrl
  } : storage ? {
    gatewayUrl: storage.gatewayUrls["ipfs://"][0]
  } : undefined), [uri, storage, gatewayUrl]);
  const resolvedMimType = useQuery(["mime-type", resolvedUrl], () => resolveMimeType(resolvedUrl), {
    enabled: !!resolvedUrl && !mimeType,
    initialData: mimeType
  });
  return {
    url: resolvedUrl,
    mimeType: resolvedMimType.data
  };
}

/**
 * This component can be used to render NFTs from the thirdweb SDK.
 * It will render the animation_url if it exists, otherwise it will render the image.
 * The default size is 300px by 300px, but this can be changed using the `width` and `height` props.
 *
 * Props: {@link ThirdwebNftMediaProps}
 *
 * @example
 * ```jsx
 * import { ThirdwebNftMedia, useContract, useNFT } from "@thirdweb-dev/react";
 * export default function NFTCollectionRender() {
 *   const { contract } = useContract(<your-contract-address>);
 *   const { data: nft, isLoading } = useNFT(contract, 0);
 *
 *   return (
 *     <div>
 *       {!isLoading && nft ? (
 *         <ThirdwebNftMedia metadata={nft.metadata} />
 *       ) : (
 *         <p>Loading...</p>
 *       )}
 *     </div>
 *   );
 * }
 * ```
 */
const ThirdwebNftMedia = /* @__PURE__ */React.forwardRef((_ref, ref) => {
  let {
    metadata,
    width = "300px",
    height = "300px",
    style,
    ...props
  } = _ref;
  return /*#__PURE__*/jsx(MediaRenderer, {
    src: metadata.animation_url || metadata.image,
    poster: metadata.image,
    alt: metadata.name?.toString() || "",
    ref: ref,
    width: width,
    height: height,
    style: {
      ...style
    },
    ...props
  });
});
ThirdwebNftMedia.displayName = "ThirdwebNftMedia";

const Popover = props => {
  return /*#__PURE__*/jsxs(RXPopover.Root, {
    open: props.open,
    onOpenChange: props.onOpenChange,
    children: [/*#__PURE__*/jsx(RXPopover.Trigger, {
      asChild: true,
      children: props.children
    }), /*#__PURE__*/jsx(RXPopover.Portal, {
      children: /*#__PURE__*/jsxs(PopoverContent, {
        sideOffset: 7,
        side: "top",
        children: [/*#__PURE__*/jsx(FlexWrapper, {
          children: props.content
        }), /*#__PURE__*/jsx(PopoverArrow, {})]
      })
    })]
  });
};
const slideUpAndFade = keyframes`
from {
    opacity: 0;
    transform: translateY(2px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
`;
const PopoverContent = styled( RXPopover.Content)`
  border-radius: ${radius.sm};
  padding: ${spacing.sm} ${spacing.md};
  background-color: ${p => p.theme.bg.inverted};
  box-shadow: ${shadow.md};
  animation-duration: 400ms;
  animation-timing-function: cubic-bezier(0.16, 1, 0.3, 1);
  will-change: transform, opacity;
  animation-name: ${slideUpAndFade};
  color: ${p => p.theme.text.inverted};
  font-size: ${fontSize.md};
`;
const PopoverArrow = styled( RXPopover.Arrow)`
  fill: ${p => p.theme.bg.inverted};
`;
const FlexWrapper = styled.div`
  display: flex;
  align-items: center;
  gap: ${spacing.sm};
`;

const TW_WEB3BUTTON = "tw-web3button";
/**
 * A component that allows the user to call an on-chain function on a contract.
 *
 * The button has to be wrapped in a `ThirdwebProvider` in order to function.
 *
 * @example
 * ```javascript
 * import { Web3Button } from "@thirdweb-dev/react";
 *
 * const App = () => {
 *  return (
 *   <div>
 *     <Web3Button contractAddress="0x..." action={(contract) => contract.erc721.transfer("0x...", 1)} />
 *   </div>
 * )
 * }
 * ```
 *
 *
 * @beta
 */
const Web3Button = _ref => {
  let {
    contractAddress,
    onSuccess,
    onError,
    onSubmit,
    isDisabled,
    contractAbi,
    children,
    action,
    className,
    type,
    theme,
    style
  } = _ref;
  const address = useAddress();
  const sdkChainId = useSDKChainId();
  const switchChain = useSwitchChain();
  const hasMismatch = useNetworkMismatch();
  const connectionStatus = useConnectionStatus();
  const queryClient = useQueryClient();
  const requiresConfirmation = !useIsHeadlessWallet();
  const {
    contract
  } = useContract(contractAddress, contractAbi || "custom");
  const thirdwebTheme = useContext(ThirdwebThemeContext);
  const themeToUse = theme || thirdwebTheme || "dark";
  const [confirmStatus, setConfirmStatus] = useState("idle");
  const actionMutation = useMutation(async () => {
    invariant(contract, "contract is not ready yet");
    if (onSubmit) {
      onSubmit();
    }

    // Wait for the promise to resolve, so errors get caught by onError
    const result = await action(contract);
    return result;
  }, {
    onSuccess: res => {
      if (onSuccess) {
        onSuccess(res);
      }
    },
    onError: err => {
      if (onError) {
        onError(err);
      }
    },
    onSettled: () => queryClient.invalidateQueries()
  });
  if (!address) {
    return /*#__PURE__*/jsx(ConnectWallet, {
      style: style,
      theme: theme,
      className: `${className || ""} ${TW_WEB3BUTTON}--connect-wallet`
    });
  }

  // let onClick = () => actionMutation.mutate();

  const btnStyle = {
    minWidth: "150px",
    minHeight: "43px"
  };
  let button = null;
  const handleSwitchChain = async () => {
    if (sdkChainId) {
      setConfirmStatus("waiting");
      try {
        await switchChain(sdkChainId);
        setConfirmStatus("idle");
      } catch (e) {
        console.error(e);
        setConfirmStatus("idle");
      }
    }
  };

  // Switch Network Button
  if (hasMismatch && !isDisabled) {
    const _button = /*#__PURE__*/jsx(Button, {
      variant: "inverted",
      type: type,
      className: `${className || ""} ${TW_WEB3BUTTON}--switch-network`,
      onClick: handleSwitchChain,
      style: {
        ...btnStyle,
        ...style
      },
      "data-is-loading": confirmStatus === "waiting",
      "data-theme": theme,
      children: confirmStatus === "waiting" ? /*#__PURE__*/jsx(Spinner, {
        size: "sm",
        color: "inverted"
      }) : "Switch Network"
    });
    if (requiresConfirmation) {
      button = /*#__PURE__*/jsx(Popover, {
        content: /*#__PURE__*/jsx("span", {
          children: "Confirm in Wallet"
        }),
        open: confirmStatus === "waiting",
        onOpenChange: isOpen => {
          if (!isOpen) {
            setConfirmStatus("idle");
          }
        },
        children: _button
      });
    } else {
      button = _button;
    }
  }

  // Disabled Loading Spinner Button
  else if (!isDisabled && (actionMutation.isLoading || !contract || connectionStatus === "connecting" || connectionStatus === "unknown")) {
    button = /*#__PURE__*/jsx(Button, {
      variant: "inverted",
      type: type,
      className: `${className || ""} ${TW_WEB3BUTTON}`,
      disabled: true,
      style: {
        ...btnStyle,
        ...style
      },
      "data-is-loading": true,
      "data-theme": theme,
      children: /*#__PURE__*/jsx(Spinner, {
        size: "md",
        color: "inverted"
      })
    });
  }

  // action button
  else {
    button = /*#__PURE__*/jsx(Button, {
      variant: "inverted",
      type: type,
      className: `${className || ""} ${TW_WEB3BUTTON}`,
      onClick: () => actionMutation.mutate(),
      disabled: isDisabled,
      style: {
        ...btnStyle,
        ...style
      },
      "data-is-loading": "false",
      "data-theme": theme,
      children: children
    });
  }
  return /*#__PURE__*/jsx(ThemeProvider, {
    theme: themeToUse === "dark" ? darkTheme : lightTheme,
    children: button
  });
};

const DEFAULT_API_KEY = "f9e23156ccfc6173c5267eaabf320fb692ffab1c2d572095a58091cbb67590cd";

const GetStartedWithWallets = _ref => {
  let {
    onBack
  } = _ref;
  const walletConfigs = useWallets();
  const {
    meta
  } = walletConfigs[0];
  return /*#__PURE__*/jsx(GetStartedScreen, {
    onBack: () => {
      onBack();
    },
    walletIconURL: meta.iconURL,
    walletName: meta.name,
    appleStoreLink: meta.urls?.ios,
    googlePlayStoreLink: meta.urls?.android,
    chromeExtensionLink: meta.urls?.chrome,
    header: /*#__PURE__*/jsxs(Fragment, {
      children: [/*#__PURE__*/jsx(ModalTitle, {
        children: " Get started with EVM wallets "
      }), /*#__PURE__*/jsx(Spacer, {
        y: "md"
      }), /*#__PURE__*/jsx(ModalDescription, {
        children: "An EVM Wallet is your gateway to interact with web3 apps on Ethereum and other custom blockchains."
      }), /*#__PURE__*/jsx(Spacer, {
        y: "xl"
      }), /*#__PURE__*/jsxs("div", {
        style: {
          display: "flex",
          gap: spacing.md,
          alignItems: "center"
        },
        children: [/*#__PURE__*/jsx(SecondaryText, {
          children: "We recommend"
        }), /*#__PURE__*/jsxs("div", {
          style: {
            display: "flex",
            gap: spacing.xs,
            alignItems: "center"
          },
          children: [/*#__PURE__*/jsx(Img, {
            src: meta.iconURL,
            width: iconSize.md,
            height: iconSize.md
          }), /*#__PURE__*/jsx(NeutralText, {
            children: meta.name
          })]
        })]
      })]
    }),
    footer: /*#__PURE__*/jsxs(Fragment, {
      children: [/*#__PURE__*/jsx(Spacer, {
        y: "xl"
      }), /*#__PURE__*/jsx(HelperLink, {
        target: "_blank",
        href: "https://ethereum.org/en/wallets/find-wallet/",
        style: {
          textAlign: "center"
        },
        children: "Learn more about wallets"
      }), " "]
    })
  });
};
const NeutralText = styled.p`
  font-size: ${fontSize.md};
  color: ${p => p.theme.text.neutral};
  margin: 0;
`;

const reservedScreens = {
  main: "main",
  getStarted: "getStarted"
};

const ConnectModal = () => {
  const {
    theme,
    title
  } = useContext(ModalConfigCtx);
  const walletConfigs = useWallets();
  const initialScreen = walletConfigs.length === 1 && !walletConfigs[0].selectUI ? walletConfigs[0] : reservedScreens.main;
  const [screen, setScreen] = useState(initialScreen);
  const isWalletModalOpen = useIsWalletModalOpen();
  const setIsWalletModalOpen = useSetIsWalletModalOpen();
  const connectionStatus = useConnectionStatus();
  const wallet = useWallet();
  const walletModalConfig = useContext(ModalConfigCtx);
  const setWalletModalConfig = useContext(SetModalConfigCtx);
  const disconnect = useDisconnect();
  const handleClose = useCallback(function () {
    let reset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    if (reset) {
      setScreen(initialScreen);
    }
    if (connectionStatus === "connecting") {
      disconnect();
    }
    setIsWalletModalOpen(false);
  }, [setIsWalletModalOpen, initialScreen, connectionStatus, disconnect]);
  const handleBack = useCallback(() => {
    setScreen(initialScreen);
  }, [setScreen, initialScreen]);
  const isWrapperConnected = !!wallet?.getPersonalWallet();
  const isWrapperScreen = typeof screen !== "string" && !!screen.personalWallets;
  const prevConnectionStatus = useRef(connectionStatus);

  // reopen the screen to complete wrapper wallet's next step after connecting a personal wallet
  useEffect(() => {
    if (!isWrapperConnected && isWrapperScreen && !isWalletModalOpen && connectionStatus === "connected" && prevConnectionStatus.current === "connecting") {
      setIsWalletModalOpen(true);
    }
    prevConnectionStatus.current = connectionStatus;
  }, [isWalletModalOpen, connectionStatus, setIsWalletModalOpen, isWrapperScreen, isWrapperConnected]);
  const WalletConnectUI = typeof screen !== "string" && (screen.connectUI || HeadlessConnectUI);
  return /*#__PURE__*/jsx(ThemeProvider, {
    theme: typeof theme === "object" ? theme : theme === "light" ? lightTheme : darkTheme,
    children: /*#__PURE__*/jsxs(Modal, {
      style: {
        maxWidth: "480px"
      },
      open: isWalletModalOpen,
      setOpen: value => {
        setIsWalletModalOpen(value);
        if (!value) {
          setScreen(initialScreen); // reset screen
        }

        if (connectionStatus === "connecting") {
          disconnect();
        }
      },
      children: [screen === reservedScreens.main && /*#__PURE__*/jsx(WalletSelector, {
        title: title,
        walletConfigs: walletConfigs,
        onGetStarted: () => {
          setScreen(reservedScreens.getStarted);
        },
        selectWallet: setScreen
      }), screen === reservedScreens.getStarted && /*#__PURE__*/jsx(GetStartedWithWallets, {
        onBack: handleBack
      }), WalletConnectUI && /*#__PURE__*/jsx(WalletConnectUI, {
        supportedWallets: walletConfigs,
        theme: theme,
        goBack: handleBack,
        close: handleClose,
        isOpen: isWalletModalOpen,
        open: () => {
          setIsWalletModalOpen(true);
        },
        walletConfig: screen,
        selectionData: walletModalConfig.data,
        setSelectionData: data => {
          setWalletModalConfig(config => ({
            ...config,
            data
          }));
        }
      })]
    })
  });
};

/**
 *
 * The `<ThirdwebProvider />` component lets you control what networks you want users to connect to,
 * what types of wallets can connect to your app, and the settings for the [Thirdweb SDK](https://docs.thirdweb.com/typescript).
 *
 * @example
 * You can wrap your application with the provider as follows:
 *
 * ```jsx title="App.jsx"
 * import { ThirdwebProvider } from "@thirdweb-dev/react";
 *
 * const App = () => {
 *   return (
 *     <ThirdwebProvider>
 *       <YourApp />
 *     </ThirdwebProvider>
 *   );
 * };
 * ```
 *
 */
const ThirdwebProvider = _ref => {
  let {
    thirdwebApiKey = DEFAULT_API_KEY,
    supportedWallets,
    theme,
    children,
    ...restProps
  } = _ref;
  const wallets = supportedWallets || defaultWallets;
  return /*#__PURE__*/jsx(WalletUIStatesProvider, {
    theme: theme,
    children: /*#__PURE__*/jsx(ThemeProvider, {
      theme: theme === "dark" ? darkTheme : lightTheme,
      children: /*#__PURE__*/jsxs(ThirdwebProviderCore, {
        theme: theme,
        thirdwebApiKey: thirdwebApiKey,
        supportedWallets: wallets,
        ...restProps,
        children: [children, /*#__PURE__*/jsx(ConnectModal, {})]
      })
    })
  });
};

function useInstalledWallets() {
  let isMetamaskInstalled = false;
  let isCoinbaseWalletInstalled = false;
  if (assertWindowEthereum(globalThis.window)) {
    isMetamaskInstalled = globalThis.window.ethereum?.isMetaMask;
    isCoinbaseWalletInstalled = globalThis.window.ethereum?.isCoinbaseWallet || globalThis.window.ethereum?.providers?.some(p => p.isCoinbaseWallet) || false;
  }
  const installedWallets = {
    metamask: !!isMetamaskInstalled,
    coinbaseWallet: !!isCoinbaseWalletInstalled
  };
  return installedWallets;
}

function useMetamask() {
  const connect = useConnect();
  return useCallback(async connectOptions => {
    const {
      metamaskWallet
    } = await import('./headlessConnectUI-d4e74332.esm.js').then(function (n) { return n.r; });
    return connect(metamaskWallet(), connectOptions);
  }, [connect]);
}

function useCoinbaseWallet() {
  const connect = useConnect();
  return useCallback(async connectOptions => {
    const {
      coinbaseWallet
    } = await import('./headlessConnectUI-d4e74332.esm.js').then(function (n) { return n.q; });
    return connect(coinbaseWallet(), connectOptions);
  }, [connect]);
}

function useFrameWallet() {
  const connect = useConnect();
  return useCallback(async connectOptions => {
    const {
      frameWallet
    } = await import('./frameWallet-20517e9f.esm.js');
    return connect(frameWallet(), connectOptions);
  }, [connect]);
}

function usePaperWallet() {
  const connect = useConnect();
  return useCallback(async options => {
    const {
      paperWallet
    } = await import('./paperWallet-06e4db58.esm.js');
    return connect(paperWallet({
      clientId: options.clientId
    }), {
      chainId: options.chainId,
      email: options.email
    });
  }, [connect]);
}
function usePaperWalletUserEmail() {
  const wallet = useWallet();
  const queryClient = useQueryClient();
  const emailQuery = useQuery([wallet?.walletId, "paper-email"], () => {
    if (!wallet || wallet.walletId !== walletIds.paper) {
      throw "Not connected to Paper Wallet";
    }
    return wallet.getEmail();
  }, {
    retry: false
  });

  // Invalidate the query when the wallet changes
  useEffect(() => {
    queryClient.invalidateQueries([wallet?.walletId, "paper-email"]);
  }, [wallet, queryClient]);
  return emailQuery;
}

function useWalletConnectV1() {
  const connect = useConnect();
  return useCallback(async options => {
    const {
      walletConnectV1
    } = await import('./headlessConnectUI-d4e74332.esm.js').then(function (n) { return n.s; });
    return connect(walletConnectV1(), options);
  }, [connect]);
}
function useWalletConnect() {
  const connect = useConnect();
  return useCallback(async options => {
    const {
      walletConnect
    } = await import('./walletConnect-33932892.esm.js');
    return connect(walletConnect(options), options);
  }, [connect]);
}

export { ConnectWallet as C, ExportLocalWallet as E, MediaRenderer as M, NetworkSelector as N, SecondaryText as S, ThirdwebProvider as T, Web3Button as W, useMetamask as a, useCoinbaseWallet as b, useFrameWallet as c, usePaperWalletUserEmail as d, usePaperWallet as e, useWalletConnect as f, useWalletConnectV1 as g, useResolvedMediaType as h, ThirdwebNftMedia as i, shortenAddress as s, useInstalledWallets as u };
