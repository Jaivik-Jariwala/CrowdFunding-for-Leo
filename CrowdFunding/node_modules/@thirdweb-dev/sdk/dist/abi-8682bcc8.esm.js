import { a8 as BigNumberTransformSchema, aa as AddressOrEnsSchema, a6 as BigNumberSchema, a7 as BigNumberishSchema, bK as hasMatchingAbi, e as AbiSchema, bX as detectFeatures, cd as getCreate2FactoryAddress, ck as computeDeploymentInfo, bO as extractConstructorParamsFromAbi, cg as computeDeploymentAddress, cb as isContractDeployed, cf as getInitBytecodeWithSalt, co as fetchAndCacheDeployMetadata } from './contract-publisher-40b0022e.esm.js';
import { z } from 'zod';
import { A as AmountSchema, C as CommonNFTOutput, b as CommonNFTInput, N as NFTInputOrUriSchema } from './QueryParams-3949f366.esm.js';
import { w as extractFeatures, j as deployCreate2Factory, n as convertParamValues } from './sdk-932b5efc.esm.js';
import { utils, BigNumber } from 'ethers';
import invariant from 'tiny-invariant';
import { GENERATED_ABI } from '@thirdweb-dev/generated-abis';

const PropertiesInput = /* @__PURE__ */(() => z.object({}).catchall(z.union([BigNumberTransformSchema, z.unknown()])))();

/**
 * @internal
 */
const OptionalPropertiesInput = /* @__PURE__ */(() => z.union([z.array(PropertiesInput), PropertiesInput]).optional())();

/**
 * @internal
 */
const TokenMintInputSchema = /* @__PURE__ */z.object({
  toAddress: AddressOrEnsSchema,
  amount: AmountSchema
});

/**
 * @public
 */

/**
 * @internal
 */
const EditionMetadataOutputSchema = /* @__PURE__ */z.object({
  supply: BigNumberSchema,
  metadata: CommonNFTOutput
});

/**
 * @internal
 */
const EditionMetadataWithOwnerOutputSchema = /* @__PURE__ */(() => EditionMetadataOutputSchema.extend({
  owner: z.string(),
  quantityOwned: BigNumberSchema
}))();

/**
 * @internal
 */
const EditionMetadataInputSchema = /* @__PURE__ */z.object({
  supply: BigNumberishSchema,
  metadata: CommonNFTInput
});

/**
 * @internal
 */
const EditionMetadataInputOrUriSchema = /* @__PURE__ */z.object({
  supply: BigNumberishSchema,
  metadata: NFTInputOrUriSchema
});

/**
 * @public
 */

let ProposalState = /*#__PURE__*/function (ProposalState) {
  ProposalState[ProposalState["Pending"] = 0] = "Pending";
  ProposalState[ProposalState["Active"] = 1] = "Active";
  ProposalState[ProposalState["Canceled"] = 2] = "Canceled";
  ProposalState[ProposalState["Defeated"] = 3] = "Defeated";
  ProposalState[ProposalState["Succeeded"] = 4] = "Succeeded";
  ProposalState[ProposalState["Queued"] = 5] = "Queued";
  ProposalState[ProposalState["Expired"] = 6] = "Expired";
  ProposalState[ProposalState["Executed"] = 7] = "Executed";
  return ProposalState;
}({});

/**
 * @internal
 * @param contractWrapper
 * @param abi
 * @returns
 */
function matchesPrebuiltAbi(contractWrapper, abi) {
  return hasMatchingAbi(AbiSchema.parse(contractWrapper.abi || []), [abi]);
}

/**
 * Return all the detected features in the abi
 * @param abi - parsed array of abi entries
 * @returns array of all detected extensions with full information on each feature
 * @internal
 * @deprecated use getAllDetectedExtensions instead
 */
function getAllDetectedFeatures(abi) {
  const features = [];
  extractFeatures(detectFeatures(abi), features);
  return features;
}

/**
 * Return all the detected extensions in the abi
 * @param abi - parsed array of abi entries
 * @returns array of all detected extensions with full information on each feature
 * @public
 */
function getAllDetectedExtensions(abi) {
  return getAllDetectedFeatures(abi).map(f => ({
    ...f,
    extensions: f.features
  }));
}

function toEther(amount) {
  return utils.formatEther(amount);
}

function toUnits(amount, decimals) {
  return utils.parseUnits(AmountSchema.parse(amount), decimals);
}

function toDisplayValue(amount, decimals) {
  return utils.formatUnits(amount, decimals);
}

/**
 *
 * @internal
 * @param provider
 * @param storage
 * @param create2Factory
 */
async function computeNativeTokenAddress(provider, storage, create2Factory) {
  if (!create2Factory) {
    create2Factory = await getCreate2FactoryAddress(provider);
  }
  return (await computeDeploymentInfo("infra", provider, storage, create2Factory, {
    contractName: "WETH9"
  })).transaction.predictedAddress;
}

/**
 * Direct deploy a contract at a deterministic address, using Create2 method
 * Address depends on the Create2 factory address and salt (if provided).
 *
 * @public
 *
 * @param bytecode
 * @param abi
 * @param signer
 * @param constructorArgs
 * @param saltForCreate2
 */
async function directDeployDeterministic(bytecode, abi, signer, constructorArgs, saltForCreate2) {
  let gasLimit = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 7000000;
  invariant(signer.provider, "Provider is required");
  const bytecodePrefixed = bytecode.startsWith("0x") ? bytecode : `0x${bytecode}`;

  // 1. Deploy CREATE2 factory (if not already exists)
  const create2Factory = await deployCreate2Factory(signer);

  // 2. Encode constructor params
  const constructorParamTypes = extractConstructorParamsFromAbi(abi).map(p => {
    return p.type;
  });
  const paramValues = convertParamValues(constructorParamTypes, constructorArgs);
  const encodedArgs = utils.defaultAbiCoder.encode(constructorParamTypes, paramValues);

  // 3. Construct deployment transaction
  const address = computeDeploymentAddress(bytecodePrefixed, encodedArgs, create2Factory, saltForCreate2);
  const contractDeployed = await isContractDeployed(address, signer.provider);
  let initBytecodeWithSalt = "";
  if (!contractDeployed) {
    console.debug(`deploying contract via create2 factory at: ${address}`);
    initBytecodeWithSalt = getInitBytecodeWithSalt(bytecodePrefixed, encodedArgs, saltForCreate2);
    let tx = {
      to: create2Factory,
      data: initBytecodeWithSalt
    };
    try {
      await signer.estimateGas(tx);
    } catch (e) {
      console.debug("error estimating gas while deploying prebuilt: ", e);
      tx.gasLimit = BigNumber.from(gasLimit);
    }

    // 4. Deploy
    await (await signer.sendTransaction(tx)).wait();
  } else {
    throw new Error(`Contract already deployed at ${address}`);
  }
}

/**
 * Direct deploy a contract at a deterministic address, using Create2 method
 * Address depends on the Create2 factory address and salt (if provided).
 *
 * @public
 *
 * @param publishMetadataUri
 * @param signer
 * @param storage
 * @param constructorArgs
 * @param saltForCreate2
 */
async function directDeployDeterministicWithUri(publishMetadataUri, signer, storage, constructorArgs, saltForCreate2) {
  let gasLimit = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 7000000;
  const {
    compilerMetadata
  } = await fetchAndCacheDeployMetadata(publishMetadataUri, storage);
  await directDeployDeterministic(compilerMetadata.bytecode, compilerMetadata.abi, signer, constructorArgs, saltForCreate2, gasLimit);
}
async function predictAddressDeterministic(bytecode, abi, provider, constructorArgs, saltForCreate2) {
  const bytecodePrefixed = bytecode.startsWith("0x") ? bytecode : `0x${bytecode}`;

  // 1. Deploy CREATE2 factory (if not already exists)
  const create2Factory = await getCreate2FactoryAddress(provider);

  // 2. Encode constructor params
  const constructorParamTypes = extractConstructorParamsFromAbi(abi).map(p => {
    return p.type;
  });
  const paramValues = convertParamValues(constructorParamTypes, constructorArgs);
  const encodedArgs = utils.defaultAbiCoder.encode(constructorParamTypes, paramValues);

  // 3. Construct deployment transaction
  const address = computeDeploymentAddress(bytecodePrefixed, encodedArgs, create2Factory, saltForCreate2);
  return address;
}
async function predictAddressDeterministicWithUri(publishMetadataUri, provider, storage, constructorArgs, saltForCreate2) {
  const {
    compilerMetadata
  } = await fetchAndCacheDeployMetadata(publishMetadataUri, storage);
  return await predictAddressDeterministic(compilerMetadata.bytecode, compilerMetadata.abi, provider, constructorArgs, saltForCreate2);
}

/**
 * Deploy a contract at a deterministic address, using Create2 method
 * Address depends on the Create2 factory address.
 *
 * @public
 *
 * @param type signer
 * @param bytecode
 * @param encodedArgs
 * @param create2FactoryAddress
 */
async function deployContractDeterministicRaw(signer, bytecode, encodedArgs, create2FactoryAddress, options, predictedAddress) {
  let gasLimit = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 7000000;
  // Check if the implementation contract is already deployed
  invariant(signer.provider, "Provider required");
  const contractDeployed = predictedAddress ? await isContractDeployed(predictedAddress, signer.provider) : false;
  if (!contractDeployed) {
    console.debug(`deploying contract via create2 factory at: ${predictedAddress}`);
    const initBytecodeWithSalt = getInitBytecodeWithSalt(bytecode, encodedArgs);
    let tx = {
      to: create2FactoryAddress,
      data: initBytecodeWithSalt
    };
    try {
      await signer.estimateGas(tx);
    } catch (e) {
      console.debug("error estimating gas while deploying prebuilt: ", e);
      tx.gasLimit = BigNumber.from(gasLimit);
    }
    await (await signer.sendTransaction(tx)).wait();
  }
}

function getCachedAbiForContract(address) {
  if (address in GENERATED_ABI) {
    return GENERATED_ABI[address];
  }
  return undefined;
}

export { EditionMetadataOutputSchema as E, OptionalPropertiesInput as O, ProposalState as P, TokenMintInputSchema as T, EditionMetadataWithOwnerOutputSchema as a, EditionMetadataInputSchema as b, EditionMetadataInputOrUriSchema as c, toUnits as d, toDisplayValue as e, getAllDetectedFeatures as f, getCachedAbiForContract as g, getAllDetectedExtensions as h, computeNativeTokenAddress as i, directDeployDeterministic as j, directDeployDeterministicWithUri as k, predictAddressDeterministicWithUri as l, matchesPrebuiltAbi as m, deployContractDeterministicRaw as n, predictAddressDeterministic as p, toEther as t };
