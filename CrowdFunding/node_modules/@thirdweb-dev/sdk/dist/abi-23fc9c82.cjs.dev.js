'use strict';

var contractPublisher = require('./contract-publisher-3b827ae5.cjs.dev.js');
var zod = require('zod');
var QueryParams = require('./QueryParams-ab6fb117.cjs.dev.js');
var sdk = require('./sdk-e77043a6.cjs.dev.js');
var ethers = require('ethers');
var invariant = require('tiny-invariant');
var generatedAbis = require('@thirdweb-dev/generated-abis');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var invariant__default = /*#__PURE__*/_interopDefault(invariant);

const PropertiesInput = /* @__PURE__ */(() => zod.z.object({}).catchall(zod.z.union([contractPublisher.BigNumberTransformSchema, zod.z.unknown()])))();

/**
 * @internal
 */
const OptionalPropertiesInput = /* @__PURE__ */(() => zod.z.union([zod.z.array(PropertiesInput), PropertiesInput]).optional())();

/**
 * @internal
 */
const TokenMintInputSchema = /* @__PURE__ */zod.z.object({
  toAddress: contractPublisher.AddressOrEnsSchema,
  amount: QueryParams.AmountSchema
});

/**
 * @public
 */

/**
 * @internal
 */
const EditionMetadataOutputSchema = /* @__PURE__ */zod.z.object({
  supply: contractPublisher.BigNumberSchema,
  metadata: QueryParams.CommonNFTOutput
});

/**
 * @internal
 */
const EditionMetadataWithOwnerOutputSchema = /* @__PURE__ */(() => EditionMetadataOutputSchema.extend({
  owner: zod.z.string(),
  quantityOwned: contractPublisher.BigNumberSchema
}))();

/**
 * @internal
 */
const EditionMetadataInputSchema = /* @__PURE__ */zod.z.object({
  supply: contractPublisher.BigNumberishSchema,
  metadata: QueryParams.CommonNFTInput
});

/**
 * @internal
 */
const EditionMetadataInputOrUriSchema = /* @__PURE__ */zod.z.object({
  supply: contractPublisher.BigNumberishSchema,
  metadata: QueryParams.NFTInputOrUriSchema
});

/**
 * @public
 */

let ProposalState = /*#__PURE__*/function (ProposalState) {
  ProposalState[ProposalState["Pending"] = 0] = "Pending";
  ProposalState[ProposalState["Active"] = 1] = "Active";
  ProposalState[ProposalState["Canceled"] = 2] = "Canceled";
  ProposalState[ProposalState["Defeated"] = 3] = "Defeated";
  ProposalState[ProposalState["Succeeded"] = 4] = "Succeeded";
  ProposalState[ProposalState["Queued"] = 5] = "Queued";
  ProposalState[ProposalState["Expired"] = 6] = "Expired";
  ProposalState[ProposalState["Executed"] = 7] = "Executed";
  return ProposalState;
}({});

/**
 * @internal
 * @param contractWrapper
 * @param abi
 * @returns
 */
function matchesPrebuiltAbi(contractWrapper, abi) {
  return contractPublisher.hasMatchingAbi(contractPublisher.AbiSchema.parse(contractWrapper.abi || []), [abi]);
}

/**
 * Return all the detected features in the abi
 * @param abi - parsed array of abi entries
 * @returns array of all detected extensions with full information on each feature
 * @internal
 * @deprecated use getAllDetectedExtensions instead
 */
function getAllDetectedFeatures(abi) {
  const features = [];
  sdk.extractFeatures(contractPublisher.detectFeatures(abi), features);
  return features;
}

/**
 * Return all the detected extensions in the abi
 * @param abi - parsed array of abi entries
 * @returns array of all detected extensions with full information on each feature
 * @public
 */
function getAllDetectedExtensions(abi) {
  return getAllDetectedFeatures(abi).map(f => ({
    ...f,
    extensions: f.features
  }));
}

function toEther(amount) {
  return ethers.utils.formatEther(amount);
}

function toUnits(amount, decimals) {
  return ethers.utils.parseUnits(QueryParams.AmountSchema.parse(amount), decimals);
}

function toDisplayValue(amount, decimals) {
  return ethers.utils.formatUnits(amount, decimals);
}

/**
 *
 * @internal
 * @param provider
 * @param storage
 * @param create2Factory
 */
async function computeNativeTokenAddress(provider, storage, create2Factory) {
  if (!create2Factory) {
    create2Factory = await contractPublisher.getCreate2FactoryAddress(provider);
  }
  return (await contractPublisher.computeDeploymentInfo("infra", provider, storage, create2Factory, {
    contractName: "WETH9"
  })).transaction.predictedAddress;
}

/**
 * Direct deploy a contract at a deterministic address, using Create2 method
 * Address depends on the Create2 factory address and salt (if provided).
 *
 * @public
 *
 * @param bytecode
 * @param abi
 * @param signer
 * @param constructorArgs
 * @param saltForCreate2
 */
async function directDeployDeterministic(bytecode, abi, signer, constructorArgs, saltForCreate2) {
  let gasLimit = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 7000000;
  invariant__default["default"](signer.provider, "Provider is required");
  const bytecodePrefixed = bytecode.startsWith("0x") ? bytecode : `0x${bytecode}`;

  // 1. Deploy CREATE2 factory (if not already exists)
  const create2Factory = await sdk.deployCreate2Factory(signer);

  // 2. Encode constructor params
  const constructorParamTypes = contractPublisher.extractConstructorParamsFromAbi(abi).map(p => {
    return p.type;
  });
  const paramValues = sdk.convertParamValues(constructorParamTypes, constructorArgs);
  const encodedArgs = ethers.utils.defaultAbiCoder.encode(constructorParamTypes, paramValues);

  // 3. Construct deployment transaction
  const address = contractPublisher.computeDeploymentAddress(bytecodePrefixed, encodedArgs, create2Factory, saltForCreate2);
  const contractDeployed = await contractPublisher.isContractDeployed(address, signer.provider);
  let initBytecodeWithSalt = "";
  if (!contractDeployed) {
    console.debug(`deploying contract via create2 factory at: ${address}`);
    initBytecodeWithSalt = contractPublisher.getInitBytecodeWithSalt(bytecodePrefixed, encodedArgs, saltForCreate2);
    let tx = {
      to: create2Factory,
      data: initBytecodeWithSalt
    };
    try {
      await signer.estimateGas(tx);
    } catch (e) {
      console.debug("error estimating gas while deploying prebuilt: ", e);
      tx.gasLimit = ethers.BigNumber.from(gasLimit);
    }

    // 4. Deploy
    await (await signer.sendTransaction(tx)).wait();
  } else {
    throw new Error(`Contract already deployed at ${address}`);
  }
}

/**
 * Direct deploy a contract at a deterministic address, using Create2 method
 * Address depends on the Create2 factory address and salt (if provided).
 *
 * @public
 *
 * @param publishMetadataUri
 * @param signer
 * @param storage
 * @param constructorArgs
 * @param saltForCreate2
 */
async function directDeployDeterministicWithUri(publishMetadataUri, signer, storage, constructorArgs, saltForCreate2) {
  let gasLimit = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 7000000;
  const {
    compilerMetadata
  } = await contractPublisher.fetchAndCacheDeployMetadata(publishMetadataUri, storage);
  await directDeployDeterministic(compilerMetadata.bytecode, compilerMetadata.abi, signer, constructorArgs, saltForCreate2, gasLimit);
}
async function predictAddressDeterministic(bytecode, abi, provider, constructorArgs, saltForCreate2) {
  const bytecodePrefixed = bytecode.startsWith("0x") ? bytecode : `0x${bytecode}`;

  // 1. Deploy CREATE2 factory (if not already exists)
  const create2Factory = await contractPublisher.getCreate2FactoryAddress(provider);

  // 2. Encode constructor params
  const constructorParamTypes = contractPublisher.extractConstructorParamsFromAbi(abi).map(p => {
    return p.type;
  });
  const paramValues = sdk.convertParamValues(constructorParamTypes, constructorArgs);
  const encodedArgs = ethers.utils.defaultAbiCoder.encode(constructorParamTypes, paramValues);

  // 3. Construct deployment transaction
  const address = contractPublisher.computeDeploymentAddress(bytecodePrefixed, encodedArgs, create2Factory, saltForCreate2);
  return address;
}
async function predictAddressDeterministicWithUri(publishMetadataUri, provider, storage, constructorArgs, saltForCreate2) {
  const {
    compilerMetadata
  } = await contractPublisher.fetchAndCacheDeployMetadata(publishMetadataUri, storage);
  return await predictAddressDeterministic(compilerMetadata.bytecode, compilerMetadata.abi, provider, constructorArgs, saltForCreate2);
}

/**
 * Deploy a contract at a deterministic address, using Create2 method
 * Address depends on the Create2 factory address.
 *
 * @public
 *
 * @param type signer
 * @param bytecode
 * @param encodedArgs
 * @param create2FactoryAddress
 */
async function deployContractDeterministicRaw(signer, bytecode, encodedArgs, create2FactoryAddress, options, predictedAddress) {
  let gasLimit = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 7000000;
  // Check if the implementation contract is already deployed
  invariant__default["default"](signer.provider, "Provider required");
  const contractDeployed = predictedAddress ? await contractPublisher.isContractDeployed(predictedAddress, signer.provider) : false;
  if (!contractDeployed) {
    console.debug(`deploying contract via create2 factory at: ${predictedAddress}`);
    const initBytecodeWithSalt = contractPublisher.getInitBytecodeWithSalt(bytecode, encodedArgs);
    let tx = {
      to: create2FactoryAddress,
      data: initBytecodeWithSalt
    };
    try {
      await signer.estimateGas(tx);
    } catch (e) {
      console.debug("error estimating gas while deploying prebuilt: ", e);
      tx.gasLimit = ethers.BigNumber.from(gasLimit);
    }
    await (await signer.sendTransaction(tx)).wait();
  }
}

function getCachedAbiForContract(address) {
  if (address in generatedAbis.GENERATED_ABI) {
    return generatedAbis.GENERATED_ABI[address];
  }
  return undefined;
}

exports.EditionMetadataInputOrUriSchema = EditionMetadataInputOrUriSchema;
exports.EditionMetadataInputSchema = EditionMetadataInputSchema;
exports.EditionMetadataOutputSchema = EditionMetadataOutputSchema;
exports.EditionMetadataWithOwnerOutputSchema = EditionMetadataWithOwnerOutputSchema;
exports.OptionalPropertiesInput = OptionalPropertiesInput;
exports.ProposalState = ProposalState;
exports.TokenMintInputSchema = TokenMintInputSchema;
exports.computeNativeTokenAddress = computeNativeTokenAddress;
exports.deployContractDeterministicRaw = deployContractDeterministicRaw;
exports.directDeployDeterministic = directDeployDeterministic;
exports.directDeployDeterministicWithUri = directDeployDeterministicWithUri;
exports.getAllDetectedExtensions = getAllDetectedExtensions;
exports.getAllDetectedFeatures = getAllDetectedFeatures;
exports.getCachedAbiForContract = getCachedAbiForContract;
exports.matchesPrebuiltAbi = matchesPrebuiltAbi;
exports.predictAddressDeterministic = predictAddressDeterministic;
exports.predictAddressDeterministicWithUri = predictAddressDeterministicWithUri;
exports.toDisplayValue = toDisplayValue;
exports.toEther = toEther;
exports.toUnits = toUnits;
