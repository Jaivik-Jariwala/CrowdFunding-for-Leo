'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var classPrivateFieldSet = require('../../../../dist/classPrivateFieldSet-f0dc2a42.cjs.dev.js');
var defineProperty = require('../../../../dist/defineProperty-21d22449.cjs.dev.js');
var ethers = require('ethers');
var oauth = require('@magic-ext/oauth');
var utils = require('ethers/lib/utils');
var magicSdk = require('magic-sdk');
var WagmiConnector = require('../../../../dist/WagmiConnector-d9779ee8.cjs.dev.js');
var normalizeChainId = require('../../../../dist/normalizeChainId-8778491e.cjs.dev.js');
require('@thirdweb-dev/chains');
require('eventemitter3');

// | {
//     oauthProvider: OAuthProvider;
//   }

const IS_SERVER = typeof window === "undefined";
class MagicBaseConnector extends WagmiConnector.WagmiConnector {
  constructor(config) {
    super(config);
    defineProperty._defineProperty(this, "id", "magic-link");
    defineProperty._defineProperty(this, "name", "Magic Link");
    defineProperty._defineProperty(this, "ready", !IS_SERVER);
    defineProperty._defineProperty(this, "provider", void 0);
    defineProperty._defineProperty(this, "magicOptions", void 0);
    this.magicOptions = config.options;
  }
  async getAccount() {
    const provider = new ethers.ethers.providers.Web3Provider(await this.getProvider()) // TODO: fix type mismatch
    ;

    const signer = provider.getSigner();
    const account = await signer.getAddress();
    if (account.startsWith("0x")) {
      return account;
    }
    return `0x${account}`;
  }
  async getProvider() {
    if (this.provider) {
      return this.provider;
    }
    const magic = this.getMagicSDK();
    this.provider = magic.rpcProvider;
    return this.provider;
  }
  async getSigner() {
    const provider = new ethers.ethers.providers.Web3Provider(await this.getProvider()) // TODO: fix type mismatch
    ;

    const signer = await provider.getSigner();
    return signer;
  }
  async isAuthorized() {
    const magic = this.getMagicSDK();
    try {
      return await magic.user.isLoggedIn();
    } catch (e) {
      return false;
    }
  }
  onAccountsChanged(accounts) {
    if (accounts.length === 0) {
      this.emit("disconnect");
    } else {
      this.emit("change", {
        account: utils.getAddress(accounts[0])
      });
    }
  }
  onChainChanged(chainId) {
    const id = normalizeChainId.normalizeChainId(chainId);
    const unsupported = this.isChainUnsupported(id);
    this.emit("change", {
      chain: {
        id,
        unsupported
      }
    });
  }
  onDisconnect() {
    this.emit("disconnect");
  }
  async disconnect() {
    const magic = this.getMagicSDK();
    await magic.user.logout();
  }
}
var _connectedChainId = /*#__PURE__*/new WeakMap();
var _type = /*#__PURE__*/new WeakMap();
class MagicAuthConnector extends MagicBaseConnector {
  // oauthProviders: OAuthProvider[];

  constructor(config) {
    super(config);
    defineProperty._defineProperty(this, "magicSDK", void 0);
    defineProperty._defineProperty(this, "magicSdkConfiguration", void 0);
    classPrivateFieldSet._classPrivateFieldInitSpec(this, _connectedChainId, {
      writable: true,
      value: void 0
    });
    classPrivateFieldSet._classPrivateFieldInitSpec(this, _type, {
      writable: true,
      value: void 0
    });
    defineProperty._defineProperty(this, "oauthCallbackUrl", void 0);
    this.magicSdkConfiguration = config.options.magicSdkConfiguration;
    classPrivateFieldSet._classPrivateFieldSet(this, _type, config.options.type);
    // this.oauthProviders = config.options.oauthOptions?.providers || [];
    // this.oauthCallbackUrl = config.options.oauthOptions?.callbackUrl;
  }

  async connect(options) {
    if (!this.magicOptions.apiKey) {
      throw new Error("Magic API Key is not provided.");
    }
    try {
      if (options.chainId) {
        this.initializeMagicSDK({
          chainId: options.chainId
        });
      }
      const provider = await this.getProvider();
      this.setupListeners();
      this.emit("message", {
        type: "connecting"
      });

      // Check if there is a user logged in
      const isAuthenticated = await this.isAuthorized();

      // Check if we have a chainId, in case of error just assign 0 for legacy
      let chainId;
      try {
        chainId = await this.getChainId();
      } catch (e) {
        chainId = 0;
      }
      classPrivateFieldSet._classPrivateFieldSet(this, _connectedChainId, chainId);

      // if there is a user logged in, return the user
      if (isAuthenticated) {
        return {
          provider,
          chain: {
            id: chainId,
            unsupported: false
          },
          account: await this.getAccount()
        };
      }
      const magic = this.getMagicSDK();
      if (classPrivateFieldSet._classPrivateFieldGet(this, _type) === "connect") {
        if ("email" in options || "phoneNumber" in options) {
          console.warn("Passing email or phoneNumber is not required for Magic Connect");
        }
        await magic.wallet.connectWithUI();
      } else {
        // LOGIN WITH MAGIC LINK WITH OAUTH PROVIDER
        // if ("oauthProvider" in options) {
        //   await magic.oauth.loginWithRedirect({
        //     provider: options.oauthProvider,
        //     redirectURI: this.oauthCallbackUrl || window.location.href,
        //   });
        // }

        // LOGIN WITH MAGIC LINK WITH EMAIL
        if ("email" in options) {
          await magic.auth.loginWithMagicLink({
            email: options.email,
            showUI: true
          });
        }

        // LOGIN WITH MAGIC LINK WITH PHONE NUMBER
        else if ("phoneNumber" in options) {
          await magic.auth.loginWithSMS({
            phoneNumber: options.phoneNumber
          });
        } else {
          throw new Error("Invalid options: Either provide and email or phoneNumber when using Magic Auth");
        }
      }
      const signer = await this.getSigner();
      let account = await signer.getAddress();
      if (!account.startsWith("0x")) {
        account = `0x${account}`;
      }
      return {
        account,
        chain: {
          id: chainId,
          unsupported: false
        },
        provider
      };

      // throw new UserRejectedRequestError("User rejected request");
    } catch (error) {
      console.error(error);
      throw new Error("Something went wrong");
    }
  }
  async getChainId() {
    const networkOptions = this.magicSdkConfiguration?.network;
    if (typeof networkOptions === "object") {
      const chainID = networkOptions.chainId;
      if (chainID) {
        return normalizeChainId.normalizeChainId(chainID);
      }
    }
    throw new Error("Chain ID is not defined");
  }
  initializeMagicSDK() {
    let {
      chainId
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const options = {
      ...this.magicSdkConfiguration,
      extensions: [new oauth.OAuthExtension()]
    };
    if (chainId) {
      const chain = this.chains.find(c => c.chainId === chainId);
      if (chain) {
        options.network = {
          rpcUrl: chain.rpc[0],
          chainId: chain.chainId
        };
      }
    }
    this.magicSDK = new magicSdk.Magic(this.magicOptions.apiKey, options);
    this.provider = this.magicSDK.rpcProvider;
    return this.magicSDK;
  }
  getMagicSDK() {
    if (!this.magicSDK) {
      return this.initializeMagicSDK();
    }
    return this.magicSDK;
  }
  async setupListeners() {
    const provider = await this.getProvider();
    provider.on("accountsChanged", this.onAccountsChanged);
    provider.on("chainChanged", this.onChainChanged);
    provider.on("disconnect", this.onDisconnect);
  }
  async switchChain(chainId) {
    const chain = this.chains.find(c => c.chainId === chainId);
    if (!chain) {
      throw new Error("Chain not found");
    }
    if (classPrivateFieldSet._classPrivateFieldGet(this, _connectedChainId) !== chainId) {
      this.initializeMagicSDK({
        chainId
      });
    }
    return chain;
  }
}

exports.MagicAuthConnector = MagicAuthConnector;
exports.MagicBaseConnector = MagicBaseConnector;
