import { _ as _classPrivateMethodInitSpec, a as _classPrivateMethodGet } from './classPrivateMethodGet-ea199cc3.browser.esm.js';
import { _ as _classPrivateFieldInitSpec, a as _classPrivateFieldSet, b as _classPrivateFieldGet } from './classPrivateFieldSet-a5db7c83.browser.esm.js';
import { _ as _defineProperty } from './defineProperty-c8ecdc07.browser.esm.js';
import { a as AbstractClientWallet } from './base-8189a847.browser.esm.js';
import { w as walletIds } from './walletIds-99b78e4a.browser.esm.js';
import { Core } from '@walletconnect/core';
import { Web3Wallet } from '@walletconnect/web3wallet';
import { utils } from 'ethers';
import EventEmitter from 'eventemitter3';
import { E as EIP155_SIGNING_METHODS, T as TW_WC_PROJECT_ID, W as WC_RELAY_URL } from './wc-c6a6a61c.browser.esm.js';
import { formatJsonRpcResult } from '@walletconnect/jsonrpc-utils';
import WalletConnect from '@walletconnect/client';
import { isContractDeployed, ThirdwebSDK } from '@thirdweb-dev/sdk';

const PREFIX = "__TW__";
class LocalStorage {
  constructor(name) {
    _defineProperty(this, "name", void 0);
    this.name = name;
  }
  getItem(key) {
    return localStorage.getItem(`${PREFIX}/${this.name}/${key}`);
  }
  setItem(key, value) {
    return localStorage.setItem(`${PREFIX}/${this.name}/${key}`, value);
  }
  removeItem(key) {
    return localStorage.removeItem(`${PREFIX}/${this.name}/${key}`);
  }
}
function createLocalStorage(name) {
  return new LocalStorage(name);
}

class WalletConnectHandler extends EventEmitter {}

const STORAGE_URI_KEY = "storage_uri_key";
var _wcMetadata$1 = /*#__PURE__*/new WeakMap();
var _wcWallet$2 = /*#__PURE__*/new WeakMap();
var _activeSessionPayload = /*#__PURE__*/new WeakMap();
var _activeCallRequest = /*#__PURE__*/new WeakMap();
var _storage = /*#__PURE__*/new WeakMap();
var _sessionStorage = /*#__PURE__*/new WeakMap();
var _init = /*#__PURE__*/new WeakSet();
var _parseTxParams = /*#__PURE__*/new WeakSet();
var _setupWalletConnectEventsListeners$2 = /*#__PURE__*/new WeakSet();
class WalletConnectV1Handler extends WalletConnectHandler {
  constructor(options) {
    super();
    _classPrivateMethodInitSpec(this, _setupWalletConnectEventsListeners$2);
    _classPrivateMethodInitSpec(this, _parseTxParams);
    _classPrivateMethodInitSpec(this, _init);
    _classPrivateFieldInitSpec(this, _wcMetadata$1, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _wcWallet$2, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _activeSessionPayload, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _activeCallRequest, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _storage, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _sessionStorage, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet(this, _wcMetadata$1, options?.walletConnectWalletMetadata || {
      name: "Thirdweb Smart Wallet",
      description: "Thirdweb Smart Wallet",
      url: "https://thirdweb.com",
      icons: ["https://thirdweb.com/favicon.ico"]
    });
    _classPrivateFieldSet(this, _storage, options.storage);
    _classPrivateFieldSet(this, _sessionStorage, new SessionStorage(options.storage));
  }
  async init() {
    const uri = _classPrivateFieldGet(this, _storage).getItem(STORAGE_URI_KEY);
    if (uri) {
      _classPrivateMethodGet(this, _init, _init2).call(this, uri);
    }
    return Promise.resolve();
  }
  async connectApp(uri) {
    if (!_classPrivateFieldGet(this, _wcWallet$2)) {
      _classPrivateFieldGet(this, _storage).setItem(STORAGE_URI_KEY, uri);
      _classPrivateMethodGet(this, _init, _init2).call(this, uri);
    }
    return Promise.resolve();
  }
  async approveSession(wallet) {
    if (!_classPrivateFieldGet(this, _wcWallet$2)) {
      throw new Error("Please, init the wallet before making session requests.");
    }
    const address = await wallet.getAddress();
    const chainId = await wallet.getChainId();
    await _classPrivateFieldGet(this, _wcWallet$2).approveSession({
      accounts: [address],
      chainId: chainId
    });
    this.emit("session_approved");
    return Promise.resolve();
  }
  rejectSession() {
    if (!_classPrivateFieldGet(this, _wcWallet$2)) {
      throw new Error("Please, init the wallet before making session requests.");
    }
    _classPrivateFieldGet(this, _wcWallet$2).rejectSession();
    return Promise.resolve();
  }
  async approveEIP155Request(wallet) {
    const {
      params,
      method
    } = _classPrivateFieldGet(this, _activeCallRequest);
    try {
      let result;
      switch (method) {
        case EIP155_SIGNING_METHODS.ETH_SIGN:
          const ethMsg = params[1];
          result = await wallet.signMessage(utils.arrayify(ethMsg));
          break;
        case EIP155_SIGNING_METHODS.PERSONAL_SIGN:
          const message = params[0];
          result = await wallet.signMessage(utils.arrayify(message));
          break;
        case EIP155_SIGNING_METHODS.ETH_SEND_TRANSACTION:
          const chainId = await wallet.getChainId();
          const signer = await wallet.getSigner();
          const tx = await signer.sendTransaction(_classPrivateMethodGet(this, _parseTxParams, _parseTxParams2).call(this, params, chainId));
          const {
            transactionHash
          } = await tx.wait();
          result = transactionHash;
          break;
        case EIP155_SIGNING_METHODS.ETH_SIGN_TRANSACTION:
          const chainIdSign = await wallet.getChainId();
          const signerSign = await wallet.getSigner();
          const txParams = await signerSign.populateTransaction(_classPrivateMethodGet(this, _parseTxParams, _parseTxParams2).call(this, params, chainIdSign));
          result = await signerSign.signTransaction(txParams);
          break;
        case EIP155_SIGNING_METHODS.SWITCH_CHAIN:
          {
            await wallet.switchChain(params[0].chainId);
            result = params[0].chainId;
            break;
          }
      }
      _classPrivateFieldGet(this, _wcWallet$2)?.approveRequest({
        id: _classPrivateFieldGet(this, _activeCallRequest)?.id,
        result
      });
    } catch (error) {
      let message;
      if (error instanceof Error) {
        message = error.message;
      } else {
        message = `Error executing the method: ${method}`;
      }
      _classPrivateFieldGet(this, _wcWallet$2)?.rejectRequest({
        id: _classPrivateFieldGet(this, _activeCallRequest)?.id,
        error: {
          message
        }
      });
    }
    return Promise.resolve();
  }
  rejectEIP155Request() {
    _classPrivateFieldGet(this, _wcWallet$2)?.rejectRequest({
      id: 1,
      error: {
        message: "Rejected by user"
      }
    });
    return Promise.resolve();
  }
  getActiveSessions() {
    const session = _classPrivateFieldGet(this, _wcWallet$2)?.session;
    if (!session) {
      return [];
    }
    const result = [{
      topic: session?.clientId,
      peer: {
        metadata: session.peerMeta ? session.peerMeta : {
          name: "Thirdweb Powered Wallet",
          description: "Thirdweb Powered Wallet",
          url: "https://thirdweb.com",
          icons: ["https://thirdweb.com/favicon.ico"]
        }
      }
    }];
    return result;
  }
  async disconnectSession() {
    _classPrivateFieldGet(this, _wcWallet$2)?.killSession();
    _classPrivateFieldGet(this, _wcWallet$2)?.off("session_request");
    _classPrivateFieldGet(this, _wcWallet$2)?.off("call_request");
    _classPrivateFieldGet(this, _wcWallet$2)?.off("disconnect");
    _classPrivateFieldGet(this, _storage).removeItem(STORAGE_URI_KEY);
    _classPrivateFieldSet(this, _wcWallet$2, undefined);
    this.emit("session_delete");
    return Promise.resolve();
  }
}
function _init2(uri) {
  _classPrivateFieldSet(this, _wcWallet$2, new WalletConnect({
    uri: uri,
    clientMeta: _classPrivateFieldGet(this, _wcMetadata$1),
    storage: _classPrivateFieldGet(this, _sessionStorage)
  }));
  _classPrivateMethodGet(this, _setupWalletConnectEventsListeners$2, _setupWalletConnectEventsListeners2$2).call(this);
}
function _parseTxParams2(params, chainId) {
  let txParams = {
    from: params[0].from,
    data: params[0].data,
    chainId: chainId
  };
  if (params[0].gas) {
    txParams = {
      ...txParams,
      gasLimit: params[0].gas
    };
  }
  if (params[0].to) {
    txParams = {
      ...txParams,
      to: params[0].to
    };
  }
  return txParams;
}
function _setupWalletConnectEventsListeners2$2() {
  if (!_classPrivateFieldGet(this, _wcWallet$2)) {
    throw new Error("Please, init the wallet before making session requests.");
  }

  // Subscribe to session requests
  _classPrivateFieldGet(this, _wcWallet$2).on("session_request", (error, payload) => {
    if (error) {
      throw new Error(`WCV1H.session_request error: ${error.message}`);
    }
    _classPrivateFieldSet(this, _activeSessionPayload, payload);
    this.emit("session_proposal", {
      proposer: {
        metadata: payload.params[0].peerMeta
      }
    });
  });

  // Subscribe to call requests
  _classPrivateFieldGet(this, _wcWallet$2).on("call_request", (error, payload) => {
    if (error) {
      throw new Error(`WCV1H.call_request error: ${error.message}`);
    }
    const {
      params,
      method
    } = payload;
    _classPrivateFieldSet(this, _activeCallRequest, payload);
    switch (method) {
      case EIP155_SIGNING_METHODS.ETH_SIGN:
      case EIP155_SIGNING_METHODS.PERSONAL_SIGN:
        const message = params[0];
        const decodedMessage = new TextDecoder().decode(utils.arrayify(message));
        const paramsCopy = [...params];
        paramsCopy[0] = decodedMessage;
        this.emit("session_request", {
          topic: params[1],
          params: paramsCopy,
          peer: {
            metadata: _classPrivateFieldGet(this, _activeSessionPayload).params[0].peerMeta
          },
          method: method
        });
        return;
      case EIP155_SIGNING_METHODS.SWITCH_CHAIN:
        const chain = params[0]; // {"chainId":"0x13881"}
        const chainId = parseInt(chain.chainId, 16);
        chain.chainId = chainId;
        const paramsCopyWithChain = [...params];
        paramsCopyWithChain[0] = chain;
        this.emit("session_request", {
          topic: params[1],
          params: paramsCopyWithChain,
          peer: {
            metadata: _classPrivateFieldGet(this, _activeSessionPayload).params[0].peerMeta
          },
          method: method
        });
        return;
      case EIP155_SIGNING_METHODS.ETH_SEND_TRANSACTION:
      case EIP155_SIGNING_METHODS.ETH_SIGN_TRANSACTION:
        this.emit("session_request", {
          topic: method,
          params: params,
          peer: {
            metadata: _classPrivateFieldGet(this, _activeSessionPayload).params[0].peerMeta
          },
          method: method
        });
        return;
      default:
        throw new Error(`WalletConnectV1Handler.call_request. Method not implemented: ${method}`);
    }
  });
  _classPrivateFieldGet(this, _wcWallet$2).on("disconnect", error => {
    if (error) {
      throw new Error(`WCV1H.disconnect error: ${error.message}`);
    }
    this.disconnectSession();
  });
}
var _storage2 = /*#__PURE__*/new WeakMap();
class SessionStorage {
  constructor(storage) {
    _classPrivateFieldInitSpec(this, _storage2, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet(this, _storage2, storage);
  }
  getSession() {
    const session = _classPrivateFieldGet(this, _storage2).getItem("session");
    if (!session) {
      return null;
    }
    const sessionObj = JSON.parse(session);
    return sessionObj;
  }
  setSession(session) {
    _classPrivateFieldGet(this, _storage2).setItem("session", JSON.stringify(session));
    return session;
  }
  removeSession() {
    _classPrivateFieldGet(this, _storage2).removeItem("session");
  }
}

var _core = /*#__PURE__*/new WeakMap();
var _wcWallet$1 = /*#__PURE__*/new WeakMap();
var _session = /*#__PURE__*/new WeakMap();
var _wcMetadata = /*#__PURE__*/new WeakMap();
var _activeProposal = /*#__PURE__*/new WeakMap();
var _activeRequestEvent = /*#__PURE__*/new WeakMap();
var _setupWalletConnectEventsListeners$1 = /*#__PURE__*/new WeakSet();
var _getSignParamsMessage = /*#__PURE__*/new WeakSet();
class WalletConnectV2Handler extends WalletConnectHandler {
  constructor(options) {
    super();
    /**
     * Gets message from various signing request methods by filtering out
     * a value that is not an address (thus is a message).
     * If it is a hex string, it gets converted to utf8 string
     */
    _classPrivateMethodInitSpec(this, _getSignParamsMessage);
    _classPrivateMethodInitSpec(this, _setupWalletConnectEventsListeners$1);
    _classPrivateFieldInitSpec(this, _core, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _wcWallet$1, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _session, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _wcMetadata, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _activeProposal, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _activeRequestEvent, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet(this, _wcMetadata, options?.walletConnectWalletMetadata || {
      name: "Thirdweb Smart Wallet",
      description: "Thirdweb Smart Wallet",
      url: "https://thirdweb.com",
      icons: ["https://thirdweb.com/favicon.ico"]
    });
    _classPrivateFieldSet(this, _core, new Core({
      projectId: options?.walletConenctV2ProjectId || TW_WC_PROJECT_ID,
      relayUrl: options?.walletConnectV2RelayUrl || WC_RELAY_URL
    }));
  }
  async init() {
    _classPrivateFieldSet(this, _wcWallet$1, await Web3Wallet.init({
      core: _classPrivateFieldGet(this, _core),
      metadata: _classPrivateFieldGet(this, _wcMetadata)
    }));
    const sessions = _classPrivateFieldGet(this, _wcWallet$1).getActiveSessions();
    const keys = Object.keys(sessions);
    if (keys.length > 0) {
      _classPrivateFieldSet(this, _session, sessions[keys[0]]);
    }
    _classPrivateMethodGet(this, _setupWalletConnectEventsListeners$1, _setupWalletConnectEventsListeners2$1).call(this);
  }
  async connectApp(wcUri) {
    if (!_classPrivateFieldGet(this, _wcWallet$1)) {
      throw new Error("Please, init the wallet before connecting an app.");
    }
    await _classPrivateFieldGet(this, _wcWallet$1).core.pairing.pair({
      uri: wcUri
    });
  }
  async approveSession(wallet) {
    if (!_classPrivateFieldGet(this, _wcWallet$1)) {
      throw new Error("Please, init the wallet before making session requests.");
    }
    if (!_classPrivateFieldGet(this, _activeProposal)) {
      throw new Error("Please, pass a valid proposal.");
    }
    const account = await wallet.getAddress();
    const {
      id,
      params
    } = _classPrivateFieldGet(this, _activeProposal);
    const {
      requiredNamespaces,
      relays
    } = params;
    const namespaces = {};
    Object.keys(requiredNamespaces).forEach(key => {
      const accounts = [];
      requiredNamespaces[key].chains?.map(chain => {
        accounts.push(`${chain}:${account}`);
      });
      namespaces[key] = {
        accounts,
        methods: requiredNamespaces[key].methods,
        events: requiredNamespaces[key].events
      };
    });
    _classPrivateFieldSet(this, _session, await _classPrivateFieldGet(this, _wcWallet$1).approveSession({
      id,
      relayProtocol: relays[0].protocol,
      namespaces
    }));
    this.emit("session_approved");
  }
  async rejectSession() {
    if (!_classPrivateFieldGet(this, _wcWallet$1)) {
      throw new Error("Please, init the wallet before making session requests.");
    }
    if (!_classPrivateFieldGet(this, _activeProposal)) {
      throw new Error("Please, pass a valid proposal.");
    }
    const {
      id
    } = _classPrivateFieldGet(this, _activeProposal);
    await _classPrivateFieldGet(this, _wcWallet$1).rejectSession({
      id,
      reason: {
        message: "User rejected methods.",
        code: 5002
      }
    });
  }
  async approveEIP155Request(wallet) {
    if (!_classPrivateFieldGet(this, _activeRequestEvent)) {
      return;
    }
    const {
      topic,
      params,
      id
    } = _classPrivateFieldGet(this, _activeRequestEvent);
    const {
      request
    } = params;
    let response;
    switch (request.method) {
      case EIP155_SIGNING_METHODS.PERSONAL_SIGN:
      case EIP155_SIGNING_METHODS.ETH_SIGN:
        const message = _classPrivateMethodGet(this, _getSignParamsMessage, _getSignParamsMessage2).call(this, request.params);
        const signedMessage = await wallet.signMessage(message);
        response = formatJsonRpcResult(id, signedMessage);
        break;
      // case EIP155_SIGNING_METHODS.ETH_SIGN_TYPED_DATA:
      // case EIP155_SIGNING_METHODS.ETH_SIGN_TYPED_DATA_V3:
      // case EIP155_SIGNING_METHODS.ETH_SIGN_TYPED_DATA_V4:
      //   const {
      //     domain,
      //     types,
      //     message: data,
      //   } = getSignTypedDataParamsData(request.params);
      //   // https://github.com/ethers-io/ethers.js/issues/687#issuecomment-714069471
      //   delete types.EIP712Domain;
      //   const signedData = await wallet._signTypedData(domain, types, data);
      //   return formatJsonRpcResult(id, signedData);
      case EIP155_SIGNING_METHODS.ETH_SEND_TRANSACTION:
        const signer = await wallet.getSigner();
        const sendTransaction = request.params[0];
        const tx = await signer.sendTransaction(sendTransaction);
        const {
          transactionHash
        } = await tx.wait();
        response = formatJsonRpcResult(id, transactionHash);
        break;
      case EIP155_SIGNING_METHODS.ETH_SIGN_TRANSACTION:
        const signerSign = await wallet.getSigner();
        const signTransaction = request.params[0];
        const signature = await signerSign.signTransaction(signTransaction);
        response = formatJsonRpcResult(id, signature);
      default:
        const error = {
          id,
          jsonrpc: "2.0",
          error: {
            message: "Invalid event.",
            code: 1002
          }
        };
        return _classPrivateFieldGet(this, _wcWallet$1)?.respondSessionRequest({
          topic,
          response: error
        });
    }
    return _classPrivateFieldGet(this, _wcWallet$1)?.respondSessionRequest({
      topic,
      response
    });
  }
  async rejectEIP155Request() {
    if (!_classPrivateFieldGet(this, _activeRequestEvent)) {
      return;
    }
    const {
      topic,
      id
    } = _classPrivateFieldGet(this, _activeRequestEvent);
    const response = {
      id,
      jsonrpc: "2.0",
      error: {
        message: "User rejected methods.",
        code: 5002
      }
    };
    return _classPrivateFieldGet(this, _wcWallet$1)?.respondSessionRequest({
      topic,
      response
    });
  }
  getActiveSessions() {
    if (!_classPrivateFieldGet(this, _wcWallet$1)) {
      throw new Error("Please, init the wallet before getting sessions.");
    }
    const sessions = _classPrivateFieldGet(this, _wcWallet$1).getActiveSessions();
    const sessionKeys = Object.keys(sessions);
    if (!sessions || sessionKeys.length === 0) {
      return [];
    }
    const thisSessions = [];
    for (const sessionKey of sessionKeys) {
      const topic = sessions[sessionKey].topic;
      const peerMeta = sessions[sessionKey].peer.metadata;
      thisSessions.push({
        topic,
        peer: {
          metadata: peerMeta
        }
      });
    }
    return thisSessions;
  }
  disconnectSession() {
    if (!_classPrivateFieldGet(this, _wcWallet$1)) {
      throw new Error("Please, init the wallet before disconnecting sessions.");
    }
    if (!_classPrivateFieldGet(this, _session)) {
      return Promise.resolve();
    }
    const params = {
      topic: _classPrivateFieldGet(this, _session).topic,
      reason: {
        message: "User disconnected.",
        code: 6000
      }
    };
    return _classPrivateFieldGet(this, _wcWallet$1)?.disconnectSession(params);
  }
}
function _setupWalletConnectEventsListeners2$1() {
  if (!_classPrivateFieldGet(this, _wcWallet$1)) {
    throw new Error("Please, init the wallet before making session requests.");
  }
  _classPrivateFieldGet(this, _wcWallet$1).on("session_proposal", proposal => {
    _classPrivateFieldSet(this, _activeProposal, proposal);
    this.emit("session_proposal", {
      proposer: {
        metadata: proposal.params.proposer.metadata
      }
    });
  });
  _classPrivateFieldGet(this, _wcWallet$1).on("session_delete", session => {
    _classPrivateFieldSet(this, _session, undefined);
    _classPrivateFieldSet(this, _activeProposal, undefined);
    this.emit("session_delete", {
      topic: session.topic
    });
  });
  _classPrivateFieldGet(this, _wcWallet$1).on("session_request", async requestEvent => {
    if (!_classPrivateFieldGet(this, _session)) {
      return;
    }
    const {
      params: requestParams
    } = requestEvent;
    const {
      request
    } = requestParams;
    const {
      params
    } = request;
    switch (request.method) {
      case EIP155_SIGNING_METHODS.ETH_SIGN:
      case EIP155_SIGNING_METHODS.PERSONAL_SIGN:
        _classPrivateFieldSet(this, _activeRequestEvent, requestEvent);
        const message = params[0];
        const decodedMessage = new TextDecoder().decode(utils.arrayify(message));
        const paramsCopy = [...params];
        paramsCopy[0] = decodedMessage;
        this.emit("session_request", {
          topic: _classPrivateFieldGet(this, _session).topic,
          params: paramsCopy,
          peer: {
            metadata: _classPrivateFieldGet(this, _session).peer.metadata
          },
          method: request.method
        });
        return;
      case EIP155_SIGNING_METHODS.ETH_SEND_TRANSACTION:
      case EIP155_SIGNING_METHODS.ETH_SIGN_TRANSACTION:
        _classPrivateFieldSet(this, _activeRequestEvent, requestEvent);
        this.emit("session_request", {
          topic: _classPrivateFieldGet(this, _session).topic,
          params: requestEvent.params.request.params,
          peer: {
            metadata: _classPrivateFieldGet(this, _session).peer.metadata
          },
          method: request.method
        });
        return;
      default:
        throw new Error(`WCV2.Method not supported: ${request.method}`);
    }
  });
}
function _getSignParamsMessage2(params) {
  const message = params.filter(p => !utils.isAddress(p))[0];
  if (utils.isHexString(message)) {
    return utils.toUtf8String(message);
  }
  return message;
}

class NoOpWalletConnectHandler extends WalletConnectHandler {
  init() {
    return Promise.resolve();
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  connectApp(uri) {
    return Promise.resolve();
  }
  approveSession(
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  wallet) {
    return Promise.resolve();
  }
  rejectSession() {
    return Promise.resolve();
  }
  approveEIP155Request(
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  wallet) {
    return Promise.resolve();
  }
  rejectEIP155Request() {
    return Promise.resolve();
  }
  getActiveSessions() {
    return [];
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  disconnectSession() {
    return Promise.resolve();
  }
}

const sdkCache = new Map();
function getSDK(chain) {
  const cached = sdkCache.get(chain);
  if (cached) {
    return cached;
  }
  const sdk = new ThirdwebSDK(chain);
  sdkCache.set(chain, sdk);
  return sdk;
}

/**
 * Get all the signers added to the given smart wallet (excluding owner)
 * @param chain
 * @param factoryAddress
 * @param smartWalletAddress
 * @returns
 */
async function getAllSigners(chain, factoryAddress, smartWalletAddress) {
  const readOnlySDK = getSDK(chain);
  const factoryContract = await readOnlySDK.getContract(factoryAddress);
  const signers = await factoryContract.call("getSignersOfAccount", [smartWalletAddress]);
  return signers;
}

/**
 * Get all the smart wallets associated with a personal wallet address
 * @param chain
 * @param factoryAddress
 * @param personalWalletAddress
 * @returns
 */
async function getAllSmartWallets(chain, factoryAddress, personalWalletAddress) {
  const readOnlySDK = getSDK(chain);
  const factoryContract = await readOnlySDK.getContract(factoryAddress);
  const ownedAccount = await getSmartWalletAddress(chain, factoryAddress, personalWalletAddress);
  const accessibleAccounts = await factoryContract.call("getAccountsOfSigner", [personalWalletAddress]);
  return {
    owned: ownedAccount,
    hasSignerRole: accessibleAccounts
  };
}

/**
 * Check if a smart wallet is deployed for a given personal wallet address
 * @param chain
 * @param factoryAddress
 * @param personalWalletAddress
 * @returns
 */
async function isSmartWalletDeployed(chain, factoryAddress, personalWalletAddress) {
  const readOnlySDK = getSDK(chain);
  const factoryContract = await readOnlySDK.getContract(factoryAddress);
  const accountAddress = await factoryContract.call("getAddress", [personalWalletAddress]);
  const isDeployed = await isContractDeployed(accountAddress, readOnlySDK.getProvider());
  return isDeployed;
}

/**
 * Get the associated smart wallet address for a given personal wallet address
 * @param chain
 * @param factoryAddress
 * @param personalWalletAddress
 * @returns
 */
async function getSmartWalletAddress(chain, factoryAddress, personalWalletAddress) {
  const readOnlySDK = getSDK(chain);
  const factoryContract = await readOnlySDK.getContract(factoryAddress);
  const accountAddress = await factoryContract.call("getAddress", [personalWalletAddress]);
  return accountAddress;
}

var _wcWallet = /*#__PURE__*/new WeakMap();
var _setupWalletConnectEventsListeners = /*#__PURE__*/new WeakSet();
class SmartWallet extends AbstractClientWallet {
  get walletName() {
    return "Smart Wallet";
  }
  constructor(options) {
    super(SmartWallet.id, {
      ...options
    });
    _classPrivateMethodInitSpec(this, _setupWalletConnectEventsListeners);
    _defineProperty(this, "connector", void 0);
    _defineProperty(this, "enableConnectApp", false);
    _classPrivateFieldInitSpec(this, _wcWallet, {
      writable: true,
      value: void 0
    });
    this.enableConnectApp = options?.enableConnectApp || false;
    _classPrivateFieldSet(this, _wcWallet, this.enableConnectApp ? options?.wcVersion === "v1" ? new WalletConnectV1Handler({
      walletConnectWalletMetadata: options?.walletConnectWalletMetadata,
      walletConenctV2ProjectId: options?.walletConenctV2ProjectId,
      walletConnectV2RelayUrl: options?.walletConnectV2RelayUrl,
      storage: options?.wcStorage || createLocalStorage("smart-wallet")
    }) : new WalletConnectV2Handler({
      walletConnectWalletMetadata: options?.walletConnectWalletMetadata,
      walletConenctV2ProjectId: options?.walletConenctV2ProjectId,
      walletConnectV2RelayUrl: options?.walletConnectV2RelayUrl
    }) : new NoOpWalletConnectHandler());
  }
  async getConnector() {
    if (!this.connector) {
      if (this.enableConnectApp) {
        await _classPrivateFieldGet(this, _wcWallet).init();
        _classPrivateMethodGet(this, _setupWalletConnectEventsListeners, _setupWalletConnectEventsListeners2).call(this);
      }
      const {
        SmartWalletConnector
      } = await import('../evm/connectors/smart-wallet/dist/thirdweb-dev-wallets-evm-connectors-smart-wallet.browser.esm.js');
      this.connector = new SmartWalletConnector(this.options);
    }
    return this.connector;
  }
  getPersonalWallet() {
    return this.connector?.personalWallet;
  }

  /**
   * Execute a single transaction
   * @param transactions
   * @returns the transaction receipt
   */
  async execute(transaction) {
    const connector = await this.getConnector();
    return connector.execute(transaction);
  }

  /**
   * Execute multiple transactions in a single batch
   * @param transactions
   * @returns the transaction receipt
   */
  async executeBatch(transactions) {
    const connector = await this.getConnector();
    return connector.executeBatch(transactions);
  }

  /**
   * Manually deploy the smart wallet contract. If already deployed this will throw an error.
   * Note that this is not necessary as the smart wallet will be deployed automatically on the first transaction the user makes.
   * @returns the transaction receipt
   */
  async deploy() {
    const connector = await this.getConnector();
    return connector.deploy();
  }

  /**
   * Check if the smart wallet contract is deployed
   * @returns true if the smart wallet contract is deployed
   */
  async isDeployed() {
    const connector = await this.getConnector();
    return connector.isDeployed();
  }
  autoConnect(params) {
    return this.connect(params);
  }

  // wcv2
  async connectApp(uri) {
    if (!this.enableConnectApp) {
      throw new Error("enableConnectApp is set to false in this wallet config");
    }
    _classPrivateFieldGet(this, _wcWallet)?.connectApp(uri);
  }
  async approveSession() {
    await _classPrivateFieldGet(this, _wcWallet).approveSession(this);
    this.emit("message", {
      type: "session_approved"
    });
  }
  rejectSession() {
    return _classPrivateFieldGet(this, _wcWallet).rejectSession();
  }
  approveRequest() {
    return _classPrivateFieldGet(this, _wcWallet).approveEIP155Request(this);
  }
  rejectRequest() {
    return _classPrivateFieldGet(this, _wcWallet).rejectEIP155Request();
  }
  getActiveSessions() {
    if (!_classPrivateFieldGet(this, _wcWallet)) {
      throw new Error("Please, init the wallet before making session requests.");
    }
    return _classPrivateFieldGet(this, _wcWallet).getActiveSessions();
  }
  disconnectSession() {
    return _classPrivateFieldGet(this, _wcWallet)?.disconnectSession();
  }
  isWCReceiverEnabled() {
    return this.enableConnectApp;
  }
}
function _setupWalletConnectEventsListeners2() {
  if (!_classPrivateFieldGet(this, _wcWallet)) {
    throw new Error("Please, init the wallet before making session requests.");
  }
  _classPrivateFieldGet(this, _wcWallet).on("session_proposal", proposal => {
    this.emit("message", {
      type: "session_proposal",
      data: proposal
    });
  });
  _classPrivateFieldGet(this, _wcWallet).on("session_delete", () => {
    this.emit("message", {
      type: "session_delete"
    });
  });
  _classPrivateFieldGet(this, _wcWallet).on("switch_chain", request => {
    const chainId = request.params[0].chainId;
    this.emit("message", {
      type: "switch_chain",
      data: {
        chainId
      }
    });
    _classPrivateFieldGet(this, _wcWallet).disconnectSession();
  });
  _classPrivateFieldGet(this, _wcWallet).on("session_request", request => {
    this.emit("message", {
      type: "session_request",
      data: request
    });
  });
}
_defineProperty(SmartWallet, "meta", {
  name: "Smart Wallet",
  iconURL: "ipfs://QmeAJVqn17aDNQhjEU3kcWVZCFBrfta8LzaDGkS8Egdiyk/smart-wallet.svg"
});
_defineProperty(SmartWallet, "id", walletIds.smartWallet);

export { LocalStorage as L, SmartWallet as S, WalletConnectV1Handler as W, WalletConnectV2Handler as a, WalletConnectHandler as b, createLocalStorage as c, getAllSmartWallets as d, getSmartWalletAddress as e, getAllSigners as g, isSmartWalletDeployed as i };
